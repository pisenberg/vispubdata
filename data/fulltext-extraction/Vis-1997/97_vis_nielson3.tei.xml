<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Computing the Separating Surface for Segmented Data</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><forename type="middle">M</forename><surname>Nielson</surname></persName>
							<email>nielson@asu.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Computer Science and Engineering</orgName>
								<orgName type="institution">Arizona State University Tempe</orgName>
								<address>
									<postCode>85287-5406</postCode>
									<region>AZ</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Richard</forename><surname>Franke</surname></persName>
							<email>rfranke@nps.navy.mil</email>
							<affiliation key="aff1">
								<orgName type="department">Mathematics Naval Postgraduate School Monterey</orgName>
								<address>
									<postCode>93943-5216</postCode>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Computing the Separating Surface for Segmented Data</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:36+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>An algorithm for computing a triangulated surface which separates a collection of data points that have been segmented into a number of different classes is presented. The problem generalizes the concept of an isosurface which separates data points that have been segmented into only two classes: those for which data function values are above the threshold and those which are below the threshold value. The algorithm is very simple, easy to implement and applies without limit to the number of classes.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction and Algorithm</head><p>In this paper we describe an algorithm for computing a triangulated surface which separates regions of different types. We assume that we have a collection of data points</p><formula xml:id="formula_0">n i V i ,..., 1 , =</formula><p>and that each of these data points has been classified into one of several possible classes M i c i ,...,</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">, =</head><p>. This includes, for example, medical scanning device data that has been postprocessed by some segmentation procedure into different tissues or organ classes or physical simulation data that has been classified by material properties such solid, liquid or gas. For our algorithm, we assume that the data points i V are the vertices of a tetrahedrization of the domain of interest. Two important application areas are where the data points lie on a 3D rectilinear grid or 3D curvilinear grid. In either case we preprocess the data by subdividing each voxel or hexahedron (curvilinear grid cell) into tetrahedra and proceed with our algorithm. See <ref type="figure" target="#fig_0">Figure 1</ref> and Nielson <ref type="bibr" target="#b3">[4]</ref>. Note that in the 6 tetrahedra split, each cube is split exactly as shown. In the 5 tetrahedra split, a rotated version of what is shown is used on alternating voxels so that adjoining diagonals line up properly. Our goal is to produce a triangulated surface which separates the components (connected subsets) of the regions,</p><formula xml:id="formula_1">M i R i ,..., 1 , =</formula><p>, each containing the data of type</p><formula xml:id="formula_2">M i c i ,..., 1 , = .</formula><p>This surface can be viewed as a generalization of the isosurface often associated with the marching cube algorithm (see <ref type="bibr" target="#b1">[2]</ref> and <ref type="bibr" target="#b4">[5]</ref>). In the context of the mc algorithm the discrete vertices lying on a 3D rectilinear grid are classified into only two possible classes: either the value of the data function, , δ is above the threshold of the isosurface or below this threshold. The isosurface then separates these two classes of data points into two regions. In the more general situation where there are several possible classes for data points, the separating surface is defined</p><formula xml:id="formula_3">as ) ( ,; ,... 1 , j j i M j i i R R S ∩ = ≠ = U</formula><p>. This, more general, separating surface is fundamentally different from an isosurface in that it may contain regions where three or more surface segments join (see <ref type="bibr" target="#b0">[1]</ref>).</p><p>This means that the data structures used for the representation of the triangular approximation must allow for three or more triangles to share a common edge. This is not necessary for the results of a valid mc type algorithm which can be represented with a triangular grid structure.</p><p>In the spirit of the mc algorithm, our algorithm sequentially "marches" through all the cells processing one at a time. In our case, a cell is a tetrahedron. Again, for the topological aspects of our algorithm, it is not important where exactly this point lies on the face, but some practical considerations which we discuss later lead to reasonable choices for this point. And finally if all four points are classified differently, we need to reference a point t m lying interior to the tetrahedron. This notation is further illustrated in <ref type="figure">Figure 2</ref>. <ref type="figure">Figure 2</ref>. Notation used for vertices, mid-edge, mid-face and mid-tetrahedron points.</p><formula xml:id="formula_4">Let i V , j V , k V , l V</formula><formula xml:id="formula_5">V i V j V k m ij m kj m t m ijk m ik</formula><p>The strength of our tetrahedral-based algorithm is its simplicity and subsequent ease of implementation. There are only five cases to be considered: (0) all vertices are classified as one type (trivial case; no separating surface intersects the tetrahedron), (1) three vertices are of one class and one other vertex is of another class, (2) two vertices are of one class and two vertices are of another class, (3) two vertices of one class and the other two vertices are of second and third classes, and (4) each vertex is of a different class. Because any configuration in one of these five cases can be rotated into a standard configuration, standardized algorithms can be used assuming that (local) vertices are labeled</p><formula xml:id="formula_6">k j i V V V , ,</formula><p>and</p><formula xml:id="formula_7">l V .</formula><p>The face of a tetrahedron having vertices of more than one type must be split. This can be seen in Figures 3, 4, 5 and 6 for the four nontrivial cases. When the vertices on a particular face of the tetrahedron are of only two types, the face is split along the line segment joining the mid-edge points on that face, say the points il m and jl m . This occurs in cases (1)-(3). When the vertices on a face are all three of a different type, the face must be split not only at the mid-edge points, but also at the mid-face point ijk m interior to this face. The face is then divided by the line segments joining the mid-face point to the mid-edge points. When four different types are present then we must involve the mid-tetrahedron point t m . The separating surface is to be represented as a union of triangles, so quadrilaterals that naturally occur in our algorithm must be triangulated by including one diagonal or the other. We adopt the convention that we will impose those diagonals that are consistent with a certain tetrahedrization of the four hexahedra that occur in case <ref type="bibr" target="#b3">(4)</ref>. See <ref type="figure" target="#fig_3">Figure 6</ref>. Since each hexahedron has a vertex of the cube as one vertex, we adopt the triangulation of the faces by diagonals from the tetrahedron vertices to the mid-face points, and the mid-edge points to the mid-tetrahedron point. We should point out that unless certain restrictions are put on the mid-edge, mid-face and mid-tetrahedron points, those quadrilaterals may not be planar. This causes no particular problem, although we note that the separating surface will be slightly different if different choices were made when triangulating those quadrilaterals.</p><p>In case <ref type="formula">3</ref>, there is a dilemma as to whether the exterior quadrilateral faces (</p><formula xml:id="formula_8">il jl j i m m V V , , ,</formula><p>and</p><formula xml:id="formula_9">ik jk j i m m V V , , ,</formula><p>in <ref type="bibr">Figure 5)</ref> would be divided from i V to jl m and i V to jk m , or from j V to il m and j V to ik m when tetrahedrizing the subvolumes. We have adopted the strategy that the order of the vertices in the description of the tetrahedrized volume will determine that; we choose i V or j V according to which has priority in the input list.</p><p>Because we maintain order when sorting the unique classes of vertices for a particular tetrahedron, symbolically the first vertex is</p><formula xml:id="formula_10">i V .</formula><p>Hence we diagonalize the interior separating quadrilaterals using the line segments through jkl m and il m , and jkl m and ik m .</p><p>In case (2), we again wish to be consistent with some tetrahedrization of the volumes, two triangular prisms in this case. Thus, we follow the rule of connecting the priority vertex to the opposite mid-edges for each prism, i.e., i V to jk m and jl m , and k V to il m and jl m . After this is done for each prism, it is seen that the diagonal on the separating quadrilateral is arbitrary, and we choose the jk m to il m segment.</p><p>For completeness we list the triangles comprising the separating surface in each case.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Case (1):</head><p>Triangle:   For the general description of our algorithm, we have kept the location of the mid-edge, mid-face and mid-tetrahedron points arbitrary. It is easy to present this way and also this allows for maximum flexibility. In some applications where there is no additional information on which to base any bias or adjustment, one just as well select these point to be the actual geometric midpoints. That is, In some other applications where there is additional information some weights may be used to compute these values. For example, if data points are classified (or segmented) on an interval of values of some data function, then it might be useful to weight accordingly the computation of the mid-edge value. Assume that an arbitrary point ) , , (</p><formula xml:id="formula_11">kl jl il m m m , ,</formula><formula xml:id="formula_12">z y x V =</formula><p>is classified by the rules: </p><formula xml:id="formula_13">V is of class α c provided m V ≤ ≤ ) ( δ α and V is of class β c provided β δ ≤ ≤ ) (V</formula><formula xml:id="formula_14">V V V m V V V V V m m         − − +         − − = ) ( ) ( ) ( ) ( ) ( ) ( δ δ δ δ δ δ .</formula><p>We have also used the following approach which is based upon the idea of a preference or probability matrix. </p><formula xml:id="formula_15">≠ = + , 1</formula><p>. The interpretation of the matrix P can be in terms of the "strength" of various classes relative to other classes, or it can be used to cause the separating surface to come close to (or stay further away from) certain classes of points. For example, it may be desirable to not overestimate the volume associated with a particular class, and in that case the values in the row of the matrix P associated with that class should be close to zero, forcing the separating surface close to the vertices of that class.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Examples</head><p>The first example has three regions. and classified the points on this grid according to the ideal. We then applied our algorithm, using the 5 tetrahedra per cube split. In this case we used the formulas of equation <ref type="formula">1</ref>for determining the mid-edge, mid-face and mid-tetrahedron points. The separating surface which is shown in <ref type="figure" target="#fig_5">Figure 7</ref> consists of 5,987 triangles. One of the features of our algorithm is that it is designed for scattered data. Our next example illustrates its use in that context. Because the algorithm we used tetrahedrized the convex hull, points near the boundary may be in tetrahedra with large aspect ratios.</p><p>This causes distortion around the boundaries, so in <ref type="figure" target="#fig_6">Figure 8</ref> the separating triangles near the boundary have been deleted. We note, however, that if the proper tetrahedrization is performed, the separating triangles could be processed using subsets of the entire data set because our algorithm guarantees a proper match across tetrahedron boundaries. For <ref type="figure" target="#fig_6">Figure 8</ref>, we generated 2000 random points in the region { }</p><formula xml:id="formula_16">1 1 , 1 1 , 1 2 . 0 : ) , , ( ≤ ≤ − ≤ ≤ − ≤ ≤ − z y x z y x</formula><p>. These points were then classified according to the same scheme as for the previous example. The point set was tetrahedrized (yielding 12,936 tetrahedra) and our algorithm applied with separating points being taken according to equation <ref type="bibr" target="#b0">(1)</ref>. The final separating surface consists of 2,661 triangles. A graph of it is shown in <ref type="figure" target="#fig_6">Figure 8</ref>. The separating surface is necessarily jagged, but the proper character is shown.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Summary and Remarks</head><p>The algorithm presented here applies to scattered data which has been tetrahedrized. This type of data is often also called unstructured data. We apply our algorithm to rectilinear data by forming a very simple tetrahedrization based upon decomposing each cell into 5 or 6 tetrahedra. One can deal directly with rectilinear grids using a very simple approach mention to us by J. van Wijk. It is based upon the cells with vertices at the centers (more generally the interior) of the original cells. These cells each contain a single original data point. The faces of adjacent cells which differ in classification form a separating surface.</p><p>Another approach which applies to rectilinear data is based upon the idea of generalizing the original mc algorithm to nonbinary classified data. As with the mc algorithm, case tables for the various configurations of classified vertices must be created. The number of equivalence classes of configurations (under rotations and possibly also reflections) for two and three classes of vertices on a cube is manageable, but for more than three classes a table lookup approach is probably not viable due to the large number of different configurations.</p><p>After much of this paper was completed reference <ref type="bibr" target="#b2">[3]</ref> came to our attention. This paper treats essentially the same problem from the point of view of constructing barriers for robot paths. While the scheme treats only rectilinear data, it does tetrahedrize the data so it would probably work essentially as described for scattered data. The way the separating surface is constructed is different from the present algorithm in all but case 4. For the other cases, the algorithm of <ref type="bibr" target="#b2">[3]</ref> simply removes the part of the surface in case 4 that does not separate different classes.</p><p>The algorithm presented here assumes that the data has been segmented into various classes and cannot be applied until this is accomplished. The problem of segmenting data is a highly nontrivial and currently unsolved problem. In no way does this present simple algorithm add to the solution of this problem, but possibly a more general algorithm which produces a tetrahedrized volume representation of the regions for different classes could be a useful tool in this regard. In a future paper, we will present such an algorithm.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Decomposing voxel data into tetrahedra data</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 .</head><label>3</label><figDesc>Case<ref type="bibr" target="#b0">(1)</ref>: Three vertices of one class and one vertex of another class.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 .Figure 5 .</head><label>45</label><figDesc>Case (2): Two vertices of one class and two vertices of another class. Case (3): Two vertices of one class and two other vertices each of another class.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 .</head><label>6</label><figDesc>Case (4): Each vertex is a different class.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 7 .</head><label>7</label><figDesc>An example with three regions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 8 .</head><label>8</label><figDesc>An example with three regions, random points.The final example has five different regions. These regions are defined relative to several conic surfaces, and the volumes are described sequentially, with a given class overriding a lower numbered one. Above the paraboloid the definitions of the various regions. Using the 6 tetrahedra per cube split, we ran our algorithm on this data using the P matrix Because of the dense set of separating triangles, the results are shown as a shaded object inFigure 9. The surface is comprised of 58,956 triangles.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 9 .</head><label>9</label><figDesc>A surface separating five regions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_3"><head></head><label></label><figDesc>Points below the plane and outside the sphere are in a second class and the points inside the sphere form the third class.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell>Points above the</cell></row><row><cell>plane</cell><cell>z</cell><cell>=</cell><cell>0</cell><cell cols="8">, and outside the sphere</cell><cell>x</cell><cell>2</cell><cell>+</cell><cell>y</cell><cell>2</cell><cell>+</cell><cell>z</cell><cell>2</cell><cell>=</cell><cell>. 0</cell><cell>25</cell><cell>, are of</cell></row><row><cell cols="6">one type. Over { 625 , . 0 025 . 0 : ) , , ( − ≤ ≤ − x z y x</cell><cell cols="2">0</cell><cell>.</cell><cell cols="2">625</cell><cell>≤</cell><cell>y</cell><cell cols="5">the 625 , . 0 − ≤</cell><cell>0</cell><cell>.</cell><cell>625</cell><cell>≤</cell><cell>z</cell><cell>domain } 625 . 0 ≤</cell></row><row><cell cols="5">we formed a grid of size</cell><cell cols="2">14</cell><cell cols="3">×</cell><cell>26</cell><cell>×</cell><cell cols="2">26</cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We wish to acknowledge the support of the National Aeronautical and Space Administration under NASA-Ames Grant, NAG 2-990 and the support of the Office of Naval Research under grant N00014-97-1-0243. The second author was on sabbatical leave from NPS.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Polygonization of Non-Manifold Implicit Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bloomenthal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Ferguson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="309" to="316" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Marching cubes: A high resolution 3D surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="163" to="169" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Boundary extraction for rasterized motion planning, in: Modeling and planning for Sensor Based Intelligent Robot Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Heinrich</forename><surname>Mueller</surname></persName>
		</author>
		<editor>Horst Bunke, Tankeo Kanade, and Hartmut Noltemeier</editor>
		<imprint>
			<date type="published" when="1995" />
			<publisher>World Scientific</publisher>
			<biblScope unit="page" from="41" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">M</forename><surname>Nielson</surname></persName>
		</author>
		<title level="m">Scientific Visualization: Overviews, Methodologies, and Techniques</title>
		<editor>M. Nielson, H. Mueller, and H. Hagen</editor>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1997" />
			<biblScope unit="page" from="422" to="526" />
		</imprint>
	</monogr>
	<note>Tools for triangulations and tetrahedrizations</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The Asymptotic Decider: Resolving The Ambiguity in Marching Cubes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">M</forename><surname>Nielson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;91</title>
		<meeting>Visualization &apos;91</meeting>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="83" to="90" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
