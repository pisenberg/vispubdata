<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">ROAMing Terrain: Real-time Optimally Adapting Meshes</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><surname>Duchaineau</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Los Alamos National Laboratory Lawrence Livermore National Laboratory y</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Murray</forename><surname>Wolinsky</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Los Alamos National Laboratory Lawrence Livermore National Laboratory y</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">E</forename><surname>Sigeti</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Los Alamos National Laboratory Lawrence Livermore National Laboratory y</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><forename type="middle">C</forename><surname>Miller</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Los Alamos National Laboratory Lawrence Livermore National Laboratory y</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><surname>Aldrich</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Los Alamos National Laboratory Lawrence Livermore National Laboratory y</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mark</forename><forename type="middle">B</forename><surname>Mineev-Weinstein</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Los Alamos National Laboratory Lawrence Livermore National Laboratory y</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">ROAMing Terrain: Real-time Optimally Adapting Meshes</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:35+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>I.3.3 [Computer Graphics]: Picture/Image Generation -Viewing Algorithms</term>
					<term>I.3.5 [Computer Graphics]: Computational Geometry and Object Modeling -Geometric Algorithms, Object Hierarchies</term>
					<term>I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism -Virtual Reality triangle bintree, view-dependent mesh, frame-to-frame coherence, greedy algorithms</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Terrain visualization is a difficult problem for applications requiring accurate images of large datasets at high frame rates, such as flight simulation and ground-based aircraft testing using synthetic sensor stimulation. On current graphics hardware, the problem is to maintain dynamic, view-dependent triangle meshes and texture maps that produce good images at the required frame rate. We present an algorithm for constructing triangle meshes that optimizes flexible view-dependent error metrics, produces guaranteed error bounds, achieves specified triangle counts directly, and uses frame-to-frame coherence to operate at high frame rates for thousands of triangles per frame. Our method, dubbed Real-time Optimally Adapting Meshes (ROAM), uses two priority queues to drive split and merge operations that maintain continuous triangulations built from preprocessed bintree triangles. We introduce two additional performance optimizations: incremental triangle stripping and prioritycomputation deferral lists. ROAM execution time is proportionate to the number of triangle changes per frame, which is typically a few percent of the output mesh size, hence ROAM performance is insensitive to the resolution and extent of the input terrain. Dynamic terrain and simple vertex morphing are supported.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>A complete system to display views of large datasets at high frame rates consists of components to manage disk paging of geometry and texture, level-of-detail (LOD) selection for texture blocks, LOD for triangle geometry, culling to the view frustum, and triangle stripping. This paper focuses on the last three of these components, which deal with in-memory geometry management.</p><p>During interactive visualizations, many types of geometric data compete for limited polygon budgets. Terrain remains one of the most challenging types because it is not naturally decomposed into parts whose complexity can be adjusted independently, and because the qualities required of a triangulation are view dependent. Classic geometry LOD optimization algorithms, such as those of Clark <ref type="bibr" target="#b0">[1]</ref> and Funkhouser and SÃ©quin <ref type="bibr" target="#b7">[7]</ref>, are not immediately applicable to terrain because they require independently adjustable parts. Traditional triangulation optimizations <ref type="bibr">[14, 2, 15,</ref> for example], do not apply directly to terrain visualization because they do not adfmurray,sigeti,cha,marinerg@lanl.gov, Los Alamos, NM y fduchaineau1,miller86g@llnl.gov, Livermore, CA mit flexible view-dependent error objectives, and they are much too slow to be used for each frame.</p><p>All of the existing algorithms that can interactively perform view-dependent, locally-adaptive terrain meshing <ref type="bibr" target="#b12">[12,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b17">17,</ref><ref type="bibr" target="#b19">19,</ref><ref type="bibr" target="#b10">10]</ref>, including ours, rely on a pre-defined multiresolution terrain representation that is used to build the adaptive triangle mesh for a frame. An example frame generated by the ROAM implementation is depicted in <ref type="figure" target="#fig_0">Figure 1</ref>, both with and without visible mesh edges. <ref type="figure" target="#fig_1">Figure 2</ref> shows a birds-eye view of the domain mesh. The mesh is typical for ROAM: neighborhoods that are flat or distant are triangulated more coarsely than close or rough neighborhoods.  1. recursive, incremental update to view-frustum culling 2. priority update only for output triangles that can potentially be split/merged in phase 3 3. triangulation update using greedy split and merge steps driven by two priority queues (for splits and merges, respectively) 4. as-needed updates for triangle strips affected by the culling changes from phase 1 and the splits/merges from phase 3</p><p>We evaluate our method with respect to twelve criteria of general application as follows:</p><p>1. Time required to achieve a given triangle count: Our implementation can maintain an optimized mesh containing thousands of triangles at 30 frames per second for high-speed, low-altitude flights over rough terrain. The algorithm's running time is proportionate to the number of triangle changes per frame, which is typically a few percent of the total mesh size. Hence ROAM performance is insensitive to terrain database extent and resolution (with the caveat that we must have all the data in memory in the current implementation).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Flexibility in choosing view-dependent error metrics:</head><p>ROAM uses maximum geometric distortion in screen space as a base metric and queue priority value. This metric can be enhanced in many ways: ensuring correct visibility along specified lines of site, providing correct terrain positions under objects, and eliminating back-facing detail are examples. 3. Mesh representations (both pre-defined and run-time selected): Our method uses a triangle bintree for precomputation, and builds continuous adaptive meshes by incremental, fine-grained split and merge steps. The triangles are always a right-isosceles shape, and therefore avoid the numerical problems of thin, "slivery" triangles. 4. Simplicity of algorithms: ROAM is simple to understand and implement because it is centered on split and merge operations of bintree triangles whose structure naturally avoids the complex case proliferation and legitimacy rules for selectively refining and coarsening within irregular or even quadtreestructured multiresolution spaces, and no special efforts are required to avoid discontinuities (cracks) and thin triangles. The greedy priority-queue technique that drives the splits and merges provides a simple mechanism for incorporating an extensible set of error-metric enhancements. 5. Quality of mesh at a given triangle count: Our algorithm produces optimal meshes in the sense of minimizing the maximum error bound for monotonic bounds (bounds that don't get larger after a split operation). Of course this optimum is achieved over our particular choice of mesh space, and larger or better spaces of triangle meshes certainly exist. Our results in actual tests are qualitatively excellent. 6. Direct control of triangle counts: ROAM produces meshes with a specified triangle count directly. Algorithms that admit only error tolerances can only indirectly control triangle counts by hunting for the corresponding error threshold, a process that is either slow or unreliable. ROAM can operate to achieve specified tolerances, but triangle-count specification is preferable for many applications. 7. Strict frame rates: ROAM can progressively optimize from frame to frame and stop when the frame time is about to expire (although typically only a fraction of the frame time is required). Our motivating application, aircraft sensor stimulation, requires a strict frame rate governed by the equipment under test. In conjunction with processor locking or real-time operating systems on multi-processor graphics systems, our implementation provides a strict frame rate at the highest triangle counts that the graphics hardware can handle reliably. 8. Guaranteed error bounds: ROAM produces guaranteed bounds on geometric screen-space distortions. These bounds are obtained locally by a fast conversion from preprocessed world-space bounds to view-dependent screen-space bounds, and globally by the greedy nature of the optimization algorithm. 9. Memory requirements: We distinguish between preprocess data size and runtime size. Our preprocess size is equal to the number of raw, finest-level height samples plus a single "thickness" value per bintree triangle. The runtime data structures take up space proportionate to the output mesh size, which is minuscule compared to the preprocess data size. 10. Dynamic terrain: Since our preprocessing is fast and localized, the preprocessed data can be updated quickly when the terrain is changed by mud slides, explosions, etc. 11. Reduced "popping": ROAM's use of a screen-distortion metric and its tendency to make very few mesh changes per frame naturally reduces disturbing temporal artifacts (pops).</p><p>In some cases it is desirable to reduce pops further by vertex morphing, which is easily incorporated in ROAM. 12. General input meshes: Although our motivating application and implementation focuses on terrain (in the form of a height field), ROAM's mesh structure applies to manifolds of arbitrary genus with boundary. A drawback of the bintree meshes we use, and more generally any subdivision surfaces, is that irregular input meshes must be approximated, albeit as closely as one likes <ref type="bibr" target="#b4">[4]</ref>.</p><p>In addition to these general criteria, ROAM was influenced by the specialized requirements of our motivating application, synthetic sensor stimulation for aircraft undergoing ground-based testing with hardware and human controllers in the loop. In this setting it is critical to query a runtime terrain data server for line-of-site (LOS) visibility tests, object positions, and so on in addition to the texture and triangle-mesh queries used for display to multiple sensors with differing viewpoints and requirements for accuracy and frame rate. Because of the approximations made to achieve high frame rates, the issues of consistency and correctness for the various queries becomes paramount. In earlier approaches, LOS and other queries are made with respect to a single current terrain approximation. This at least gives consistency to the various query responses, but requires a single "lowest common denominator" triangle mesh suitable for all views and sensor frame rates, thus degrading quality to unacceptable levels. The philosophy in ROAM is to give responses to LOS and position queries that are correct with respect to the finest-level input data, and constrain each of the view-dependent meshes to preserve the selected LOS visibilities and positions. The ROAM architecture efficiently supports this philosophy, and thus ensures consistency through correctness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>A general treatment of multiresolution LOD control is presented by Heckbert and Garland <ref type="bibr" target="#b8">[8]</ref>, while more specific surveys and references can be found in <ref type="bibr" target="#b3">[3,</ref><ref type="bibr" target="#b11">11,</ref><ref type="bibr" target="#b19">19]</ref>. Triangle stripping cost models and techniques are presented by Evans et al. <ref type="bibr" target="#b5">[5]</ref>. Greedy algorithms have been applied to terrain triangulation in the non-realtime, nonview-dependent setting <ref type="bibr">[6, 15, for example]</ref>. A general treatment of subdivision surfaces and conversions from irregular meshes is given by Eck et al. <ref type="bibr" target="#b4">[4]</ref>, while a specific application of wavelet analysis to terrain LOD is given by Staadt et al. <ref type="bibr" target="#b16">[16]</ref>. In the remainder of this section we give more detailed overviews of recent published work most closely related to ROAM.</p><p>Miller <ref type="bibr" target="#b12">[12]</ref> uses a quadtree to preprocess a height field defined on a uniform grid. In a pre-processing phase, vertices at each quadtree level are computed using an approximate least-squares fit to the level below. For each frame at run time, a priority queue drives quadtree refinement top-down from the root, thus allowing specified triangle counts to be achieved directly. The priority for a quadtree element is a heuristic involving view-independent (error in surface) and view-dependent (screen-area coverage) components aimed at minimizing the squared error in output image pixel intensities. No advantage is made of frame-to-frame coherence, and only one type of error metric is developed. A special effort is made to ensure continuous triangulations, but "T-vertices" are allowed, where a vertex exists on only one side of an edge. Methods for overlaying of point, linear and areal features are also discussed.</p><p>Lindstrom et al. <ref type="bibr" target="#b11">[11]</ref> choose the same space of continuous triangle-bintree meshes as we do. They do not recognize the simple bintree structure nor the split and merge operations that we present, and so must take special care to maintain mesh continuity. They obtain high frame rates for large output meshes using a bottom-up vertex-reduction methodology enhanced by an elegant block-LOD-reduction algorithm. The block-LOD updates are incremental, taking advantage of frame-to-frame and object-space coherence. However, the fine-grained vertex deletion is performed bottom-up, which tends to limit performance compared to our finegrained incremental mesh updates. Also, although they use the same base metric of geometric screen-space distortion, the blockbased optimizations appear to make it difficult to enhance this metric. They provide no guaranteed error bounds (only level-to-level displacements are considered in the fine-grained LOD reduction). A tolerance parameter is used to control the algorithm, but the lack of guaranteed bounds precludes guaranteed success in attaining the requested accuracy. A triangle-count parameter is not considered, and would be difficult to incorporate with their block-LOD algorithm (this precludes support for strict frame rates with maximum triangle counts). Memory requirements are similar to ROAM, and dynamic terrain is supported. Vertex morphing is not supported, and only height maps are considered. A recursive triangle-stripping method is described, but requires corner-turning and does not take advantage of frame-to-frame coherence.</p><p>Willis et al. <ref type="bibr" target="#b17">[17]</ref> describe a hierarchical triangulated-irregularnetwork (TIN) data structure with "near/far" annotations for vertex morphing, along with a queue-driven top-down refinement procedure for building the triangle mesh for a frame. No automatic procedure is given to build the precomputed TIN hierarchies and morphing annotations. No consideration is given to controlling errors or triangle counts. Specific effort is taken to avoid T-vertices. No advantage is taken of frame-to-frame coherence. Memory requirements are higher per preprocessed multiresolution element than in ROAM. The method applies to general base (coarsest-level) triangle meshes. The vertex-morphing capabilities are powerful and unique (we consider only simple split/merge animations).</p><p>Xia et al. and Hoppe <ref type="bibr" target="#b19">[19,</ref><ref type="bibr" target="#b10">10,</ref><ref type="bibr" target="#b18">18]</ref> give similar methods for interactive, fine-grained LOD control of general TIN input meshes based on view-dependent refinement of preprocessed progressive mesh representations <ref type="bibr" target="#b9">[9]</ref>. Both algorithms allow flexible viewdependent error metrics, and have demonstrated backface detail reduction based on nested Gauss-map normal bounds. Xia et al. use a base metric derived from the edge-collapse operations inherent to progressive meshes, which gives only a loose heuristic estimate of geometric or parametric screen-space distortions. Hoppe gives a metric that separates non-directional and normal-direction errors, and mentions the possibility of modifying this to measure errors in approximating non-linear texture-coordinate mappings. Progressive meshes are most naturally refined by undoing the edge-collapse operations in exactly the reverse order of the preprocess collapse sequence. Complex legitimacy rules are required to allow different refinement orders. Only tolerance parameters are given to the viewdependent refinement. In Xia et al., special consideration is taken to avoid thin triangles. Hoppe uses a feedback mechanism to perform rough frame-rate regulation. Nested bounds are provided by analyzing neighborhoods defined by the binary vertex trees formed during the preprocessing. Although some consideration is given to frame-to-frame coherence, execution times are still proportional to the full output mesh size. As a performance enhancement, Hoppe considers traversing the active vertices once over the course of multiple frames, but indicates that this complicates frame-rate regulation. Progressive-mesh preprocessing is organized as a global optimization process, and thus is too slow to support dynamic terrain. Animation of the edge collapse/expand operations reduces popping similar to vertex morphing, but introduces degenerate thin triangles temporarily in the process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">OVERVIEW</head><p>In the remainder of this paper we describe the ROAM mesh representation, optimization algorithm, error metrics, performance enhancements and results. In this section, we give an overview of what follows.</p><p>More fundamental than the ROAM algorithm itself is the dynamic mesh representation based on triangle bintrees. In Section 4 we define triangle bintrees and describe the split and merge operations that are used to maintain continuous meshes while adding and removing one vertex at a time. Animation of the splits and merges is presented as a simple method for obtaining temporal continuity. Applicability to surfaces with general topology is considered.</p><p>Given these fundamentals of the mesh representation, Section 5 goes on to describe the dual-queue incremental optimization algorithm. A simplified version of the algorithm is given first that uses only a single "split" priority queue. We explain why this top-down algorithm produces optimal bintree-based triangulations for monotonic priorities. A second "merge" priority queue is added to enable incremental optimizations for time-varying priorities.</p><p>ROAM uses view-independent, preprocessed error bounds to facilitate the computation of view-dependent error bounds. In Section 6, the metrics, preprocessing and view-dependent conversions are given. In world space, we rely on nested bounds using a single number per bintree triangle to define a "pie-wedge" bound shape. These wedgies are readily used to compute per-triangle bounds on screen-space distortions in the projected "up" direction. We also use wedgies to facilitate computations like view-frustum intersections and LOS tests. We consider various enhancements to the basic screen-space geometric distortion metric.</p><p>For ROAM to operate at high frame rates, several performance enhancements are needed. These are described in Section 7: incremental view-frustum culling, incremental T-stripping, deferring priority recomputations, and progressive optimization. Results from experiments with our implementation are given in Section 8. These show the effect of the performance enhancements as well as the overall behavior of the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">MESH REPRESENTATION</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Triangle Bintree</head><p>Just as the square-shaped quadtree has a triangle-quadtree counterpart, the familiar rectangle-shaped bintree <ref type="bibr" target="#b13">[13]</ref> has a little-known triangle-shaped counterpart. <ref type="figure" target="#fig_3">Figure 3</ref> shows the first few levels of a triangle bintree. The root triangle, T = ( v a ; v 0 ; v 1 ) , is defined to be a right-isosceles triangle at the coarsest level of subdivision,`= 0 . At the next-finest level,`= 1 , the children of the root are defined by splitting the root along an edge formed from its apex vertex va to the midpoint vc of its base edge (v0;</p><formula xml:id="formula_0">v 1 ) . The left child of T is T0 = ( v c ; v a ; v 0 ) , while the right child of T is T1 = ( v c ; v 1 ; v a ) .</formula><p>The rest of the triangle bintree is defined by recursively repeating this splitting process.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Dynamic Continuous Triangulations</head><p>Meshes in world space are formed by assigning world-space positions w(v) to each bintree vertex. A set of bintree triangles forms a continuous mesh when any two triangles either overlap nowhere, at a common vertex, or at a common edge. We refer to such continuous meshes as bintree triangulations or simply triangulations. <ref type="figure">Figure 4</ref> shows a typical neighborhood about a triangle T within a triangulation. We define TB to be the base neighbor sharing base edge (v0; v 1 ) , T L to be the left neighbor sharing left edge (va; v 0 ) , and TR to be the right neighbor sharing right edge (v1; v a ) .</p><p>A key fact about bintree triangulations is that neighbors are either from the same bintree level`as T , or from the next finer level`+ 1 for left and right neighbors, or from the next coarser level` 1 for base neighbors. All of these possible relationships are depicted amongst the triangles in <ref type="figure">Figure 4</ref>. When T and TB are both from the same level`, we refer to the pair (T ; T B ) as a diamond. A simple split operation and its inverse, merge, are depicted in <ref type="figure">Figure 4</ref> for a triangulation containing a diamond. Split replaces triangle T with its children (T0; T 1 ) , and triangle TB by its children (TB0; T B 1 ) . This split operation introduces one new vertex vc at the diamond center, resulting in a new, continuous triangulation. If triangle T does not have a base neighbor TB , only T is split into its children. Merging can be applied to diamond (T ; T B )when the children of T and TB (if TB exists) are all in the triangulation. In this case, we say (T ; T B )is a mergeable diamond for the triangulation. An important fact about the split and merge operations is that any triangulation may be obtained from any other triangulation by a sequence of splits and merges.</p><p>Splits and merges can be animated using vertex morphing to provide a simple form of temporal continuity. For a time interval A triangle T in a triangulation cannot be split immediately when its base neighbor TB is from a coarser level. To force T to be split, TB must be forced to split first, which may require further splits in a recursive sequence. A case requiring a total of four splits is depicted in <ref type="figure" target="#fig_5">Figure 5</ref>. Such forced splits are needed for the optimization algorithm in Section 5. Base meshes of more than one triangle can be used to represent manifold surfaces of arbitrary genus with boundary. If the base mesh can be tiled with diamonds, then the split and merge operations may be used freely as in the case with a single root triangle. For terrain, a typical base mesh is a single diamond.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">DUAL-QUEUE OPTIMIZATION</head><p>The split and merge operations provide a flexible framework for making fine-grained updates to a triangulation. No special efforts are needed to avoid cracks or T-vertices. This section presents a greedy algorithm that will drive the split and merge process. The idea is simple: keep priorities for every triangle in the triangulation, starting with the base triangulation, and repeatedly do a forced split of the highest-priority triangle. As shown next, this process creates a sequence of triangulations that minimize the maximum priority (which is typically an error bound) at every step. The only requirement to ensure this optimality is that priorities should be monotonic, meaning a child's priority is not larger than its parent's. Adding a second priority queue-for mergeable diamonds-allows the greedy algorithm to start from a previous optimal triangulation when the priorities have changed, and thus take advantage of frameto-frame coherence.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Split Queue</head><p>Suppose that every bintree triangle T is given a monotonic priority p(T ) 2 [0; 1]. As triangulation T is built top-down, we shall maintain a priority queue Qs containing all of the current triangles in T.</p><p>The top-down greedy algorithm is the following:</p><p>Let T = the base triangulation. For all T 2 T, insert T into Qs. While T is too small or inaccurate f</p><p>Identify highest-priority T in Qs.</p><p>Force-split T .</p><p>Update split queue as follows: f</p><p>Remove T and other split triangles from Qs.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Add any new triangles in T to Qs. g g</head><p>This greedy algorithm produces optimal triangulations at every step. Consider any other triangulation T 0 that has a lower maximum priority than T. Clearly T 0 must contain only descendents of all the triangles that were forced to be split while building T. Because the force-split operation makes the minimum necessary refinements to preserve continuity, T 0 can not contain any ancestors to the triangles in T. Finally, because T 0 has a lower priority, it must contain only descendents of at least one triangle in T. Therefore, T 0 has a higher triangle count than T and so T is optimal.</p><p>The total number of splits and merges performed by the top-down algorithm is proportionate to N , the number of triangles in the final triangulation T.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Merge Queue</head><p>Now suppose that we are given time-varying priorities p f (T ) 2 [0; 1] for frames f 2 (0; 1; : : : ) , and the problem is to build optimal triangulations (T0; T1; : : : ) . If these priorities are changing slowly and smoothly, then the optimal triangulations for any two consecutive frames will tend to be similar to one another. In this case, performance will be enhanced if we use triangulation T f 1 as a starting point to build triangulation T f . This is done by maintaining a second priority queue, Qm, that contains all the mergeable diamonds for the current triangulation. The priority for a mergeable diamond (T ; T B )is set to the maximum of its two triangles' priorities, maxfp f (T ); p f ( T B ) g . The incremental greedy algorithm is the following:</p><formula xml:id="formula_1">If f = 0 f</formula><p>Let T = the base triangulation.</p><p>Clear Qs, Qm.</p><p>Compute priorities for T's triangles and diamonds, then insert into Qs and Qm, respectively.</p><p>g otherwise f Continue processing T = T f 1 .</p><p>Update priorities for all elements of Qs, Qm. g While T is not the target size/accuracy, or the maximum split priority is greater than the minimum merge priority f If T is too large or accurate f Identify lowest-priority (T ; T B )in Qm.</p><p>Merge (T ; T B ) .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Update queues as follows: f</head><p>Remove all merged children from Qs. Add merge parents T , TB to Qs.</p><p>Remove (T ; T B )from Qm. Add all newly-mergeable diamonds to Qm. g g otherwise f</p><p>Identify highest-priority T in Qs.</p><p>Force-split T .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Update queues as follows: f</head><p>Remove T and other split triangles from Qs.</p><p>Add any new triangles in T to Qs.</p><p>Remove from Qm any diamonds whose children were split.</p><p>Add all newly-mergeable diamonds to Qm. g g g Set T f = T. The incremental greedy algorithm produces an optimal mesh T f that has the same priority as if the top-down algorithm had been performed on the base mesh. The incremental algorithm does not generally produce optimal meshes during the intermediate steps (for example, T f 1 is usually not optimal for frame f ), but it does reach optimality using the smallest possible number of split/merge operations applied to T f 1 . The total number of splits and merges performed is proportionate to N, defined as the number of triangles from T f and T f 1 that are not in common. In the worst case, N can be N f 1 + N f . Situations like this are easily detected: there will be a large number of triangles and diamonds whose priorities are between the minimum merge priority and the maximum split priority. The remedy in this case is to fall back on the top-down algorithm, which can be accomplished by initializing T, Qs and Qm as though f = 0 .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">ERROR METRICS</head><p>This section describes the various error metrics and bounds that are used to compute queue priorities. In the remainder of this paper we restrict our attention to height maps. Specifically, we assume that the vertex-to-world-space mapping w(v) is of the form</p><formula xml:id="formula_2">w(v) = ( v x ; v y ; z ( v )),</formula><p>where (vx; v y ) are the domain coordinates of the vertex v, and z(v) is the height at v. We denote the affine height map for a bintree triangle T to be zT (x; y). We also assume that camera coordinate systems and perspective transforms are given for each frame. We will continue to use the triangleneighborhood notation from Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Nested World-Space Bounds</head><p>For height-map triangulations, a convenient bound per triangle T is a wedgie, defined as the volume of world space containing points (x; y; z) such that (x; y) 2 T and jz zT (x; y)j e T for some wedgie thickness eT 0. We refer to the line segment from (x; y; z eT ) to (x; y; z + eT ) as the thickness segment for v. Nested wedgie bounds are built bottom-up, starting with eT = 0 for all T at finest level`max. The wedgie thickness eT for a parent triangle is defined in terms of its children's wedgie thicknesses, eT 0 and eT 1 . The tightest nested wedgie bounds are given by the formula</p><formula xml:id="formula_3">eT = maxfeT 0 ; e T 1 g + j z ( v c ) z T ( v c ) j (1)</formula><p>where zT (vc) = ( z ( v 0 ) + z ( v 1 ))=2. Note that this computation is fast and localized, which facilitates dynamic terrain. A univariate example of nested wedgies is illustrated in <ref type="figure" target="#fig_6">Figure 6</ref>, along with the chain of wedgies that depend on a particular vertex v.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Geometric Screen Distortion</head><p>With textured triangulations it is natural to separate geometric screen-space distortions from color distortions. We assume in this paper that colors for a surface point are accurately represented by the texture. The remaining image errors can be represented as purely geometric distortions: the distance between where each surface point should be in screen space and where the triangulation places the point. Over the whole image we measure the maximum of these pointwise distortions. This is the base metric for ROAM.</p><p>Formally, let s(v) be the correct screen-space position for a domain point v, and sT (v) be the approximate position from triangulation T . We define the pointwise geometric distortion at v to be</p><formula xml:id="formula_4">dist(v) = k s ( v ) s T ( v ) k 2 .</formula><p>For the whole image, we define the maximum distortion to be distmax = maxv2V dist(</p><formula xml:id="formula_5">v) where V</formula><p>is the set of domain points v whose world-space positions w(v) are within the view frustum.</p><p>In practice an upper bound is computed for the maximum distortion. For each triangle T in the triangulation, a local upper bound on distortion is obtained by projecting T 's wedgie into screen space, as shown in <ref type="figure">Figure 7</ref>. The bound is defined as the maximum length of the projected thickness segments over all v 2 T . These local bounds are monotonic, and will be used to form queue priorities. The maximum split-queue priority provides an upper bound on maximum distortion. If a wedgie extends behind the near clipping plane, the triangle's priority is set to an artificial maximum value and the distortion-bound computation is skipped. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Line-of-site Correction</head><p>So far, the queue priority was derived solely from the screendistortion bound for a triangle T . This priority can be modified to ensure that selected lines of site are correctly occluded or not. A simple method to do this is to change the priorities for any triangles whose wedgies intersect the LOS. By setting these priorities to an artificial maximum value, splits will be made preferentially in a manner sufficient to ensure correct visibility along the LOS. This method tends to promote more triangle splits than necessary, although this excess is typically small in practice compared to the overall triangle count. An example of LOS correction is given in Section 8.1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.4">Other Metrics</head><p>We briefly mention other possible metric/priority variations that are compatible with ROAM:</p><p>Backface detail reduction: Using nested Gauss-map normal bounds (as in <ref type="bibr" target="#b18">[18,</ref><ref type="bibr" target="#b10">10]</ref>), priorities can be set to minimum for triangles whose subtree of triangles are all back-facing. Normal distortions: For specular highlights determined by normal vectors interpolated from the vertices, priority should be given to triangles having large normal distortions where the highlights occur. Texture-coordinate distortion: For curved mappings from surface domain to texture coordinates, priority should be added proportionate to the size of the screen-space position distortions associated with the texture-coordinate approximation. Silhouette edges: Specific emphasis can be placed on triangles whose normal bounds indicate potential back-face to frontface transitions. View frustum: Wedgies outside the six clipping planes can be given minimum priority, as discussed in Section 7.1. Atmospheric obscurance: Wedgie priorities can be decreased when fog reduces visibility. Object positioning: To correctly position objects on terrain, the priorities of triangles under each object can be artificially increased.</p><p>Clearly this list can be extended to suit a variety of applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">PERFORMANCE ENHANCEMENTS</head><p>In this section we describe enhancements that enable the ROAM algorithm to operate at high frame rates for triangulations consisting of thousands of triangles. The first three optimizations decrease the respective computation times for their subtasks by more than a factor of ten. The fourth ensures strict frame rates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">View-Frustum Culling</head><p>We assume the view frustum is defined as the intersection of six halfspaces. Each triangle in the bintree (down to the current triangulation) is given an IN flag for each of the six halfspaces, and an overall label of OUT, ALL-IN or DONT-KNOW, defined as follows: IN is set when the wedgie is entirely inside the halfspace, OUT is given when the wedgie is entirely outside at least one halfspace, ALL-IN is given if all IN flags are set, and DONT-KNOW is given if not OUT or ALL-IN. Updating these flags and labels from frame-to-frame is efficiently handled by a recursive bintree traversal. If a triangle T was labeled OUT or ALL-IN for the previous frame, and these labels are correct for the current frame, then the subtree for T does not need to be updated and recursion terminates. Otherwise, T inherits its IN flags from its parent and rechecks its wedgie against the halfspaces not marked IN, setting new IN flags if appropriate. If the wedgie is entirely outside any of these halfspaces, T and all its children are marked OUT. If all IN flags are set, T and all its children are marked ALL-IN. Otherwise T is marked DONT-KNOW and recursion continues to its children.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Incremental T-Stripping</head><p>Significant performance gains result from organizing triangles into strips, although optimum stripping is a difficult problem <ref type="bibr" target="#b5">[5]</ref>. We consider only non-generalized strips (no "vertex swapping"). We use a simple, sub-optimal, incremental approach that yields average strip lengths of around four to five triangles. As triangles are split, merged or change view-culling status, minimal re-linking of strips is performed. Deleting a triangle from a strip causes the strip to be deleted (for a singleton strip), shortened on the end, or split in two. New triangles are first inserted as singleton strips, which we subsequently attempt to glue to each of the neighboring strip ends.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Deferring Priority Recomputation</head><p>The screen-distortion priorities of the triangles change as the viewing position changes, typically in a slow and smooth manner. Recalculating priorities of all triangles for every frame is too costly. Instead, priorities are recomputed only when they potentially affect a split/merge decision.</p><p>Given a velocity bound on the viewpoint, bounds can be obtained for screen-distortion priorities over time (i.e. a time-dependent bound). Also, the crossover priority (defined as the maximum splitqueue priority when the incremental split/merge process is complete) changes slowly from frame to frame (typically around 1% change). Recomputation of a triangle can safely be deferred until its priority bound overlaps the crossover priority. A deferral list is kept for each of the next few dozen frames. Only the triangles on the current frame's deferral list must have priorities recomputed. If time allows, additional triangles may be recomputed in subsequent deferral lists. After recomputation, the triangle is placed on the deferral list farthest ahead that will provide safe recomputation scheduling.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.4">Progressive Optimization</head><p>To ensure strict frame rates, triangulation optimization should stop when the alloted frame time is about to expire. The ROAM algorithm readily supports this because optimization processing and stripping updates occur one split/merge at a time. Of course, early termination yields non-optimal triangulations. However, because the split/merge steps are performed in decreasing order of importance, the partial work done is optimal in the sense that we have gotten as close to true optimal as time permits while maintaining the specified triangle count. We refer to this stepwise processing as progressive optimization. Priority recomputations can also be limited based on time available. The only phase of ROAM not amenable to progressive completion is view-frustum culling, which fortunately requires only a small fraction of the frame time and is completed before priority recomputation and mesh optimization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">RESULTS</head><p>Performance figures were measured on an Indigo2 Silicon Graphics workstation with Maximum Impact graphics hardware and a single R10000 processor. These figures were obtained simulating a fighter aircraft in terrain avoidance mode flying at high speed over very hilly terrain <ref type="bibr" target="#b0">1</ref> . With all incremental features of the algorithm turned on and 3000 triangles rendered the total time per frame is approximately 30 milliseconds. Of this, 5 milliseconds is spent doing the view-frustum culling, 5 milliseconds calculating the queue priorities, 5 milliseconds splitting/merging the triangles in the mesh and 15 milliseconds outputting the triangle strips.</p><p>Turning off the priority recomputation deferral increases the time calculating the queue priorities to about 43 milliseconds resulting in a total frame time of 68 milliseconds. Turning off incremental stripping further increases the frame time to 140 milliseconds. Finally, turning off incremental split/merge optimization increases the time to 210 milliseconds.</p><p>On a single R10000 processor Silicon Graphics Onyx with an Infinite Reality graphics board, performance improves so that 6000 triangles can be rendered at 30 frames per second. The subjective quality of the terrain geometry is very good. In a high-speed terrainfollowing scenario over rough terrain with 3000 terrain triangles in the mesh, silhouettes appear realistically complex and stable and there are virtually no popping artifacts. In a similar flight over less rough but still mountainous terrain 1500 triangles suffice to eliminate perceptible popping. Since the system is capable of producing meshes with 6000 triangles or more at 30 frames per second, ROAM appears to completely eliminate perceptible popping artifacts for even the most stringent flight regimes.</p><p>To understand this qualitative assessment better, we measured "pop" sizes and average number of splits and merges for the same high-speed, low-altitude loop over very rough terrain. A histogram of pop sizes in pixels (for a 1000 1000 image with 3000 triangles per frame), is shown in <ref type="figure" target="#fig_9">Figure 8</ref>. On average, only 43.2 splits and merges are performed per frame. In other words, less than 3% of the triangles change, and these few, scattered pops almost all measure under 1.5mm on a typical 21 inch workstation monitor.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.1">Line-of-site Example</head><p>An example of LOS visibility correction is shown in <ref type="figure">Figure 9</ref>. In this example, 8 triangles were "stolen" from the surrounding terrain to provide the correct occlusion along the line of site to the centermost box. <ref type="figure">Figure 9</ref>: Left side is before LOS correction, right is after.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">CONCLUSION</head><p>We have presented ROAM, an algorithm for optimizing triangulations given view-dependent error metrics. The method has been implemented and provides high-quality triangulations with thousands of triangles at high frame rates. A novel dual-queue incremental optimization process was combined with fast, localized preprocessing and several runtime performance enhancements, including incremental view-frustum culling, incremental stripping, prioritycomputation deferral and progressive optimization.</p><p>Critical future issues include management of geometry-and texture-loading from disk, and optimization of texture-block LOD.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Example of ROAM terrain.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Triangulation for example frame, with eye looking right. Dark region is outside view frustum, light region is inside, and grey overlaps boundary.ROAM consists of a preprocessing component and several runtime components. The preprocessing component produces nested, view-independent error bounds bottom-up for a triangle bintree. At runtime, four phases of computation are performed per frame:</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>Levels 0-5 of a triangle bintree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>t 2 [Figure 4 :</head><label>24</label><figDesc>0; 1], consider the split of diamond (T ; T B ) shown inFigure 4.Instead of moving vc immediately to its new position wc = w(vc), let it move linearly over time from the unsplit base-edge midpoint wm = ( w ( v 0 ) + w ( v 1 ))=2 as wa(t) = ( 1 t ) w m + twc. Merges can be animated in a similar way. Split and merge operations on a bintree triangulation. A typical neighborhood is shown for triangle T on the left.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Forced splitting of triangle T .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>vFigure 6 :</head><label>6</label><figDesc>Nested wedgies for 1-D domain with dependents of v.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 : 2 ( 2 c 2</head><label>7222</label><figDesc>Distortion bound by projecting wedgie to screen space.Because of the peculiarities of the perspective transform, the maximum projected wedgie thickness does not always occur at one of the triangle vertices. This leads to the following upper-bound computation. Let (p; q; r) be the camera-space coordinates of a point w(v) without perspective, and without loss of generality assume the perspective projection is of the form s = ( p=r; q = r ) . The screen-space distortion at v 2 T is bounded by projecting the thickness segment at v.Let (a; b; c)be the camera-space vector corre-sponding to world-space thickness vector (0; 0; e T ) . The screenspace distortion at v is bounded by ar cp) 2 + ( br cq) 2 1=2(3)It is straightforward to show that the minimum of r and the maximum of (ar cp) 2 + ( br cq) 2 occur at the corner vertices of T (although not generally the same corner). An upper bound on d dist(v) can thus be obtained by substituting these minimum and maximum values into Equation 3.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 8 :</head><label>8</label><figDesc>Histogram showing relative number of pops versus pop size (in pixels) totaled over the full test flight.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">Specifically, we use the USGS 1-degree DEM data (90 meter post spacing) for Northern New Mexico. We test on a circular flight 300 meters above the Jemez mountains, with trajectory smoothing, and camera facing in the direction of flight.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was performed on U.S. Department of Energy Contract W7405-ENG-36, funded jointly by the U.S. Navy and Air Force. We thank James Reus for his assistance in the early stages of this work. We also thank our sponsors, who have provided substantial input and feedback during these investigations: in particular, we </p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Hierarchical geometric models for visible surface algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">H</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="547" to="554" />
			<date type="published" when="1976-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amitabh</forename><surname>Varshney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dinesh</forename><surname>Manocha</surname></persName>
		</author>
		<imprint>
			<pubPlace>Greg Turk, Hans Weber, Pankaj Agarwal, Frederick Brooks, and</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Simplification envelopes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Wright</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;96 Proc</title>
		<imprint>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="119" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Temporal continuity of levels of detail in delaunay triangulated terrain</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">-Or</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yishay</forename><surname>Levanoni</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Visualization &apos;96</title>
		<meeting>Visualization &apos;96</meeting>
		<imprint>
			<publisher>IEEE Comput. Soc. Press</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="37" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Multiresolution analysis of arbitrary meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matthias</forename><surname>Eck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tony</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Duchamp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugues</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Lounsbery</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Werner</forename><surname>Stuetzle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;95 Proc</title>
		<imprint>
			<date type="published" when="1995-08" />
			<biblScope unit="page" from="173" to="182" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Optimizing tirangle strips for fast rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Francine</forename><surname>Evans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><surname>Skiena</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amitabh</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Visualization &apos;96</title>
		<meeting>Visualization &apos;96</meeting>
		<imprint>
			<publisher>IEEE Comput. Soc. Press</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="319" to="326" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Automatic extraction of irregular network digital terrain models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Robert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">J</forename><surname>Fowler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Little</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;79 Proc.)</title>
		<imprint>
			<date type="published" when="1979-08" />
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="199" to="207" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlo</forename><forename type="middle">H</forename><surname>Funkhouser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>SÃ©quin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIG-GRAPH &apos;93 Proc.)</title>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="247" to="254" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Multiresolution modeling for fast rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><forename type="middle">S</forename><surname>Heckbert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Garland</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Graphics Interface &apos;94</title>
		<meeting>Graphics Interface &apos;94<address><addrLine>Banff, Canada</addrLine></address></meeting>
		<imprint>
			<publisher>Canadian Inf. Proc. Soc</publisher>
			<date type="published" when="1994-05" />
			<biblScope unit="page" from="43" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugues</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;96 Proc</title>
		<imprint>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">View-dependent refinement of progressive meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hugues</forename><surname>Hoppe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;97 Proc</title>
		<imprint>
			<date type="published" when="1997-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Real-time, continuous level of detail rendering of height fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Lindstrom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Koller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Ribarsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Larry</forename><forename type="middle">F</forename><surname>Hodges</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nick</forename><surname>Faust</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><forename type="middle">A</forename><surname>Turner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIG-GRAPH &apos;96 Proc</title>
		<imprint>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="109" to="118" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Multiscale Compression of Digital Terrain Data to meet Real Time Rendering Rate Constraints</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Miller</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<pubPlace>Davis</pubPlace>
		</imprint>
		<respStmt>
			<orgName>University of California</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Applications of Spatial Data Structures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Hanan</forename><surname>Samet</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<publisher>Addison-Wesley</publisher>
			<pubPlace>Reading, MA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Decimation of triangle meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><forename type="middle">A</forename><surname>Zarge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;92 Proc.)</title>
		<imprint>
			<date type="published" when="1992-07" />
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="65" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Automatic generation of triangular irregular networks using greedy cuts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>ClÃ¡udio</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><forename type="middle">S B</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arie</forename><forename type="middle">E</forename><surname>Mitchell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Visualization &apos;95</title>
		<meeting>Visualization &apos;95</meeting>
		<imprint>
			<publisher>IEEE Comput. Soc. Press</publisher>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Fast multiresolution surface meshing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Oliver</forename><surname>Staadt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Markus</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Gatti</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Visualization &apos;95</title>
		<meeting>Visualization &apos;95</meeting>
		<imprint>
			<publisher>IEEE Comput. Soc. Press</publisher>
			<date type="published" when="1995-07" />
			<biblScope unit="page" from="135" to="142" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A method for continuous adaptive terrain</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lee</forename><forename type="middle">R</forename><surname>Willis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">T</forename><surname>Jones</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jenny</forename><surname>Zhao</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IMAGE VII Conference</title>
		<meeting>IMAGE VII Conference</meeting>
		<imprint>
			<date type="published" when="1996-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Adaptive real-time levelof-detail-based rendering for polygonal models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>El-Sana</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Dynamic view-dependent simplification for polygonal models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julie</forename><forename type="middle">C</forename><surname>Xia</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Amitabh</forename><surname>Varshney</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Visualization &apos;96</title>
		<meeting>Visualization &apos;96</meeting>
		<imprint>
			<publisher>IEEE Comput. Soc. Press</publisher>
			<date type="published" when="1996" />
			<biblScope unit="page" from="327" to="334" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
