<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Repairing CAD Models</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gill</forename><surname>Barequet</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Johns Hopkins University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Subodh</forename><surname>Kumar</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Johns Hopkins University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Repairing CAD Models</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:35+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>We describe an algorithm for repairing polyhedral CAD models that have errors in their B-REP. Errors like cracks, degeneracies, duplication, holes and overlaps are usually introduced in solid models due to imprecise arithmetic, model transformations, designer&apos;s fault, programming bugs, etc. Such errors often hamper further processing like finite element analysis, radiosity computation and rapid prototyping. Our fault-repair algorithm converts an unordered collection of polygons to a shared-vertex representation to help eliminate errors. This is done by choosing, for each polygon edge, the most appropriate edge to unify it with. The two edges are then geometrically merged into one, by moving vertices. At the end of this process, each polygon edge is either coincident with another or is a boundary edge for a polygonal hole or a dangling wall and may be appropriately repaired. Finally, in order to allow user-inspection of the automatic corrections, we produce a visualization of the repair and let the user mark the corrections that conflict with the original design intent. A second iteration of the correction algorithm then produces a repair that is commensurate with the intent. Thus, by involving the users in a feedback loop, we are able to refine the correction to their satisfaction.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>CAD (Computer-Aided Design) models are often represented as unordered lists of polygons -sometimes referred to as "soups of polygons." File formats like IGES <ref type="bibr" target="#b13">[NCG91]</ref>, DXF <ref type="bibr" target="#b1">[Aut95]</ref> and STL <ref type="bibr" target="#b0">[3DS89]</ref> (which is a de facto standard in the rapid-prototyping industry) allow users to represent models as such soups of polygons. Each polygon is listed independently as an ordered list of its vertex-coordinates, occasionally along with its normal vector. The collection of polygons is assumed to represent a complete model. Unfortunately this is often not the case. Typical problems include cracks (in the surface), degeneracies, duplication (of patches of the surface), holes and overlaps, as shown in <ref type="figure" target="#fig_0">Figure 1</ref>. Cracks occur due to inaccuracies in the data or in the process that creates the data. For example, a vertex shared by multiple polygons may be computed according to two surface equations, resulting in slightly different positions in space, causing a crack or an overlap. Such faults are especially common in models obtained by tessellating curved surfaces and are a result of different tessellations of the same boundary curve. These cracks often complicate further processing of data, specially if it requires inside-outside classification of points with respect to the model. For example, if a solid, P, is not closed, it is difficult to determine if a it interferes with another solid Q. The fabrication process in most rapid prototyping techniques often fails due to erroneous solid descriptions. Illumination algorithms compute  [BMSW91] catalogs some common types of errors and proposes techniques to avoid them. Missing polygons are also a common source of holes in the model. Another possible error is the existence of dangling walls inside a solid or repetition of portions of the geometry; these are usually mistakes of the model designer and result from repeated operations. We present algorithms to eliminate dangling geometry, T-joints, holes and cracks in a polygonal solid model, and generate consistent polygon-orientations. We assume that the target model is a set of closed 2-manifolds [O'N66], but allow users to override this assumption.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Related Work</head><p>Several techniques for correcting some of the errors described above have been proposed in the past. <ref type="bibr">Morvan and Fadel [MF96a,</ref><ref type="bibr" target="#b11">MF96b]</ref> describe a virtual environment that provides tools for model correction, controlled primarily by the user. Unfortunately, this can be a cumbersome and inefficient procedure for large models. Furthermore, it is easy to miss errors. Our approach makes the correction process automatic, at the same time including the user in the correction loop. The user can visualize the errors and guide the correction algorithm. Turk and Levoy <ref type="bibr" target="#b15">[TL94]</ref>, in order to generate polygonal models from range data, remove overlaps of polygons by clipping them. For our application, vertex-shifting seems to cause comparatively smaller perturbation to the input model. Rock and Wozny <ref type="bibr" target="#b14">[RW92]</ref> present efficient data structures for computing exact matches between polygon edges for reconstructing the topology of the model. Bøhn and Wozny <ref type="bibr" target="#b7">[BW92,</ref><ref type="bibr" target="#b8">BW93]</ref> present a technique based on Jordan curve construction for identifying holes bounded by edges at each of which only one facet occurs. They use local techniques for filling a hole by triangles. Mäkelä and Dolenc <ref type="bibr" target="#b10">[MD93]</ref> also use local techniques for filling cracks in the model surface. <ref type="bibr">Barequet and Sharir [BS95]</ref> describe a globallyconsistent approach for identifying and filling holes. Unfortunately, when a large number of cracks is involved, simple-minded hole filling may result in an explosion of the number of polygons needed to describe the model. The approach of Murali and Funkhouser <ref type="bibr" target="#b12">[MF97]</ref> is to determine regions of space that lie inside a solid using spatial partitioning and use the partition as the description of solids. Unfortunately, for degenerate cases, their output may be significantly different from the input even for small errors in the input.</p><p>In our work we propose a heuristic which assumes that most of the cracks and overlaps occur due to numerical error in the computation of vertex coordinates, and hence shifts the positions of vertices by a small amount to eliminate the error. Our method ensures that no vertex is moved farther than a user-specified error-tolerance. Larger holes are filled using the triangulation technique of <ref type="bibr" target="#b5">[BS95]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Our Approach</head><p>We present a topologically-based geometric algorithm designed to rid polygonal boundary representations (B-REP) of solid models of some common errors. We define the problem as follows:</p><p>Given input: A list of polygons, where each polygon is specified by an ordered sequence of vertices, and each vertex is specified by three real numbers that represent its x, y, and z coordinates.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Generate the following output:</head><p>A list of unique vertices, each specified by its three coordinates.</p><p>A list of unique directed edges, each specified by two vertex indices.</p><p>A list of unique polygons, each specified by an ordered sequence of edge indices. Each polygon is oriented counterclockwise when it is viewed from outside the model.</p><p>We have implemented a system called RSVP (Repair by Shifting Vertices of Polygons). RSVP takes as input a soup of polygons and outputs the adjacency structure of the corrected model. Each edge of the resulting solid appears exactly twice, in opposite orientations, on two adjacent polygons. A brief overview of RSVP follows:</p><p>The repair algorithm generates manifolds with consistent normal vectors. It closes small cracks and fills larger gaps with polygons. Small overlaps are detected and separated. Holes, open geometry, zero-volume solids and T-joints are also handled.</p><p>We first compute the connected components of the surface, which are typically open manifolds. An edge does not lie on the boundary of a component if it appears in exactly two polygons. All other edges are boundary edges. Duplicate polygons are also found at this stage. The next step is matching each boundary edge with another that may not necessarily coincide with it. We use an adjacency score for ranking all the edge-to-edge candidates for matching, We maintain a queue of candidates sorted by this score and process candidates in that order.</p><p>We merge two boundary edges with the minimum score by moving their end points. We continue such merges until no more merges may be made without moving a vertex by more than ", where " is a user specified parameter. If the angle between two polygons in a component (either before or after merges) is 0 , the component is flagged as zero-volume.</p><p>The holes and open components that remain after the merging process are identified by a second step of computing Jordan curves on the (modified) surface. The holes can be optionally triangulated, and the dangling or zero-volume parts can be discarded.</p><p>We produce a visualization of the model repair. Often the vertex shift is too small and thus a naive model display is useless with respect to inspecting the erros. We describe a highlighting technique in conjunction with zoom windows for aiding the user inspect the faults on the surface and supervise the repair process.</p><p>Once the user overrides a decision made by the system, further iterations are performed to obtain a better result.</p><p>The rest of the paper is organized as follows. Section 2 discusses the algorithm to generate connected components of the given model. Sections 3 and 4 describe our candidate ranking and processing algorithms. Section 5 presents the final triangulation step. Section 6 presents our repair visualization technique and section 7 describes our implementation and some experimental results. We end with some concluding remarks and possible future work in section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Computing the Connected Components</head><p>To reduce the number of candidate matchings, we first compute components of the model that are correctly specified in the input model, i.e., we merge two polygon edges, e1 = v1v2 and e2 = w1w2, if e1 = e2, i.e., v1 = w1 and v2 = w2, and no other edge e3 = e1.</p><p>The assumption here is that no accidental error can cause exactly two edges to match each other. If this assumption is invalid for an application, each polygon may be considered a single component and passed on to the merging phase.</p><p>We compute the connected components of the model using a process similar to that of <ref type="bibr" target="#b5">[BS95]</ref>. We first construct G, the adjacency graph of the model. Each facet of the model is a vertex in G. G includes the graph-edge F1-F2, if faces F1 and F2 contain edges e1 and e2, respectively, such that e1 = e2. We use a depth-first traversal of G to construct the connected components of the model.</p><p>During the traversal process we also orient all the facets of each component consistently. Each internal edge of the component appears exactly twice, in opposite orientations, in a pair of neighboring facets. The algorithm is also able to detect non-orientable surfaces while processing a "back-edge" in the depth-first order traversal. Back-edges are used to perform a consistency check between two facets whose respective orientations are already fixed. If the two orientation do not match, the component is non-orientable and the system reports the error as such.</p><p>Once we partition a model into connected components, we must find the boundary edges of each component, which may be later merged with the boundary edges of other components. In addition, we need to determine the preceding and following boundary-edges for each edge in a component (which are used later for computing scores). To obtain the boundary contours of a component, we compute the binary sum <ref type="bibr" target="#b5">[BS95]</ref> of all the facets (as cycles of graphedges). The result is the collection of the boundary polygonal contours (see <ref type="figure">Figure 2</ref>). Note that in case of T-joint ( <ref type="figure" target="#fig_3">Figure 3</ref>), there are two possible preceding or following edges; we maintain pointers to both. In the merging phase, we select the one with lower score. In our current implementation, such T-joints can result in zero area polygons. It is relatively simple to add a post-processing phase to eliminate zero-polygons, and even duplicate polygon vertices. Note that, in general, a simple deletion of a zero-polygon is not sufficient. Multiple polygons may be adjacent to it. This is highlighted in <ref type="figure" target="#fig_3">Figure 3</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Ranking the Matching Candidates</head><p>Once connected components of a model are constructed and their boundary contours computed, we generate a list of candidate boundary-edge pairs. The two (oriented) edges of a candidate pair  belong to different components. We assign scores to candidates as follows: Let e1 = ,,! v1v2 and e2 = ,,,! w1w2 be two boundary edges (see <ref type="figure" target="#fig_5">Figure 4</ref>). We first assume that the boundary contours are oriented correctly, i.e., all the connected components appear in their correct orientations. We later (Section 4.2) describe how to remove this assumption to deal with more complex cases when we cannot rely on the original orientations of the facets.</p><p>Our goal is to evaluate the "desirability" of merging two directed edges e1 and e2. For this purpose we estimate, the magnitude of the geometric error: this could be the area of the missing part of the two corresponding polygons in case of cracks or that of the extra parts in case of overlaps. The case of cracks is demonstrated in <ref type="figure" target="#fig_5">Figure 4</ref>; an estimate for the missing geometry is shown lightly shaded. For a boundary-edge pair e1; e 2 , we compute e1; e 2 , an estimate for the relative error; we normalize the area error by the lengths of e1 and e2 to prevent larger errors for longer edges. In order to compute e1; e 2 , we first compute the area of the region spanned by e1 and e2. This is done by linearly parametrizing (by t) e1 and e2, respectively, and computing:</p><p>Ae1; e 2 = Z 1 0 j , , ,</p><p>t e 2 t j</p><formula xml:id="formula_1">2 d t = 1 3 j , , ! v 2 w 2 , , , ! v 1 w 1 j 2 + , , ! v 2 w 2 , , ! v 1 w 1<label>(1)</label></formula><p>To compute , instead of integrating j ,,,,,,! e1te2tj 2 , as done in (1),  <ref type="table">00000  00000 00000  00000  00000 00000  00000  00000 00000  00000 00000  00000  00000 00000  00000  00000 00000  00000 00000  00000   11111  11111 11111  11111  11111 11111  11111  11111 11111  11111 11111  11111  11111 11111  11111  11111 11111  11111</ref>  we must integrate j ,,,,,! e1tltj 2 + ,,,,,! lte2tj 2 , where l is the line of intersection of the error-polygons <ref type="figure" target="#fig_5">(Figure 4</ref>). Note that j ,,,,,,! e1te2tj 2 = j ,,,,,! e1tltj 2 + j ,,,,,! lte2tj 2 + 2 j , , , , , ! e 1 t l t jj ,,,,,! lte2tj cos;</p><p>where is the angle between the error polygons. If we make the approximation that the error is symmetric, i.e., j ,,,,,! e1tltj = j ,,,,,! lte2tj, e1; e 2 = A e 1 ; e 2 j , ! e 1 jj , ! e2j cos 2 = Ae1; e 2 j , ! e 1 jj , ! e2jN1 N2 ;</p><p>where N1 and N2, are the normals to the error polygons, respectively. Intuitively, the angle term induces our score to favor smoother matches over sharp bends.</p><p>To compute the final Score(e1; e 2 ), we also consider the edgepairs immediately preceding and following e1; e 2 : Score(e1; e 2 ) =</p><p>Use1; e 2 + e 1 ; e 2 + 0 : 5e , 1 ; e , 2 + 0 : 5e + 1 ; e + 2 U s is a user-specified score for certain candidates. In order to prohibit merging of two edges e1 and e2, we set Use1; e 2 to +1</p><p>(,1 to cause a merge). Setting of Us is controlled by the visualization algorithm described in section 6. By default Us = 0 for each candidate. While it is possible to use a continuous function (that achieves a maximum at t = 0 : 5 between e1 and e2) to weight the s, empirical evidence shows that an equal distribution of weights between the matching pair and the adjacent pairs works well. We sort all the matching candidates in ascending order of score (a lower score corresponds to a better matching candidate), and maintain for each score the respective edges and their endpoints.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Processing the Matching Candidates</head><p>We process all the matching candidates in ascending order of score. For each boundary edge we maintain one bit which indicates whether the edge was already matched or not. Processing a matching candidate is performed only if both its edges were still unmerged and such a merge does not introduce any self-intersections.</p><p>(Self intersections are ignored if the score is -1.) In order to match a pair of boundary edges e1 = ,,! v1v2 and e2 = ,,,! w1w2, we merge v1 with w2 and v2 with w1. The merging is performed by replacing a pair of vertices by their average, the mid-point on the line-segment which connects between the two points. Since it is possible that, for example, v1 and w2 were already merged, or that v1 (or w2) was already merged with another vertex, this process maintains buckets of merged vertices. Initially, every vertex is set to a singleton bucket. Merging two vertices then actually amounts to merging the two buckets that contain them. Each bucket maintains the original coordinates of all the vertices that it contains, so that when we merge two buckets we are able to recompute the average of all involved vertices.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Vertex Merging</head><p>A formal description of the vertex-merging process follows:  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Orientation Checking</head><p>If the original orientation of facets is not consistent, we need to make the following modifications to our algorithm: Orient all the facets of each connected component consistently with respect to other facets in the component.</p><p>Compute, for each pair of boundary edges, two matching candidates. The additional candidate consists of the same edges but with the assumption that the orientation of one of them should be inverted. The order of the considered four vertices (along one boundary contour) is also inverted for computing the score of this candidate.</p><p>Before the vertex-merging process, initialize each boundary edge with a reference to its connected component.</p><p>During the vertex-merging process, when two edges are matched (either in their regular orientations, or when one is inverted), the orientation consistency between the two respective connected components is checked. If the two edges belong to the same connected component, then the candidate can be processed only if it passes the consistency test. Otherwise, processing this candidate causes the uniting of the two respective connected components, in which case the type of the candidate, and previous possible reorientations of the components, determine whether we have to reorient one of the components (that is, invert the orientations of all its facets) in order to maintain global consistency.</p><p>These considerations are very similar to those of <ref type="bibr" target="#b5">[BS95]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Filling Holes</head><p>If the user sets a small value for ", the maximum allowed vertexshift, there may be holes left in the models at the end of the vertex merging phase. Some of these holes may be due to large position errors, others may be due to missing polygons. A boundary edge could remain unmatched either because it did not appear in any matching candidate, or its potential matching edges were merged with other boundary edges.</p><p>Identifying the remaining holes is done in the same way the original boundary contours were located (see Section 2). These are indeed the boundary polygons of the new object after the vertexmerging step.</p><p>Our system automatically triangulates these holes (unless overridden by the user). A triangulation of a three-dimensional polygonal contour C is a collection of triangles which define a simplyconnected 2-manifold whose boundary is C. <ref type="bibr">Barequet et al. show in [BDE96]</ref> that the decision whether a three-dimensional polygon is triangulable (that is, whether it has a triangulation which does not intersect itself) is N P -complete. For practical reasons, we do not check whether a hole is triangulable or not. As in <ref type="bibr" target="#b5">[BS95]</ref>, we use a simple dynamic-programming technique which computes the triangulation of a hole with n edges in On 3 time. Following <ref type="bibr" target="#b6">[BST96]</ref>, we minimize a measure which is a linear combination of the area of the triangles and the ratio (for each triangle) between the lengths of the longest and the shortest edges. Let At be the area of a triangle t, and let Lt (resp. St) be the lengths of the longest (resp. shortest) edges of t. The weight of a triangle t is of the form !areaAt + ! ratioLt=St, where !area and !ratio are user-defined weights. The rationale of this measure is the aim both to minimize the surface area of the triangulation and to avoid, as much as possible, long skinny triangles. Minimizing the total area of the triangulation is guided by the intuition that the unknown surface only whose boundary (the hole) is known is the one that minimizes the "tension" as in a soap bubble. Avoiding long skinny triangles is done because many external applications (such as finite-element analysis) rely not only on the continuity of the surface but also on its regularity.</p><p>Our experimentation shows that in practice such a triangulation indeed produces "intuitively-correct" filling of holes. Note, however, that for larger holes, it may not be clear if these are legitimate holes, or just an artifact of dangling geometry. If the sum of the area of the filled triangles is smaller than the sum of the area of the rest of the component polygons, we leave the holes marked as holes, otherwise we mark the component as dangling. The choice of the shift-bound, ", is important for some cases. For example, two well separated hemispheres may each end up separately closed by triangulation. The correct solution in this case might be to close the two hemispheres together, i.e., to either extend the two components towards each other, or triangulate the region between the two components. Automatic control of " and inter-component triangulation is left as future work. In our current scheme we let the user set a large enough ", possibly after repair-visualization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">The Visualization Loop</head><p>While automated error correction speeds up the detection and elimination of errors, often there are multiple correct solutions. The original intent of the designer may not be followed by the heuristic for edge matching. For example, see <ref type="figure" target="#fig_9">Figure 5</ref>(a). Without considering the context, we cannot unequivocally choose between <ref type="figure" target="#fig_9">Figures 5(b)</ref> and (c), either of which could be the intended shape.</p><p>We, therefore, involve the designer in the correction loop to override incorrect decisions made by the automated process. A subsequent iteration of RSVP avoids matchings marked incorrect by the user.</p><p>A simple rendering of the faulty or corrected model is not usually effective: it is not easy to recognize the errors. We augment the simple rendering (of the input model) by highlighting the computed holes. Inspection is done in two phases, one for each type of errors -Erroneous geometry: cracks and overlaps and Extraneous geometry: inside walls, holes, zero-volume components, etc.</p><p>Dangling geometry is identified in RSVP by incomplete components, i.e., components that contain edges with a single polygon adjacent to them after the merging process.</p><p>For visualization, the cracks correspond to the merged edges. We display the cracks in red color and the rest of the model in blue to clearly highlight the repaired crackes. In addition, we also assign a different color to each solid. These are helpful in identifying cases like that in <ref type="figure" target="#fig_9">Figure 5</ref>.</p><p>Typical errors are so small that it may not be easy to find them in a simple rendering. To help visualize the errors we employ two techniques:</p><p>Fault line : Each boundary edge is drawn using a single pixel thick line (called fault line). Thus even small errors are represented in the image and can be easily located.</p><p>Zoom window : Sometimes it becomes necessary to see the actual geometry in the neighborhood of a given error. Since the dimensions of errors are usually quite small (with resect to the surrounding features of the model), the user needs to significantly zoom-in to the error. Unfortunately, this results in a loss of context and can be confusing. We allow the user to maintain context, but pop up a second (and recursively more) zoom window which shows the zoomed-in view around the selected point of the model (see <ref type="figure" target="#fig_0">Figure 10</ref>).</p><p>To highlight cracks we use two-sided flat shading of the model. All vertices that belong to the same bucket (see Section 4) are shown in the same color. In addition, any window showing an augmented input model can also be replicated with the second window showing the corrected model. A typical use of this tool is to focus in on a fault line, pop up a zoom window which shows the error in detail, and then replicate the zoom window showing the corresponding part of the corrected model. The user can select a fault line that is marked for separation. On the next iteration of the automatic correction, the score of the selected pair is artificially increased by setting Us to +1 (see Section 3).</p><p>Extraneous geometry editing is normally performed after the user is satisfied with the results of the erroneous geometry editing. At the end of merge phase, extraneous geometry is marked as triangulated hole (shown in red), dangling piece (shown in green) or zero volume (shown in blue). If a component is zero-volume in addition to being dangling, it is shown in cyan. The complete components are either shown in gray wire-frame or not shown at all, based on user's preference. The users can select (using the mouse) any extraneous component they wish to change. The display of such selected components is changed to wire-frame in appropriate color (to facilitate "undo" operation). A selected dangling component may be marked to be retained as-is, or re-classified as one with hole. A triangulated hole may be selected to be removed. Subsequently, the rest of the component, now dangling, may either be retained or discarded. All unselected zero-volume solids and dangling components are saved into an error-file and removed from the model. Any dangling components re-classified as holes are completed by hole-filling.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Implementation and Experimental Results</head><p>We have implemented the algorithm in C on a Silicon Graphics workstation. The visualization component is based on OpenGL.</p><p>We have experimented with the algorithm on several data files (with many hundreds of thousand polygons) obtained from CAD systems. <ref type="figure" target="#fig_0">Figure 1(a)</ref> shows a synthetic cube with a "broken" surface, while <ref type="figure" target="#fig_0">Figure 1(b)</ref> shows the repaired model after vertex merging. <ref type="figure">Figure 6</ref>(a) shows a ball with a tiny holes in its poles. One such hole is displayed in <ref type="figure">Figure 6(b)</ref>. Vertex merging results in the construction shown in <ref type="figure">Figure 6(c)</ref>. Alternatively, if we avoid any vertex shifting by setting small enough maximum allowed shift, the holes are triangulated (by minimizing the total area of the triangles) as shown in <ref type="figure">Figure 6(d)</ref>.  . We avoided merging of vertices whose mutual distance was above 10 units. Consequently, some holes remained after the vertex merging step. These holes were then triangulated so as to obtain a fully repaired model. <ref type="table">Table 1</ref> summarizes the performance of our implementation on all the examples described above.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Conclusion</head><p>A number of applications in computer graphics, e.g, virtual prototyping, global illuminations, surface simplification, etc., rely on complete adjacency graph of the model. By moving vertices by a small distance, we are able to construct such an adjacency graph.</p><p>In practice, we found that minor variations of score weights and " did not affect the results of our repair, since most boundary edges match one edge much more strongly than other potential edges. By automating majority of the repair, while allowing the user to visualize the errors and override any corrections, we believe we have achieved a good balance between quickly correcting the model and maintaining the original intent of the design. However, our system is but a first step towards a robust and an ultimate repair tool that can be used to correct or detect any error in solid models. While our technique generates globally consistent models, it is targeted primarily at removing bulk errors (extraneous geometry) and small positional errors (erroneous geometry). For example, large intersecting polygons may not be detected. A small box lying on top of a large box always results in two separate solids. A more general approach that includes full-scale CSG operations could generate a single manifold surface in such cases. Efficiency was mostly ignored in our prototype implementation; a number of steps were implemented using brute force algorithms. While efficiency is not crucial for off-line model correction, if RSVP were to  <ref type="figure">Figure 6</ref>: A ball with holes in the poles be generalized and included in a modeling package that detects errors at modeling time, better algorithms and data structures must be used. For example, a lazy evaluation of scores may significantly speed-up processing time. Further, ability to make incremental changes to the model after user-intervention, to display part-names and maintain file pointers and to add call-back data-paths to modeling software could make RSVP a viable plug-in. Generalization of our algorithm to parametric surface models is another important ingredient for a complete modeling tool.  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>A synthetic broken cube images with artifacts in the presence of cracks in the surface due to leakage of light.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>(b). Additional vertices must be introduced to eliminate T-joints(Figure 3(c)).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>The boundary edges are shown dashed. (b) A zero-area polygon (dashed) may be created due to t-joints. The distances have been enhanced for clarity in these diagrams. (c) The zero-area polygon may be eliminated by introducing additional vertices on the adjacent polygons. Each unique vertex on the zero-polygon must be included on both sides. The components on each side are now topologically adjacent.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>T-Joints</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>A candidate matching pair of edges and its score computation.Figure (b)shows l, the line of intersection of the two nominal planes containing e1 and e2, respectively. The nominal plane for an edge e1 is constructed using the farthest point from it on its polygon.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>FI</head><label></label><figDesc></figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>Figure 7(a) shows a mechanical T-box which was cracked manually. The boundary contours of this model are displayed inFigure 7(b). The T-box repaired by vertex merging is shown inFigure 7(c).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8</head><label>8</label><figDesc>(a) shows a portion of a model of a submarine storage and handling room with dimensions 45; 43310; 9528; 407 coordinate units. The boundary contours of this model are displayed in Figure 8(b)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 5 :</head><label>5</label><figDesc>Design intent: Different possible correct solutions: (a) and (b). RSVP chooses one based on scores, say (b). If (c) was the original intent, the visualization stage lets the user mark the boundary which ensures that a second iteration of RSVP generates (c). The third possibility of self-intersecting parts is eliminated since that would generate an inconsistently oriented solid. (a) The entire model (b) A pole (c) Pole repaired by (d) Triangulated pole merging vertices</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 9 :</head><label>9</label><figDesc>Visualization of errors: The red lines mark the faults.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 10 :</head><label>10</label><figDesc>Zoom window: The user can magnify a part of the main window to view geometry without losing context. In the zoom window, actual geometry is rendered -not a visualization of the errors. The red lines in the zoom window show the red lit backfaces showing through the crack.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>[barequet,subodh]@cs.jhu.edu; U R L : http://www.cs.jhu.edu/˜[barequet,subodh]; Supported in part by the U.S. Army Research Office under Grant DAAH04-96-1-0013.</figDesc><table><row><cell cols="2">Center for Geometric Computing,</cell><cell cols="2">Dept. of Computer</cell></row><row><cell cols="4">Science, Johns Hopkins University, Baltimore, MD 21218-</cell></row><row><cell>2694, Tel:</cell><cell cols="2">(410) 516-[5298|0060], Fax:</cell><cell>(410) 516-6134,</cell></row><row><cell>Email:</cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Locate the buckets bv and bw that contain v and w, respectively;</figDesc><table><row><cell>1. Initialization: FOR each boundary edge e set handlede : = False; FOR each boundary vertex v create a bucket bv = fvig and set bv:average:= vi;</cell></row><row><cell>2. Iteration: FOR each matching candidate e1; e 2 (where e1 = ,,! v1v2 and e2 = ,,,! w1w2): IF handlede1 = False AND maxShift " AND handlede2 = False DO Merge v1; w 2 ; Merge v2; w 1 ; Set handlede1 : = True; Set handlede2 : = True;</cell></row><row><cell>OD</cell></row><row><cell>FUNCTION Merge v;w: IF v = w RETURN; ELSE DO</cell></row><row><cell>IF bv = bw THEN RETURN;</cell></row><row><cell>ELSE Set bv = bv bw;</cell></row></table><note>Recompute bv:average;Delete bw;</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Acknowledgements</head><p>We thank Ken Fast, Greg Angelini and Jim Boudroux and Electric Boat corporation for making the model of torpedo storage and handling system available for our testing.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m">Stereolithography interface specification. SLA CAD, 3D Systems Inc</title>
		<meeting><address><addrLine>Valencia, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1989" />
			<biblScope unit="page" from="50065" to="50066" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<ptr target="http://www.autodesk.com" />
		<title level="m">Data Interchange Format</title>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
	</monogr>
	<note>AutoCAD Release 13</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">On triangulating three-dimensional polygons</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Barequet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Dickerson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Eppstein</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 12th</title>
		<meeting>12th</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Ann. ACM Symp. on Computational Geometry</title>
		<imprint>
			<biblScope unit="page" from="38" to="47" />
			<date type="published" when="1996-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Making radiosity usable: Automatic preprocessing and meshing techniques for the generation of accurate radiosity solutions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Baum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Winget</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="51" to="60" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Filling gaps in the boundary of a polyhedron</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Barequet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sharir</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Aided Geometric Design</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="207" to="229" />
			<date type="published" when="1995" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">History-driven reconstruction of polyhedral surfaces from parallel slices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Barequet</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Shapiro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization&apos;96</title>
		<meeting>IEEE Visualization&apos;96</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="149" to="156" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Automatic cad-model repair: Shell-closure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Bøhn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Wozny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Solid Freeform Fabrication Symposium</title>
		<editor>H.L. Marcus et al.</editor>
		<meeting>Solid Freeform Fabrication Symposium<address><addrLine>U. Texas, Austin, Texas USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992-08" />
			<biblScope unit="page" from="86" to="94" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A topology-based approach for shell-closure</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Bøhn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Wozny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Geometric Modeling for Product Realization</title>
		<editor>P.R. Wilson et al.</editor>
		<meeting><address><addrLine>North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="297" to="319" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Efficient rendering of trimmed NURBS surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kumar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer-Aided Design</title>
		<imprint>
			<biblScope unit="volume">27</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="509" to="521" />
			<date type="published" when="1995-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">IVECS: An interactive virtual environment for the correction of .STL files</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Mäkelä</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Dolenc</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Conference on Virtual Design</title>
		<editor>H.L. Marcus [MF96a] S.M. Morvan and G.M. Fadel</editor>
		<meeting><address><addrLine>U. California, Irvine</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-08" />
		</imprint>
	</monogr>
	<note>Some efficient procedures for correcting triangulated models</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">IVECS, interactive correction of .STL files in a virtual environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">M</forename><surname>Morvan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">M</forename><surname>Fadel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Solid Freeform Fabrication Symposium</title>
		<meeting>Solid Freeform Fabrication Symposium<address><addrLine>U. Texas, Austin, Texas USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1996-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Consistent solid and boundary representations from arbitrary polygonal data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Murali</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Funkhouser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Interactive 3D Graphics</title>
		<meeting><address><addrLine>Providence, RI</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="155" to="162" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Initial graphics exchange specification (iges) version 5.1. National Computer Graphics Association</title>
		<imprint>
			<date type="published" when="1966" />
			<publisher>Academic Press</publisher>
		</imprint>
	</monogr>
	<note>O&apos;N66] B. O&apos;Neill. Elementary Differential Geometry</note>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Generating topological information from a &apos;bucket of facets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">J</forename><surname>Rock</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Wozny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Solid Freeform Fabrication Symposium</title>
		<editor>H.L. Marcus et al.</editor>
		<meeting>Solid Freeform Fabrication Symposium<address><addrLine>U. Texas, Austin, Texas USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992-08" />
			<biblScope unit="page" from="251" to="259" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Zippered polygon meshes from range images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of ACM SIGGRAPH</title>
		<meeting>ACM SIGGRAPH</meeting>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="311" to="318" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
