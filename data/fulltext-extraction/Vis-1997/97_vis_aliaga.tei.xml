<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Architectural Walkthroughs Using Portal Textures</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><forename type="middle">G</forename><surname>Aliaga</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of North Carolina at Chapel Hill</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anselmo</forename><forename type="middle">A</forename><surname>Lastra</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of North Carolina at Chapel Hill</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Architectural Walkthroughs Using Portal Textures</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:35+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>visibility culling</term>
					<term>cells</term>
					<term>portals</term>
					<term>textures</term>
					<term>sample points</term>
					<term>morphing</term>
				</keywords>
			</textClass>
			<abstract>
				<p>This paper outlines a method to dynamically replace portals with textures in a cell-partitioned model. The rendering complexity is reduced to the geometry of the current cell thus increasing interactive performance. A portal is a generalization of windows and doors. It connects two adjacent cells (or rooms). Each portal of the current cell that is some distance away from the viewpoint is rendered as a texture. The portal texture (smoothly) returns to geometry when the viewpoint gets close to the portal. This way all portal sequences (not too close to the viewpoint) have a depth complexity of one. The size of each texture and distance at which the transition occurs is configurable for each portal.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>The visualization of architectural spaces (buildings, ships or similar structures) requires large complex models with many geometric primitives. This type of model, however, has a property that can be exploited in order to reduce the rendering complexity: the space is typically divided by walls that occlude everything on the other side. Adjacent areas are only visible through certain openings (doors, windows, etc.). Past research has focused on dividing a model into cells (rooms or predetermined subsections of the model) and portals (doors, windows and other openings). Visibility culling algorithms are used to determine which other cells are visible from a particular viewpoint and view direction. Rendering is thus reduced to the geometry of the visible cells. Exact pre-processing algorithms <ref type="bibr" target="#b0">[Airey90,</ref><ref type="bibr" target="#b12">Teller91]</ref> as well as conservative run-time algorithms <ref type="bibr" target="#b5">[Luebke95]</ref> have been developed.</p><p>In this paper, we further simplify the rendering by conditionally replacing the cells visible through a portal with a texture. Consequently, the system only needs to render the geometry of the cell containing the viewpoint and a few textured mapped polygons. Furthermore, this approach alleviates the sudden decreases in performance when a complex cluster of cells becomes visible. If the viewpoint approaches a portal, the portal texture will (smoothly) return to geometry, allowing the viewpoint to move into the adjacent cell.</p><p>This technique is a specialization of the general use of impostors introduced by <ref type="bibr" target="#b6">[Maciel95]</ref>. Portions of a static 3D model can be automatically or manually replaced with representations that are faster to render, namely 2D textures. The textures display imagery that is an approximate representation of the underlying geometry but the costs of rendering are independent of the model complexity. We can control the accuracy of the representation by regulating the number of textures. This provides us with a mechanism to control the quality of the images we are seeing, at the expense of texture memory and perhaps of swapping to the texture store of the graphics accelerator. Solving the general problem of deciding where to place textures in order to improve rendering performance is difficult <ref type="bibr" target="#b10">[Shade96,</ref><ref type="bibr" target="#b9">Schaufler96,</ref><ref type="bibr" target="#b1">Aliaga96]</ref>. The cells and portals framework allows us to formulate a set of concrete and efficient algorithms for replacing geometry with textures.</p><p>In the following section (Section 2), we present the overall problem of dynamically replacing portals with textures and discuss various strategies. In Section 3, we describe our algorithm for (smoothly) replacing the cells visible through a portal with textures. Section 4 briefly describes our implementation, while Section 5 presents the results we have obtained. Finally, we end with future work (Section 6) and some conclusions (Sections 7).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Replacing Portals with Textures</head><p>In this section, we review the technique of culling to a portal and describe the notion of portal textures. We examine the possible ways of selecting the viewpoints for the portal textures, and the possible strategies for rendering the textures. Finally, we describe a method for smoothing the transition from portal texture to geometry (and vice versa).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Portal Culling and Portal Texture Culling</head><p>Based on the location of walls and other opaque surfaces, a model can be partitioned into cells <ref type="bibr" target="#b0">[Airey90,</ref><ref type="bibr" target="#b12">Teller91]</ref>. Each cell contains a list of portals, each of which defines an opening through which an adjacent cell may be seen. <ref type="figure">Figure 1</ref> shows the top view of a cell-partitioned model. The viewpoint is inside the view cell. Since the view frustum only intersects a subset of the portals of the view cell, the cells attached to each visible portal are recursively traversed to compute all of the visible cells.</p><p>Since the model contains the location of all portals, we can compute textures to be placed in the location of the otherwise transparent portal openings. At run-time, we render the view cell normally. All visible portals of the view cell are rendered as textures and no adjacent cells are actually rendered, despite being visible. <ref type="figure">Figure 2</ref> illustrates the reduced set of cells that need to be rendered. As the viewpoint approaches a portal, we switch to rendering the geometry of the cell behind the portal. Once the viewpoint enters the adjacent cell, it becomes the view cell and the previous cell will now be rendered as a portal texture.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Texture Selection Strategies</head><p>A portal can be viewed from multiple view directions as well as multiple viewpoints. Since a single texture only produces a perspectively correct image from one viewpoint, we need to do some additional work to improve image quality when using portal textures. There are two main approaches to this problem: using image warping, or using multiple textures. The former corresponds closely to image-based rendering <ref type="bibr" target="#b2">[Chen93]</ref> and plenoptic modeling <ref type="bibr" target="#b7">[McMillan95,</ref><ref type="bibr" target="#b8">Mark97]</ref>. This approach uses depth information at each pixel to warp an image to a new viewpoint. Algorithms to re-project the images and resolve changes in the visibility of the pixels are the subject of current research. This method also does not take advantage of standard rendering hardware, thus we chose to sample the geometry behind a portal from multiple viewpoints. In the models that we have encountered, we have found the use of multiple portal textures to produce decent overall image quality. We sacrifice a controlled amount of image quality for performance.</p><p>There are various possible methods for selecting the portal texture viewpoints. We have classified these methods into three categories:</p><p>• Model independent viewpoints: define a regularly spaced set of viewpoints spanning the space on the front side of a portal <ref type="figure">(Figure 3a</ref>) without regard to particular model characteristics.</p><p>• Model dependent viewpoints: define a subset of viewpoints that do not necessarily span the entire front side of a portal. This approach requires some knowledge about model characteristics, such as the typical portal viewing directions. For example, consider a hallway with a portal to a connecting room. The portal will typically only be viewed from acute angles. By the time the viewpoint is in front of the portal, the portal will need to be rendered using geometry <ref type="figure">(Figure 3b</ref>). • Single viewpoint: a single viewpoint, usually facing the portal. This method is economical and works well when the possible or likely view directions to the portal are restricted.</p><p>In general, model-dependent viewpoints produce better results than model-independent viewpoints because they take advantage of the user's domain knowledge of the model to reduce the number of textures.</p><p>At run-time, we choose the portal texture that most closely represents the view of the geometry behind the portal from the current viewpoint. As the viewpoint moves, we continuously switch to the best texture. This generates a visual effect commonly known as popping. By increasing the number of textures, we can control the extent of the popping.</p><p>We have experimented with blending portal textures but have not found the results to be visually pleasing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Texture Creation Strategies</head><p>We've discussed strategies for selecting portal texture viewpoints. Another question is when to render the textures. If we decide to use a small number of portal textures, it's probably best to render all of them at start up. However, if we prefer to use many textures in order to improve image quality, we may not be able to render them all at start up. The next simplest strategy is to render portal textures as they are needed, and cache them for reuse.</p><p>Rendering portal textures on demand works quite well for the common application of architectural walkthroughs. In practice, users don't fly quickly through the model. They usually go to a room and examine an area in detail before proceeding to another portion of the model. Demand rendering of textures will result in slower performance when the user first enters a cell. However, as the user works in an area, that area will "sweeten" and performance will increase. This is analogous to the use of a cache to take advantage of locality.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Smooth Transition Strategies</head><p>The single portal-texture case, when only one texture is used to represent the portal from all directions, is very interesting because of its low cost. Unfortunately, this case may result in a very noticeable transition from texture to geometry (or vice versa). This is one of the worst examples of popping. We can eliminate this abrupt transition by smoothly warping the geometry represented by the portal texture from its current incorrectly projected position to its correctly projected position (or vice versa). This morphing strategy <ref type="bibr" target="#b1">[Aliaga96]</ref> is very effective and may be accomplished at very low cost (the mathematics of the warp will be explained in Section 3.3). This warp can be efficiently implemented using the graphics hardware matrix stack.</p><p>We can also use the morphing strategy to ease the transition to or from geometry even when using multiple portal textures. Although it is less important in this case, since the computational cost is minimal, it is worthwhile.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Portal Textures</head><p>In this section, we describe the algorithms we chose for the portal textures system. First, we detail our texture viewpoint selection strategy. Afterwards, we explain our morphing algorithm more precisely.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Overall Algorithm</head><p>Our system replaces geometry behind portals with portal textures sampled from a constrained set of model dependent viewpoints. We smoothly change from rendering the portal texture to geometry (and vice versa) by warping the geometry from its projected position (on the portal texture) to the correct projection for the current viewpoint. The geometric warping is particularly useful if we wish to reduce overall texture memory use by using only a single texture per portal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Constrained Model Dependent Sampling</head><p>When visualizing architectural models, we typically walk at about the same height (although we perhaps change "floors"). Without loss of generality, we assume that our head movement is typically left/right and forward/backward. We may also gaze up or down at any time. This reduces the number of necessary textures. For each portal, we allow the modeler to define a set of viewpoints constrained to lie on a semicircle of some radius on the front-side of the portal. We assume that portals are typically perpendicular to the "floor" of the model and thus fix the semicircle to lie at some typical viewing height for each portal <ref type="figure">(Figure 4</ref>).</p><p>For each portal of the model, we need to define (or assume reasonable default) values for the following parameters:</p><p>(a) Viewing Height: the typical viewing height of the portal.</p><p>(b) Sampling Distance: the radius of the constraining semicircle from the portal.</p><p>(c) Transition Distance: the distance from the portal at which to perform a portal texture to geometry transition (or vice versa).</p><p>(d) Viewing Angles: the set of points on the semicircle to use as texture viewpoints. We have found the use of multiple disjoint angular spans of equally spaced viewpoints to yield good results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Morphing</head><p>In order to perform a smooth portal texture to geometry transition (or vice versa), we need to smoothly re-project the geometry behind the portal from its projected position on the texture to its correct position <ref type="bibr" target="#b1">[Aliaga96]</ref>. This warp corresponds to an inferred perspective warp <ref type="bibr" target="#b13">[Wolberg90]</ref>. In addition, the transformation must be set up so that zbuffering works properly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Setup</head><p>A portal texture corresponds to an image of the model seen through a portal, defined by four vertices v 0 -v 3 and a sample point p a . We denote this viewing frustum projection by</p><formula xml:id="formula_0">[v 0 -v 3 , p a ].</formula><p>In general, when we wish to return the cells behind the portal to geometry, our current viewpoint will be at some point p b . We need to smoothly re-project the geometry over the next several (e.g., five) frames, from the projection</p><formula xml:id="formula_1">[v 0 -v 3 , p a ] to the projection [v 0 -v 3 , p b ]</formula><p>. This implies that, despite having our eye at point p b , we need to project the geometry onto the portal plane as if we were at some position between p a and p b . Thus, we re-project the geometry using the interpolated view frustum Similarly, the interpolated frustum can be defined by a model-space transformation M i . and a projection P i . The final (warped) frustum is defined by M w = P i M i . and P w = W ib , where W ib is the perspective warp from p i to p b . This sequence of transformations is illustrated in <ref type="figure">Figure 5</ref>.</p><formula xml:id="formula_2">[v 0 -v 3 , p i ] where p i is a</formula><p>To construct the warp matrix W ib , we employ a fourcorner mapping (assuming planar quadrilaterals). We project the vertices v 0 -v 3 using P i M i and P b M b and use their projected positions to construct the four corner mapping.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Proper Occlusion</head><p>In order to resolve occlusion properly, we must set up the matrix W ib so that the final transformation matrix will produce z-values that correspond to the projection onto</p><formula xml:id="formula_3">[v 0 -v 3 , p i ].</formula><p>In essence, we wish to transform the x and y coordinates and pass the original projected z-value through the warp unaffected (at least until the homogeneous divide). We can accomplish this by placing the nine coefficients of the warp matrix as follows: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Implementation</head><p>We implemented the portal-textures system on a Silicon Graphics Onyx (250 MHz R4400, 2GB main memory) with Infinite Reality graphics (containing 64MB of texture memory) and on an Indigo2 (250 MHz R4400, 128MB memory) with Max Impact graphics (and 4MB of texture memory). The system is coded in C++, uses the OpenGL graphics library, and employs a userconfigurable amount of host memory and texture memory.</p><p>At run-time, the system renders the portal textures to host memory, and loads the textures into the texture memory of the graphics accelerator as needed (using the texture binding and copy commands of OpenGL). For simplicity, all textures are 256x256 pixels in size and 8 bits per color component. If there is no free space in the texture memory, we replace older portal textures that are no longer in view. To decide which textures in accelerator memory to replace, we use a simple working-set algorithm. Portal textures are usually computed on demand, although they could instead be computed at start up.</p><p>The contents of each cell are maintained as a collection of geometric primitives organized in a spatial partitioning tree (an octree). When a cell is flagged as visible, its contents are culled to the current frustum and rendered. Portals are culled to the current frustum using their screen-space bounding rectangle.</p><p>The overall visibility-determination algorithm is summarized by the following pseudo-code (the top-level function is assumed to be initially called with the view cell and the view frustum): </p><formula xml:id="formula_4">Visibility(cell,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Results</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Performance</head><p>We tested our system using two architectural models. The first model, named Brooks House (Color plates 1-5), is that of a large one-story house modeled using 528,000 polygons. The second model, the Haunted House (Color plates 6-7), is of a two-story house and consists of 214,000 polygons. Both of these models have been divided into cells and portals. The more complex Brooks House has 19 cells and 52 portals, while the Haunted House has 7 cells and 12 portals.</p><p>We traversed a path through each model and recorded the number of primitives rendered per frame as well as the overall frame time (Figures 6 through 9) using (a) viewfrustum culling <ref type="bibr" target="#b3">[Clark76]</ref>, (b) portal culling, and (c) portal-texture culling. For these experiments, we created portal textures for every degree, over viewing directions ranging from 30 to 120 degrees in front of the portals, and pre-computed the textures (the next section has some observations about the cost of portal texture rendering). </p><formula xml:id="formula_5">p a p b p i d i p a p b p i d b v 0 v 1 v 2 v 3 v 0 v 1 v 2 v 3 P i M i W ib P b M b</formula><p>The Brooks House model was rendered on an Onyx with Infinite Reality graphics hardware. <ref type="figure">Figures 6 and 7</ref> show the number of polygons rendered and frame time, respectively. We achieved an overall speedup of 3.3 with portal textures vs. portal culling and of 4.6 vs. viewfrustum culling. The Haunted House model was rendered on an Indigo2 with Max Impact graphics hardware. The results are plotted in <ref type="figure">Figures 8 and 9</ref>. Speedups were 2.6 for portal textures over portal culling and 4.3 for portal textures over view-frustum culling. Typically, one to three portal textures are rendered in each frame.</p><p>Notice how the large variations in rendering performance have been significantly reduced. This is due primarily to the fact that a texture can be rendered in time independent of the complexity of the geometry it represents. However, computing textures on demand may also introduce some longer frame times.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Portal Texture Creation</head><p>What if we decide to compute portal textures on demand? <ref type="figure">Figure 10</ref> shows frame rate with textures always computed on demand (a "cold cache") and sampling ranges of one and ten degrees per portal texture. We used the Brooks House model and the same path used for the results described in the previous section. Here the overall speedups are 1.8 for the finely sampled case and 2.8 for the coarsely sampled rendering.</p><p>Although the performance was still quite good, we have lost the very steady frame rate that we achieved with the pre-computed portal textures. In fact, we sometimes peaked above the portal-culling case because some scenes in the model forced us to render textures for several rooms in one frame (a room visible in a doorway that was visible in another doorway, etc). However, in general we expect that our performance will be bounded by the  geometry rendered using only portal culling, plus some extra overhead.</p><p>Computing portal textures on demand is a good strategy if the typical use of the walkthrough program is to examine areas of the model in detail. Although the frame rate may be low when we first enter a room, it will get better as we stay in that room.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">The Single Portal-Texture Case</head><p>The use of a single portal texture per portal gives us the best and steadiest performance, albeit with lowest image fidelity. However, we have observed that with morphing at transitions, the user feels very comfortable interacting with the model. Since it is trivial to pre-compute all of the portal textures when loading a model, variations in frame rate are small. This is the best choice for a tight rendering budget.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Image Quality</head><p>Increased performance is achieved at the expense of some image quality. In general, a greater number of textures, together with properly configured portal parameters and the use of morphing, will improve the image quality. In our video, we show the image quality produced by varying the number of textures. One texture per degree gives excellent quality but may be too expensive for some applications.</p><p>The amount of texture memory on the graphics accelerator has not proven to be a problem since we only needed one to three textures per frame, and the cost of texture replacement is quite low. We have timed the texture-paging rate of our SGIs. On our Onyx/IR, we can page a 256x256 texture from host to texture memory in~1</p><p>.8 milliseconds. Our Indigo2/Max Impact pages the same size texture in ~2.2 milliseconds. Thus our texture memory and texture paging requirements are well within reason.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">Future Work</head><p>The extensions of most immediate benefit to this system are those that might automatically compute the best portal viewpoints and view directions to use for creating the textures. Perhaps through the use of exact cell and portal visibility calculations <ref type="bibr" target="#b0">[Airey90,</ref><ref type="bibr" target="#b12">Teller91]</ref>, we could locate areas of the model from which each portal is visible and sample only from those areas.</p><p>Once we gather more experience with portal textures, we may decide to reduce the constraint that texture viewpoints must lie on a single semicircle. Perhaps modelers will wish to have more freedom to place texture viewpoint locations. An interactive portal-texture placement program would be useful.</p><p>At the moment, we are not taking advantage of idle time to render portal textures that may be needed in the future. We could enhance the system to perform incremental rendering in one of several ways. The easiest would be to pre-render the portal textures nearest to our current viewpoint whenever the graphics system is idle (e.g., when the user is not moving). An approach that would give better performance even when moving, is to assign a portion of each frame time to the rendering of future portal textures. We could perhaps use a simple prediction of the next several viewpoints in order to determine the best set of textures to pre-render.</p><p>The portal-textures approach is best suited to diffuse environments. This has not been a problem in practice because models for architectural walkthroughs are typically pre-illuminated using radiosity methods. However, if we wish to add specular effects, we may be able to store additional parameters, such as surface normals, at each texel and defer shading <ref type="bibr" target="#b4">[Lastra95]</ref>.</p><p>Finally, we could look to plenoptic warping <ref type="bibr" target="#b7">[McMillan95]</ref> in an effort to eliminate popping while also reducing texture memory usage. To make this practical would require specialized hardware.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Conclusions</head><p>We have demonstrated the benefits of using portal textures. This approach allows us to reduce the rendering complexity principally to that of the cell containing the viewpoint. The adjacent cells, visible through the portals, are represented by textures. For models where the use of portals is advantageous, portal textures increase performance by a constant factor, based on the number of frames a texture can be reused. Improvement is especially good when long sequences of portals are present.</p><p>We have shown two cases, one where a number of portal textures are stored (in host or texture memory) for each portal and another where only a single portal texture is stored. Morphing can be used to eliminate the visual popping effect at portal texture to geometry transitions. Using multiple portal textures can trade off quality for speed. The single portal-texture case is especially interesting because (using trivial pre-computation) it dampens the fluctuations in frame time that occur when several rooms become suddenly visible through doorways.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Acknowledgments</head><p>We are greatly indebted to Dave Luebke for many fruitful discussions about the portals system. We would also like to thank the Ultra64/Nintendo64 SGI Team for the opportunity to try out portal textures on their hardware. Furthermore, we would like to thank Leonard McMillan for his insights regarding re-projections. In addition, we are also grateful to the many late night inhabitants of the graphics lab.</p><p>The Brooks House model is courtesy of many generations of students and members of the UNC Walkthrough team. The Haunted House model was created by Dave Luebke and Mike Goslin.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>point along the line segment p a -p b . Then, we use an inferred perspective transformation to warp the projection plane, defined by frustum [v 0 -v 3 , p i ], to appear as if it were seen from the current viewpoint p b . The current frustum, [v 0 -v 3 , p b ], can be expressed using a model-space transformation M b and a projection P b .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>0</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>)LJXUH D 0RGHOLQGHSHQGHQW DQG E PRGHOGHSHQGHQW YLHZSRLQWV IRU SRUWDO 3 ,Q WKLV FDVH VLQFH ZH H[SHFW WR UHSUHVHQW WKH SRUWDO DV JHRPHWU\ E\ WKH WLPH ZH DUULYH DW ORFDWLRQ $ LW LV DGYDQWDJHRXV WR RQO\ UHQGHU SRUWDO WH[WXUHV IURP WKH PRVW OLNHO\ YLHZ ORFDWLRQV LQ DUHD % DQG &amp;</figDesc><table><row><cell>P</cell><cell>P</cell><cell></cell></row><row><cell>B</cell><cell>A</cell><cell>C</cell></row><row><cell>(a)</cell><cell>(b)</cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_5"><head></head><label></label><figDesc>)LJXUH &amp;ROGFDFKH IUDPH WLPHV IRU WKH %URRNV +RXVH PRGHO XVLQJ RQH SRUWDO WH[WXUH VDPSOH IRU HYHU\ GHJUHHV YV RQH SRUWDO WH[WXUH SHU GHJUHH</figDesc><table /><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>This research was supported in part by the Defense Advanced Research Projects Agency, ISTO Order No. A410 and DABT63-93-C-0048 ("Enabling Technologies and Application Demonstrations for Synthetic Environments"), the National Science Foundation, Grant No. MIP-9306208, and a University of North Carolina Dissertation Fellowship.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Towards Image Realism with Interactive Update Rates in Complex Virtual Building Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Airey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Rohlf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Frederick</forename><surname>Brooks</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symp. on Interactive 3D Graphics</title>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="41" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Visualization of Complex Models Using Dynamic Texture-Based Simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Daniel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Aliaga</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;96</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="101" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">View Interpolation for Image Synthesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Shenchang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lance</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Williams</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="volume">93</biblScope>
			<biblScope unit="page" from="279" to="288" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Hierarchical Geometric Models for Visible Surface Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><surname>Clark</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">CACM</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">10</biblScope>
			<biblScope unit="page" from="547" to="554" />
			<date type="published" when="1976-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Real-Time Programmable Shading</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anselmo</forename><surname>Lastra</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steven</forename><surname>Molnar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Olano</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Yulan</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Symp. on Interactive 3D Graphics</title>
		<meeting>Symp. on Interactive 3D Graphics</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="59" to="66" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Portals and Mirrors: Simple, Fast Evaluation of Potentially Visible Sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Georges</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Symp. on Interactive 3D Graphics</title>
		<meeting>Symp. on Interactive 3D Graphics</meeting>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="105" to="106" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Visual Navigation of Large Environments Using Textured Clusters</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paulo</forename><surname>Maciel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Shirley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symp. on Interactive 3D Graphics</title>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="page" from="95" to="102" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Plenoptic Modeling: An Image-Based Rendering System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leonard</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gary</forename><surname>Bishop</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995" />
			<biblScope unit="volume">95</biblScope>
			<biblScope unit="page" from="39" to="46" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Post-Rendering 3D Warping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">R</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Leonard</forename><surname>Mcmillan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gary</forename><surname>Bishop</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symp. on Interactive 3D Graphics</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="7" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A Three Dimensional Image Cache for Virtual Reality</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gernot</forename><surname>Schaufler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wolfgang</forename><surname>Sturtzlinger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics &apos;96</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="227" to="235" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><surname>Shade</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dani</forename><surname>Lischinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>David</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Hierarchical Image Caching for Accelerated Walkthroughs of Complex Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tony</forename><surname>Salesin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Snyder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 96</title>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="75" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Visibility Preprocessing For Interactive Walkthroughs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Seth</forename><surname>Teller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carlo</forename><forename type="middle">H</forename><surname>Séquin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH 91</title>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="61" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Digital Image Warping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">George</forename><surname>Wolberg</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<publisher>IEEE Computer Society Press</publisher>
			<pubPlace>Los Alamitos, California</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
