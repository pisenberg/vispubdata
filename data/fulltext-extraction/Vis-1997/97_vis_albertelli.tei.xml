<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Efficient Subdivision of Finite-Element Datasets into Consistent Tetrahedra</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Guy</forename><surname>Albertelli</surname></persName>
							<email>albertel@cis.ohio-state.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">The Ohio State University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roger</forename><forename type="middle">A</forename><surname>Crawfis</surname></persName>
							<email>crawfis@cis.ohio-state.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer and Information Science</orgName>
								<orgName type="institution">The Ohio State University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Efficient Subdivision of Finite-Element Datasets into Consistent Tetrahedra</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:35+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>tetrahedralization</term>
					<term>mesh subdivision</term>
					<term>volume rendering</term>
					<term>flow visualization</term>
					<term>isosurfaces</term>
					<term>metrics</term>
					<term>irregular grids</term>
				</keywords>
			</textClass>
			<abstract>
				<p>This paper discusses the problem of subdividing unstructured mesh topologies containing hexahedra, prisms, pyramids and tetrahedra into a consistent set of only tetrahedra, while preserving the overall mesh topology. Efficient algorithms for volume rendering, iso-contouring and particle advection exist for mesh topologies comprised solely of tetrahedra. General finiteelement simulations however, consist mainly of hexahedra, and possibly prisms, pyramids and tetrahedra. Arbitrary subdivision of these mesh topologies into tetrahedra can lead to discontinuous behavior across element faces. This will show up as visible artifacts in the iso-contouring and volume rendering algorithms, and lead to impossible face adjacency graphs for many algorithms. We present here, various properties of tetrahedral subdivisions, and an algorithm for determining a consistent subdivision containing a minimal set of tetrahedra.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.">Introduction</head><p>A tetrahedron is the most basic of solid primitives. It has several attractive features for visualization. It is convex. It is defined by four vertices, which can usually be specified in an independent order. A function sampled at these four vertices leads to a unique linear function throughout the tetrahedra. This is a very useful property for interpolation and reconstruction. For these reasons, many author's have developed visualization algorithms for tetrahedral meshes. Shirley and Tuchman <ref type="bibr" target="#b10">[Shirley90]</ref>, describe an efficient algorithm for volume rendering tetrahedra in their Projected Tetrahedra algorithm. Kenwright and Lane <ref type="bibr" target="#b3">[Kenwright96]</ref> describe a technique for efficient particle tracing through tetrahedral meshes. They split the curvilinear cells in their CFD data into five tetrahedra on the fly using an odd/even scheme on the computational coordinates. <ref type="bibr">Yagel,</ref><ref type="bibr">et. al. [Yagel96]</ref> describe a volume rendering technique that calculates slices through a finite-element mesh consisting of strictly tetrahedra. Several additional authors describe algorithms that work only on tetrahedral meshes (e.g., <ref type="bibr" target="#b0">[Cignoni96]</ref>, <ref type="bibr" target="#b4">[Knight96]</ref>). Many simulations however, use mesh topologies consisting of primarily hexahedra, with occasional prisms, pyramids and tetrahedra.</p><p>The problem of subdividing a finite-element mesh into tetrahedra is currently unknown. An inconsistent subdivision will have the adjacent face of two primitives split differently for each primitive. This inconsistency emanates as a discontinuity in the underlying data field when using tri-linear interpolation (or many other interpolation schemes). This discontinuity is readily visible when taking an iso-contour of the data, as illustrated in <ref type="figure">Figures 1 and 2</ref>. In <ref type="figure">Figure 1</ref>, a regular mesh is subdivided by splitting each voxel into five tetrahedra randomly. Several holes and shading artifacts are clearly visible. <ref type="figure">Figure 2</ref>, shows the same data set with a consistent subdivision. Similar artifacts or numerical instabilities occur using other visualization techniques. An efficient and robust algorithm for subdividing irregular meshes into tetrahedra is needed in order to allow us to use these visualization algorithms.</p><p>We will first discuss similar work in Section 2. Section 3 of this paper will present our labeling scheme for discussing subdivisions and present the possible set of subdivisions (without adding points or edges) for a hexahedron. This is perhaps the heart of the paper, and several interesting observations will be presented. Section 4 will discuss the possible subdivisions of pyramids and prisms. Section 5 will then show some characterization experiments we performed to determine what constraints we could impose on a subdivision. Section 6, gives an overview of a simple greedy algorithm we developed for consistently subdividing meshes into tetrahedra. Section 7 presents results on both test data and some real data sets. Finally, we conclude with some future research directions in Section 8.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Previous Work</head><p>Calculating a 3D tetrahedralization from scattered data points is a well know problem, and the 3D extension to the Delauney triangulation algorithm <ref type="bibr" target="#b8">[Preparata85]</ref> is the most prevalent solution. This technique can be applied to unstructured meshes, by simply throwing out the mesh topology. Not only does this destroy the local topology of the mesh, but also ignores the boundary of the original mesh, leading to representations of data outside of the normal problem domain. What is needed is a technique that can produce a consistent tetrahedralization while preserving the original mesh. This implies that no edges or data points can be removed, but only added. Furthermore, any points added need to be within the original volume. Techniques to constrain the Delauney triangulation do exist, but these are usually only applied at the boundary.</p><p>Several authors describe how to decompose a uniform or curvilinear mesh into tetrahedra [Garrity90], <ref type="bibr" target="#b5">[Max90]</ref>, <ref type="bibr" target="#b10">[Shirley90]</ref>, <ref type="bibr" target="#b3">[Kenwright96]</ref>. Here, each voxel or hexahedra is subdivided into five tetrahedra. An alternating pattern of two subdivisions is used to ensure consistency. Max <ref type="bibr" target="#b6">[Max92]</ref> employs a subdivision of six tetrahedra per curvilinear cell for a global climate simulation to handle non-planar faces in the data. In their flow volumes paper [Max93], they also describe a technique for generating a complex unstructured mesh with prisms, such that the prisms can be consistently subdivided into tetrahedra. For curvilinear data sets, care must be taken when the mesh folds back upon itself. Here, a simple alternating scheme fails at the merged seam when the periodic length of the cells is odd. As can be seen in Section 3, this can easily be fixed by using a subdivision into six tetrahedra at the seam. For finite-element meshes, with arbitrary topologies, a robust algorithm is needed that can consistently subdivide the mesh into tetrahedra.</p><p>If we are only interested in consistency, then a subdivision of a hexahedron into 24 tetrahedra would ensure consistency. Here, each face is split into four triangles about either the face centroid, or the diagonal intersections, and each triangle is then connected to the hexahedron's centroid to construct tetrahedra. Since each face produces four tetrahedra, and there are six faces, a total of 24 tetrahedra are produced. The draw back, of course, is that the efficient algorithms we are trying to use have a cost proportional to the total number of tetrahedra. Our goal therefore is to construct a tetrahedralization that is consistent and has as few tetrahedra as possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">Possible Hexahedron Subdivisions</head><p>It is only possible to subdivide a hexahedron into either five or six tetrahedra without adding additional data points. By adding the hexahedron centroid as a data point, we can produce a subdivision into 12 tetrahedra, where each face is still split by a single diagonal. From here, we can progressively add face centroids, splitting a face into four triangles to produce 14, 16, 18, 20, 22 or 24 tetrahedra. Ideally, we would like to be able to subdivide a mesh using splittings into either five or six tetrahedra. This avoids the large jump to 12, but more importantly, avoids the difficulties in adding new data points to a mesh. This section will examine possible splittings of a single hexahedron.</p><p>Consider a single face of a hexahedron. There are two possible diagonals along which the face can be split into tetrahedra. We can encode the diagonal direction in a one bit entity, with a zero indicating the bottom-left to upper-right diagonal and a one indicating the upper-left to lower-right diagonal. For a hexahedron therefore, we have a six bit entity that can encode all of the diagonal directions. Let's order the bits <ref type="bibr">(</ref> This table states that the "front" face has a zero bit for the diagonal slice from node 1 to node 6 and a one bit for the diagonal slice from node 2 to node 5. The other faces are similarly labeled. This six-bit vector leads to 64 possible diagonal sets. Of these 64, it can be shown <ref type="table" target="#tab_2">(Table 2</ref>) that 46 can easily be subdivided into either 5 or 6 tetrahedra. The remaining 18 configurations present problems or are configurations we need to avoid. There are exactly two possible configurations that lead to subdivisions into five tetrahedra. These are labeled 010101 and 101010. The two alternating bit patterns. The remaining 44 "good" configurations can be subdivided into 6 tetrahedra (2 prisms each subdivided into three tetrahedra).</p><p>Examining all 64 of these cases leads to some interesting insights. All of the 18 "bad" cases can actually be converted to a "good" case with a single bit change. In fact, eight of these can take a single bit change in all but one face, and changing the bit of the appropriate face will produce one of the five tetrahedra configurations. Four other "bad" cases can take a bit change in any of four faces to produce a "good" case, but require three bit changes to produce one of the five tetrahedra configurations. Finally, six of the "bad" cases will take a bit change in only two of the faces, and require 2 bit changes to produce a five tetrahedra configuration.</p><p>We can also classify the "bad" cases into two distinct classes. Twelve of the cases actually produce two prisms that can be subdivided. The problem arises on the interior face, where an inconsistent diagonal is chosen for the two prisms. This is annotated as "interior" in <ref type="table" target="#tab_2">Table 2</ref>. The remaining 6 bad cases have bit patterns such that opposite faces have diagonals in opposite directions. Alternating directions would thus have a 2-bit pattern of either 01 or 10 for each of the three sets of opposing faces. This leads to 8 possible configurations where the opposing faces have different diagonals. Two of these are the valid subdivisions into 5 tetrahedra, and the remaining 6 are undividable. These six require the 2 bit changes to produce a five tetrahedra configuration.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.">Pyramids and Prisms</head><p>Of course, many finite-element meshes consist of other solid primitives (and even non-solid primitives). An analysis of prisms and pyramids was also conducted, and produced similar promising results. Pyramids are especially easy to deal with. They have a single quadrilateral face, which can be split about either 1 2 3 4 5 6 7 8 <ref type="figure">Figure 3</ref>. Hexahedron numbering scheme.</p><p>diagonal to produce two tetrahedra. Thus, a pyramid abutted against a hexahedron face, will not impose any additional constraints on the system. Note, that the authors are assuming triangular faces are not abutted against quadrilateral faces in any real finite-element meshes.</p><p>As pointed out in <ref type="bibr">Max,</ref><ref type="bibr">et. al. [Max93]</ref>, a prism can be split into three tetrahedra. There are three quadrilateral faces that need to be split, bottom, left and right. If we choose diagonals, such that none of the them share a common vertex, then an inconsistent state exists, and a valid subdivision does not exist. A similar scheme of subdividing about the prism centroid can be used for bad configurations. This would produce eight tetrahedra, rather than three, and again, leave us with the additional centroid point to manage. Of the eight possible configurations, there are only two bad cases where the diagonals do not touch. Note, that if two diagonals touch, we have a tetrahedra containing the shared vertex. Separating this from the prism, yields a pyramid which can be split arbitrarily into two tetrahedra. Therefore, we can constrain any two faces of a prism and pick the appropriate diagonal for the remaining face. Since two out of eight possible configurations (25%) are bad choices, prisms impose perhaps more constraints on our system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.">Constrained Subdivisions</head><p>Since a substantial number of cases can be subdivided into 5 or 6 tetrahedra, our next investigation was examining the effect that flipping a diagonal on one of the bad cases would have on the adjacent hexahedra. Our first question was whether given a 2x2x2 set of hexahedra, in which all of the 24 external faces had their diagonals constrained, could a consistent subdivision always be found. Amazingly, all 16 million possible external face assignments led to consistent internal subdivisions. In fact, on average each configuration could be subdivided in over 290 different sets of tetrahedra. The twelve unconstrained internal faces gives us plenty of freedom in choosing a subdivision. Further constraining the systems, we examined a 2x2x1 set of hexahedra. Here, we have 16 external faces, over 65 thousand possible diagonal assignments, and only 4 internal faces whose diagonals can be selected for a possible tetrahedralization. Of these possible configurations, only 1520 or 2.32% could not be subdivided into 5 or 6 tetrahedra. Similarly, we also examined a 2x1x1 set of hexahedron, having only a single internal face. Of the 1024 possible external diagonal settings, 110 or 12% led to configurations that could not be consistently subdivided.</p><p>In a single hexahedra, if five faces are randomly assigned, for only sixteen of the 192 cases (8.3%), it is impossible to choose the diagonal direction on the remaining face, such that a good configuration results. Additionally, for more than half (100 of 192) of the cases, either choice of the remaining diagonal leads to a good subdivision.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.">A Simple Greedy Algorithm</head><p>Our initial idea was to mark each face to be split by the shortest diagonal. This provides well shaped tetrahedra and ensures consistency. We could then use this as a starting point to determine a tetrahedralization, changing diagonal choices as needed. A further refinement to this would be to associate weights with each diagonal, such that those faces that are really skewed would show a strong preference to be split by the shortest diagonal. The preceding analysis illustrates that any 2x2x2 set of hexahedra with exterior constraints can be consistently subdivided, so if we employ a greedy algorithm to assign subdivisions, we can always re-coupe in a relatively small area. In other words, a configuration can not be produced, that can not be corrected within a small localized area.</p><p>Our algorithm performs a depth first traversal of a finite-element mesh, starting at a random element. A face adjacency graph is needed to perform the traversal. As we march through the mesh, we mark those zones that have already been processed. If we reach a point where all of the current zone's neighbors have already been processed, we then take the next active cell on the wait list. As we process a cell, we randomly choose a neighbor to process next. Hence, we have a random walk through the mesh. All other neighboring zones that have not been marked are put on the wait list.</p><p>A problem arises if we encounter an area where a consistent subdivision can not be achieved without adding centroids. We have two possible solutions for handling this. In the first alternative, we back up to the zone we just came from and try an alternative configuration. In practice, this solves many of the problems. Alternatively, we can pick a good subdivision for the zone giving us difficulty and then try to fix any neighbors that are subsequently in a bad configuration state. We choose to implement the first approach.  <ref type="table" target="#tab_2">000000  yes  6  0  000001  yes  6  1  000010  yes  6  2  000011  yes  6  3  000100  yes  6  4  000101  yes  6  5  000110  no  Interior  6  000111  yes  6  7  001000  yes  6  8  001001  no  Interior  9  001010  yes  6  10  001011  yes  6  11  001100  yes  6  12  001101  yes  6  13</ref>   Given an arbitrary mesh, it is not clear if a valid subdivision is possible without adding zone or face centroids. This is a problem that the Computational Geometry community has not seemed to address yet. Ruppert and Seidel <ref type="bibr" target="#b9">[Ruppert92]</ref> shows that the problem of subdividing a single concave polyhedra is NPcomplete. Our finite-element meshes are certainly concave, but the individual elements are typically convex and of small dimension. The minimal subdivision of an unstructured mesh is still a future area of research. Since it is also unknown whether a valid subdivision should exist, we avoid endless alterations by stopping the subdivision process after several failed attempts. We handle the bad zone by splitting it about its zone centroid, producing 12 tetrahedra in these rare cases.</p><p>Storing a valid subdivision of a large mesh would be prohibitively expensive. Instead, we simply store with each zone the resulting six-bit vector that dictates the needed splitting. This allows for the use of algorithms optimized to handle hexahedra to work efficiently, and those that require tetrahedra can quickly and easily subdivide the hexahedra (or prisms and pyramids) into the needed tetrahedra on the fly. The six-bit vector is actual stored as a byte, leaving additional bits to flag zones that need to generate a face centroid. This amounts to a fairly insignificant increase in storage for most finite-element meshes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.">Results</head><p>The real results of this research is more the analysis described in Sections 3 through 5. We tested our algorithm first on regularly gridded data so that we would have an optimal subdivision to compare with. We generated regular grids with several aspect ratios, randomly fixed an increasing number of diagonal slices in order to impose some constraints, and then applied our algorithm. Our algorithm always tries to use one of the subdivisions into five tetrahedra first, before attempting any of the prism subdivisions. With no constraints, we always produce the expected five tetrahedra per cell. The average number of tetrahedra per hexahedra over several runs with varying degrees of constraints was 5.5 tetrahedra per cell. Therefore, half of the hexahedra were split into five tetrahedra and half into six tetrahedra. This amounts to a ten percent increase over the optimal solution without constraints. We also never encountered a bad case that could not be handled by backtracking one zone and trying alternative configurations.</p><p>We applied the algorithm to several data sets, summarized in <ref type="table" target="#tab_4">Table 3</ref>. The shuttle data, is part of the IRIS Explorer distribution, as is the blunt fin data. The blunt fin is actually a curvilinear grid, so produces trivial results. We also applied it to some sample data distributed with AVS (avs.inp, and box10.inp). The submarine data is courtesy of Lawrence Livermore National Laboratory (LLNL). We are still searching for more complex mesh topologies.</p><p>The table lists the number of hexahedra, the resulting number of tetrahedra, and the time to build the adjacency graph. The time to actually perform the subdivision was less than a second on all of these data sets, once the adjacency graph was available. A theoretical bound on the minimal number of tetrahedra is five per hexahedra. Both the bluntfin and the box10 produce this minimum, as expected.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Data set</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8.">Future Work</head><p>There is still some work needed in the analysis of the subdivision of a single hexahedron. Several possible symmetries can be employed to reduce the total set of configurations. More enumeration of which bits will turn good cases into bad cases, and visa versa, would also aid in the development of more efficient algorithms.</p><p>There are also several theoretical questions that have arisen as part of this investigation. We have already mentioned the question of whether a mesh is subdividable without additional data points.</p><p>The subdivision problem can be expressed in terms of graph theory. If we start off with the initial adjacency graph of the mesh, the goal then is to expand each node into either five or six new nodes (for a hexahedron) and refine the connections. Other questions are: Can a mesh be subdivided using strictly a five tetrahedra split? What is the optimal (fewest tetrahedra) splitting of a mesh? Hopefully, this research will stimulate interest in these problems.</p><p>Finally, many improvements into the simple algorithm presented here are possible. A genetic or simulated annealing algorithm may be ideally suited for determining a (locally) optimal subdivision. Processing the zones in larger blocks may avoid any bad zones and backtracking. Our current algorithm also makes no use of the kernels of insight uncovered in Section 3. More intelligent picking up the splittings would leverage this information.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Figure 4. Simple Prism Labelling</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>or faces) such that opposing faces have adjacent bits, say {front | back | left | right | bottom | top}.Figure 3shows a hexahedron with eight numbered vertices. Our bit assignment is thus:</figDesc><table><row><cell></cell><cell>Slice</cell><cell></cell></row><row><cell>Face</cell><cell>0</cell><cell>1</cell></row><row><cell>Bottom</cell><cell>1 to 6</cell><cell>2 to 5</cell></row><row><cell>Top</cell><cell>4 to 7</cell><cell>3 to 8</cell></row><row><cell>Left</cell><cell>1 to 8</cell><cell>4 to 5</cell></row><row><cell>Right</cell><cell>2 to 7</cell><cell>3 to 6</cell></row><row><cell>Front</cell><cell>1 to 3</cell><cell>2 to 4</cell></row><row><cell>Back</cell><cell>5 to 7</cell><cell>6 to 8</cell></row><row><cell cols="3">Table 1. Diagonal slice labeling</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 .</head><label>2</label><figDesc>Possible Hexahedron subdivisions</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_4"><head>Table 3 .</head><label>3</label><figDesc>Number of tetrahedra generated.</figDesc><table /><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We would like to thank Nelson Max for initially turning the second author onto this problem. Rephael Wenger provided assistance and pointers into the computational geometry literature, as well as many helpful comments. The Post data was provided by Mark Christon from the Lawrence Livermore National Laboratory. We would also like to thank the reviewers who made several suggestions to improve the paper.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Cignoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Montani</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Optimal Isosurface Extraction from Irregular Volume Data</title>
	</analytic>
	<monogr>
		<title level="m">Visualization Symposium</title>
		<meeting><address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Raytracing Irregular Volume Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">P</forename><surname>Garrity</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="35" to="40" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Interactive Time-Dependent Particle Tracing Using Tetrahedral Decomposition</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">N</forename><surname>Kenwright</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Lane</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="120" to="129" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Visualizing Unstructured Flow Data Using Dual Stream Functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Knight</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Mallinson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="355" to="363" />
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Area and Volume Coherence for Efficient Visualization of 3D Scalar Functions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="27" to="33" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
		<title level="m">Visualizing Wind Velocities by Advecting Cloud Textures. Visualization &apos;92</title>
		<meeting><address><addrLine>Boston, Massachusetts</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
	<note>Max93</note>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Becker</surname></persName>
		</author>
		<title level="m">Flow Volumes for Interactive Vector Field Visualization. Visualization &apos;93</title>
		<meeting><address><addrLine>Los Alamitos, CA</addrLine></address></meeting>
		<imprint>
			<publisher>IEEE Computer Society Press</publisher>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Computational Geometry: An Introduction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">P</forename><surname>Preparata</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">I</forename><surname>Shamos</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1985" />
			<publisher>Springer-Verlag</publisher>
			<pubPlace>New York</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">On the difficulty of triangulating three-dimensional non-convex polyhedra</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Ruppert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Seidel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Computational Geometry</title>
		<imprint>
			<biblScope unit="volume">7</biblScope>
			<biblScope unit="page" from="227" to="253" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">A Polygonal Approximation to Direct Scalar Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tuchman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="63" to="70" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">M</forename><surname>Reed</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Hardware Assisted Volume Rendering of Unstructured Grids by Incremental Slicing</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m">Volume Visualization Symposium</title>
		<meeting><address><addrLine>San Francisco, CA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
