<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Interactive Visualization of Aircraft and Power Generation Engines</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lisa</forename><forename type="middle">Sobierajski</forename><surname>Avila</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">GE Corporate Research &amp; Development Niskayuna</orgName>
								<address>
									<postCode>12309</postCode>
									<region>New York</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><surname>Schroeder</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">GE Corporate Research &amp; Development Niskayuna</orgName>
								<address>
									<postCode>12309</postCode>
									<region>New York</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Interactive Visualization of Aircraft and Power Generation Engines</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:35+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>In this paper we present a system for interactively visualizing large polygonal environments such as those produced by CAD systems during the design of aircraft and power generation engines. Our method combines view frustum culling with level-of-detail modeling to create a visualization system that supports part motion and has the ability to view arbitrary sets of data. To avoid long system start-up delays due to data loading, we have implemented our system using a dynamic loading strategy. This also allows us to interactively visualize more data than could fit in memory at one time.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Geometric environments consisting of tens of millions of polygons are common during the design of aircraft and power generation engines. Since the practice of physical mock-ups has been nearly abandoned, we require a digital replacement. Unfortunately such large polygonal environments are difficult to visualize interactively despite recent advances in computer graphics hardware and systems. The challenge increases if the geometric models must be visualized on older hardware or lowend graphics platforms.</p><p>In order to satisfy our visualization requirements, we developed a system for interactively rendering large polygonal environments. We identified four major goals for this project. First, we want a system that allows the user to quickly navigate through complex environments. This requires interactive rendering rates (3-30 frames per second) and simple navigation techniques.</p><p>Second, we want the system to serve as a front-end for databases containing auxiliary information about the geometric objects including, for example, textual data such as serial number or image data such as assembly drawings. For this system to be accepted as a database query tool, the visualization aspect of it must seem natural and should not require the user to have an in depth understanding of the underlying rendering algorithms.</p><p>Third, we would like to use the system, either interactively or through batch processing, as an effective communication tool. This may involve generating images and animations to be included in an HTML document, or line drawings to be sent to a plotter. This goal requires us to consider not only interactive rendering requirements, but also high quality output requirements such as the ability to modify material properties of objects, manipulate multiple light sources, and generate high resolution images.</p><p>Finally, we want to provide a set of generic core geometric operations such as collision detection and clearance analyses, while allowing for application specific functionality to be easily added to the system.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">System Overview</head><p>The obvious design goal for our system is to implement a visualization environment with maximum interactivity. In order to accomplish this goal, we found that we had to pay careful attention to the details of the data and the application of the system to the data. Only by fully understanding this information were we able to properly trade off the various system constraints. As a result of this study, we developed the following system requirements:</p><p>• Database size: We anticipate that the database may reach 100 million triangles and 25,000 separate parts, with an average size of 10 million triangles and 1,000 parts.</p><p>• Unstructured data: The data we treat does not have any inherent regularity or structure. Some visualization environments, such as office buildings or terrain, have known properties that allow effective pre-processing for visibility and occlusion <ref type="bibr" target="#b0">[1]</ref>.</p><p>• Volatility: In a typical design environment, hundreds of new parts may be introduced each day. It is also common to develop competing designs in parallel. Thus we require the system to accommodate frequent changes to the database, and to load an arbitrary set of parts, not necessarily from the same database.</p><p>• Robustness: Because of the size of the data, and the frequency of change, we require automated processes that never fail. This requires robust algorithms, as well as algorithms that require no human intervention or tweaking.</p><p>• Part motion: The system was designed from inception to accommodate the motion of parts.</p><p>• Data Attributes: The system is required to support surface normals and scalar data at a per vertex or per facet level. At a per part level, graphical attributes such as color and surface properties must be supported.</p><p>• Minimum start-up cost: An interactive visualization system must not only provide high rendering rates, but the time required to load data and begin working must be interactive as well.</p><p>• Hardware independence: We need this system to run on a variety of hardware platforms, many of which do not support advanced graphics features such as texture mapping. Therefore we must avoid methods that rely on such features <ref type="bibr" target="#b7">[8]</ref>, and utilize only basic primitive projection methods that are supported across all of our target platforms.</p><p>• Flexibility: We envision a core rendering engine that can be embedded in a variety of applications. For example, applica-tions to automatically generate graphical reports or generate HTML pages are essential.</p><p>Based on these requirements we designed an interactive visualization system that we call Galileo. The overall architecture of Galileo consists of three components. The first component is the polygonal database, which is constructed in a pre-processing step prior to data interaction. The second component is the rendering engine. The rendering engine is a compiled core written in C and optimized for the OpenGL graphics library. The third component is the application layer, typically a graphical user interface written in the interpreted language Tcl/Tk. The application layer drives the rendering core via a layer of wrapper code.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">The Polygonal Database</head><p>Initially we considered utilizing a global spatial-based database but we found that the requirements of part motion, high data volatility, unstructured data and minimum start-up cost eliminated this possibility. Instead we have adopted a levelof-detail (LOD) approach that creates models of varying resolution for each geometric object.</p><p>The polygonal database consists of a collection of parts, where each part is represented by a minimum of two LOD representations. The lowest level is a bounding box, and the highest level is a full-resolution representation. Depending on the number of polygons, n additional levels of detail may be constructed for a particular part. We use three key algorithms to build the n levels of intermediate models: a 26-sided convex hull (i.e., a k-dop with k=26); a modified decimation algorithm <ref type="bibr" target="#b3">[4]</ref>[5] that yields a guaranteed reduction level; and a modified oriented bounding-box (OBB) algorithm <ref type="bibr" target="#b2">[3]</ref> to generate the pieces of a part.</p><p>The k-dop, which we refer to as a simple convex hull or a gem because of its faceted appearance, is built from thirteen pairs of parallel planes. Each plane is defined by an equation of the form</p><p>where the values of , , and include all triples from the set except for . The value of for each plane is selected by moving the plane towards the geometric object until it just touches the object. Finally, a fast clipping algorithm is employed to trim each plane in order to obtain a polygonal model of the region bounded by all 26 planes, resulting in a convex hull with at most 26 sides.</p><p>All other intermediate LODs are created with a decimation technique. The algorithm was modified so that it will generate any reduction level between 0-100%. This modification was necessary so that explicit control over the number of output triangles in a given LOD is possible. The main idea behind the change is that topological modification to the mesh is allowed, and the mesh may be "split" (i.e., broken into manifold pieces) as necessary to achieve a given reduction level. <ref type="figure">Figure 1</ref> shows three levels of resolution for a geometric model produced by a CAD system. The convex hull representation has 18 polygons, the decimated version generated with a desired reduction rate of 95% has 15,718 triangles, and the full resolution model has 314,393 triangles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ax By Cz D</head><formula xml:id="formula_0">+ + + 0 = A B C 1 -0 1 , , { } 0 0 0 , , ( ) D</formula><p>The original polygonal file produced by the CAD system requires 22.6 MB of disk space for storage. The full resolution file for our system requires 11.1 Mb of disk space, while the decimated and convex hull representations require 647.6 Kb and 1564 bytes respectively. To increase the effectiveness of view frustum culling during interactive visualization, we use a dicing technique to segregate the polygons of an LOD into pieces. The dicing process is based on building an oriented bounding box (OBB) <ref type="bibr" target="#b2">[3]</ref> from the vertices of the part. The process is initialized by computing a root OBB, and then recursively separating the vertices into two groups by using a split plane oriented perpendicular to the long axis of the parent OBB. A child OBB is then computed for each of the two groups of vertices. The process continues until the number of vertices present in each leaf OBB is less than some desired threshold. Finally, pieces are constructed by finding all polygons whose vertices are contained within a single OBB. Those polygons whose vertices span more than one leaf OBB are arbitrarily assigned to one of the OBBs (i.e., pieces).</p><p>The full resolution CAD model shown in <ref type="figure">Figure 1</ref> is composed of 88 pieces with an average of 3573 triangles in each. These pieces are independently colored in <ref type="figure">Figure 2</ref> in order show the organization of the polygons. The division of parts into pieces is helpful not only in rendering methods, but also in computational methods such as collision detection. We generally force a part to split into pieces until each piece contains less than 5,000 primitives.</p><p>We found that the geometric components that we need to visualize are often composed of several individual parts. If we consider the entire component to be one part, then a single LOD would be used to represent it during rendering, whereas if we split the component into its individual parts then small parts could be displayed at lower resolution compared to the larger parts of the component. To facilitate this, we introduced the concept of assemblies into our database structure where each assembly contains one or more parts. The breakdown of geometry into parts within an assembly may be obtained from the input geometry file as is often the case with CAD data, or could be derived by extracting connected components.</p><p>A collection of assemblies is stored on disk as a set of directories. Within each assembly directory is an information file that contains the number of parts in the assembly, the center and radius of a bounding sphere that encloses all the LODs of all the parts, and the per part information. For each part, material properties and a bounding sphere and bounding box that enclose all LODs are stored in the information file. This bounding box is actually the lowest detail LOD for the part. The geometric information for each LOD of that part is stored as a separate file in the assembly directory. Each LOD file contains a set of vertices and vertex attributes followed by the piece information where each piece contains a set of index lists that refer back to the vertices and represent the primitives for that piece. For compact storage, the smallest data type that can represent the set of vertices is used to stored the indices for each LOD. For example, an LOD with 200 vertices would use one byte per index while an LOD with 30,000 vertices would use two bytes per index Data is loaded from disk into the visualization system as a collection of assemblies. The assembly structure shown in <ref type="figure" target="#fig_0">Figure 3</ref> closely matches the file structure described in the previous section. Assemblies, parts, and pieces all have bounding sphere information. In addition, attributes such as material properties and visibility, as well as a transformation matrix are stored in each part. The vertex list and any vertex attributes such as normal and color are stored at the LOD layer while the indices representing the primitives and the primitive attributes are stored at the piece layer. Again, the smallest data type that can be used to store the indices is selected for each LOD in order to reduce memory requirements.</p><p>Our interactive rendering method is based on three goals. First, we would like to avoid rendering geometric primitives that are not visible. Second, we would like to draw parts that are close to us with better detail than those that are far away. The final goal, which seems obvious yet often contradicts the first two, is that we do not want to add too much processing or memory overhead to the rendering process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">View Frustum Culling</head><p>General visibility culling <ref type="bibr" target="#b1">[2]</ref>[9] works well with spatially organized polygonal databases, but we did not find it to be practical for our goals of minimal overhead and a dynamic environment with a large number of complex geometric objects. Therefore we decided to include only view frustum culling in our rendering method.</p><p>To perform culling, we create five plane equations of the form that define the bounds of the view frustum according to the current viewing transformation. These planes include the near clipping plane and the left, right, top, and bottom sides of the view frustum, and are defined so that the positive side of the plane faces the inside of the view frustum. The bounding sphere for each assembly, with center and radius , is compared against these five planes in order to label the assembly as visible, partially visible, or not visible from the current viewing direction. Visibility classification must also be performed for each part in a partially visible assembly. We selected a bounding sphere for view frustum culling rather than a bounding box in order to keep this classification easy to compute. In addition the bounding sphere is independent of part orientation, and part translation requires only a corresponding translation of the sphere's center.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Basic Level-Of-Detail Selection</head><p>After view frustum culling we now have a count of the potentially visible parts that must be rendered. In addition, the user has selected a desired refresh rate which defines the amount of time available for the render. The obvious method for selecting an LOD for each part would involve dividing the rendering time among the parts, then selecting the best LOD that could be rendered within the allocated time. We found that using time as a direct measurement does not work well since many graphics library implementations, such as OpenGL, utilize buffering to improve performance. This makes it difficult to accurately measure the amount of time required to render small parts.</p><p>Instead of measuring time directly, we measure the number of primitives drawn divided by the total rendering time which yields the primitives per second. For each image rendered, we compute the number of primitives that can be drawn within the allocated time. These primitives are then divided among the parts, and an LOD with approximately the desired number of primitives is selected. If different primitives require significantly different amounts of time to render, such as flat shaded triangles rendered as strips versus gouraud shaded independent polygons, then these rates can be measured at system start-up and a conversion table can be generated to map all primitive counts into a count for a common type of primitive.</p><p>At the heart of the LOD selection method are the heuristics used to divide the primitives among the potentially visible parts. We considered a variety of metrics including part size, distance to the view plane, and offset from the center. We found that approximate screen coverage is fast to compute and is generally a good predictor of the importance of a part in the image since it captures information about the size of the part in relation to its distance from the view. We compute the approximate screen coverage by calculating the percentage of the screen that is covered by a view-aligned bounding box that encloses the part's bounding sphere. For efficiency, this calculation is combined with the view frustum culling method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Interactive Rendering</head><p>Now that we have selected an LOD for each part, we have to consider the individual pieces. Each part in each assembly that is either visible or partially visible is considered for drawing. For parts that are marked as visible, all pieces of the LOD are drawn. For parts that are marked as partially visible, the view frustum clipping operation described in Section 4.1 is performed on each piece, and any piece that is visible or partially visible is drawn.</p><p>The basic LOD selection method described above does not work well with large parts when only a small fraction of the pieces are potentially visible. A low resolution LOD will be selected due to the total number of primitives, yet only the visible pieces are drawn. To solve this problem, we consider the number of primitives drawn the last time the LOD was rendered rather than the total number of primitives in the LOD during the selection process. As fewer pieces are rendered, the primitive count drops and eventually the selection process will be able to choose a higher resolution LOD. Another problem with the basic LOD selection method is that it cannot guarantee that the requested frame rate will be the actual frame rate. The basic LOD selection method works best when there are a large number of parts, with each part having a large number of LODs uniformly covering the resolution range from a six polygon bounding box to a full resolution model. If we are visualizing a large number of parts each containing a small number of LODs, then we can increase our accuracy by adjusting the number of primitives allocated to render a frame based on the relationship between our desired frame rate and our actual frame rate. Care must be taken to adjust the allocated primitives slowly and only if the actual rate is different from the desired rate by more than some to avoid oscillations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Dynamic Data Loading</head><p>The rendering method described in the previous section assumes that all LODs are currently available in memory. This is not a reasonable assumption since this may require a long load time or may not even be possible due to memory limitations. To avoid this problem we create two threads in our rendering engine with one thread assigned to rendering tasks and the other thread responsible for managing the loading and unloading of LODs. Initially, the information files for the set of assemblies to be visualized are consulted, and the assembly structures are generated with NULL pointers for all the LODs except for the bounding box representation. A flag is stored for each LOD indicating its priority for loading and the last frame in which this LOD was rendered. Initially all priorities and frame indicators are set to 0. Each time an LOD is rendered it is assigned the current value of the render counter that indicates the number of frames that have been rendered since the start of the system. When a part requires an LOD for rendering that is not in memory, the priority is increased by a value between 1 and 100 based on the screen coverage of that part. The thread responsible for loading data selects the LOD with the highest priority, and if a memory limit would not be exceeded this LOD is loaded. If loading this part would exceed a memory limit, then the LOD that was least recently rendered is unloaded from memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Implementation and Results</head><p>The Galileo database builder is written in C++, and uses the C++ libraries of the Visualization Toolkit (vtk) <ref type="bibr" target="#b5">[6]</ref> <ref type="bibr" target="#b6">[7]</ref>. The Galileo rendering engine is written in C, with OpenGL used for geometric rendering. The user interface is implemented in Tcl/ Tk, with wrapper code used to access the underlying rendering engine from the interpreted script level. Support for multiple threads was obtained by using POSIX threads, Sun threads, or shared process groups depending on platform and operating system. Galileo can currently run on any Unix platform that supports OpenGL rendering. We have tested the system on a variety of Silicon Graphics, Hewlett-Packard, and Sun workstations.</p><p>Using Galileo on a wide range of workstations we found that the system generally "feels" the same but "looks" different across the different platforms. The frame rate, which is controlled by the user, is nearly independent of the underlying graphics hardware. The LODs that are selected to be rendered at the given frame rate are dependent on the graphics performance of the workstation. In <ref type="figure">Figure 4</ref> we see three images of the same data produced during interactive visualization with the same desired frame rate of five frames per second. All three images were generated on Silicon Graphics workstations. The first i m a g e wa s c r e a t e d o n a d u a l p r o c e s s o r O ny x w i t h InfiniteReality graphics, the second on a dual processor Octane with MXI graphics, and the third on a single processor O 2 . It is clear that the image produced on the InfiniteReality workstation contains more detail than the image generate on the O 2 due to the underlying power of the graphics processor. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 3 :</head><label>3</label><figDesc>The assembly structure. Bounding spheres are stored for each assembly, part and piece. Properties and a transformation matrix are stored for each part. Vertex information is stored in each LOD, and geometric primitives are stored in each piece.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 4 :Figure 1 :Figure 2 :</head><label>412</label><figDesc>A complex CAD environment shown at (a) full resolution and viewed on (b) an InfiniteReality, (c) an Octane, and (d) an O 2 using the same desired frame rate. Three LODs for a CAD model including (a) an 18sided convex hull, (b) a decimated representation, and (c) the full resolution model. The pieces of this CAD model are independently colored to show the organization of the polygons.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>We would like to thank George Ryon, Mike Godbey, Lance Shumaker, Charles Law, Margaret Kelliher, Jonathan Davis, and Jeanette Bruno for their help on the development of Galileo and their valuable feedback on this project.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Increasing Update Rates in the Building Walkthrough System with Automatic Model-Space Subdivision and Potentially Visible Set Calculations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Airey</surname></persName>
		</author>
		<idno>TR90-027</idno>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
		<respStmt>
			<orgName>Computer Science Department, U.N.C. Chapel Hill</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Hierarchical Rendering of Complex Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Greene</surname></persName>
		</author>
		<idno>USCS-CRL- 95-27</idno>
		<imprint>
			<date type="published" when="1995" />
		</imprint>
		<respStmt>
			<orgName>University of California at Santa Cruz</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">OBBTree: A Hierarchical Structure for Rapid Interference Detection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gottschalk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Lin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;96 Proceedings)</title>
		<imprint>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="171" to="180" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Decimation of triangle meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Zarge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="65" to="70" />
			<date type="published" when="1992-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A topology modifying progressive decimation algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Visualization &apos;97</title>
		<meeting>of Visualization &apos;97</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">The Visualization Toolkit: An Object-Oriented Approach to 3D Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lorensen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>Prentice Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">The Design and Implementation of an Object-Oriented Toolkit for 3D Graphics and Visualization. Proceeding of Visualization &apos;96</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">M</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="93" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Hierarchical Image Caching for Accelerated Walkthroughs of Complex Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shade</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Leschinski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">H</forename><surname>Salesin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Snyder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="75" to="82" />
			<date type="published" when="1992-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Visibility Computations in Densely Occluded Polyhedral Environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Teller</surname></persName>
		</author>
		<idno>UCB/CSD 92/680</idno>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
		<respStmt>
			<orgName>University of California at Berkley</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
