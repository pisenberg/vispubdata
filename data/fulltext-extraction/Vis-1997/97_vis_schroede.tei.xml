<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Topology Modifying Progressive Decimation Algorithm</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
						</author>
						<title level="a" type="main">A Topology Modifying Progressive Decimation Algorithm</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:36+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Triangle decimation techniques reduce the number of triangles in a mesh, typically to improve interactive rendering performance or reduce data storage and transmission requirements. Most of these algorithms are designed to preserve the original topology of the mesh. Unfortunately, this characteristic is a strong limiting factor in overall reduction capability, since objects with a large number of holes or other topological constraints cannot be effectively reduced. In this paper we present an algorithm that yields a guaranteed reduction level, modifying topology as necessary to achieve the desired result. In addition, the algorithm is based on a fast local decimation technique, and its operations can be encoded for progressive storage, transmission, and reconstruction. In this paper we describe the new progressive decimation algorithm, introduce mesh splitting operations and show how they can be encoded as a progressive mesh. We also demonstrate the utility of the algorithm on models ranging in size from 1,132 to 1.68 million triangles and reduction ratios of up to 200:1.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Even with the increasing speeds of computer hardware, interactive computer graphics and animation remains an elusive goal. Model size keeps growing, partly because of advances in data acquisition, and partly due to ever more sophisticated computer simulation and modeling techniques. Laser digitizers can generate nearly one million polygons in a 30 second span, while iso-surface generation can create 1-10 million polygons. Terrain models from high-altitude sources such as satellites are even larger: more than 10 million triangles is not uncommon.</p><p>To address this situation a variety of polygon reduction techniques have been developed to reduce model size. Siggraph '92 was a seminal year for polygon reduction with the presentation of two papers. Schroeder et al. <ref type="bibr" target="#b0">[1]</ref> presented an algorithm called triangle decimation based on local vertex deletion followed by re-triangulation. Turk <ref type="bibr" target="#b1">[2]</ref> described an algorithm based on dispersion of new points on top of the original mesh, followed by global re-triangulation. At Siggraph '93 Hoppe et al. <ref type="bibr" target="#b2">[3]</ref> presented a mathematically rigorous algorithm based on optimization techniques. Later that year Hincker and Hanson <ref type="bibr" target="#b3">[4]</ref> described an algorithm based on merging regions of nearly co-planar polygons into a single large polygon, and then retriangulating. Since that time other notable algorithms have been presented including methods that are guaranteed accurate within a global error bounds <ref type="bibr" target="#b10">[11]</ref> or within a simplification envelope <ref type="bibr" target="#b7">[8]</ref>.</p><p>All of the algorithms described above are designed to pre-serve the original topology of the mesh. While this may be important for many applications (e.g., analysis or computational geometry), preserving topology introduces constraints into the reduction process. For example, Color Plate 1(a) shows a shell mesh with seven holes, and Plate 1(b) shows the result of reduction where topology is preserved. As shown in the figure, the topological constraint introduced by the holes clearly limits the ability of an algorithm to reduce the mesh. In many applications, such as interactive navigation of geometric databases, preserving topology is not a critical constraint. Reduction algorithms are typically used to improve rendering speed or to minimize data size or compression requirements. In such applications topology-preserving reduction schemes are often incapable of achieving desired reduction levels. This results in unresponsive systems or the use of crude bounding boxes or bounding hulls to represent objects. Removing topological constraint can create large gains in reduction factors and therefore, system responsiveness and interactivity.</p><p>Another important development in the field of polygon reduction is the progressive mesh <ref type="bibr" target="#b6">[7]</ref> introduced by Hoppe. A progressive mesh is one in which the original mesh can be decomposed into a simpler base mesh, where the base mesh is related to the original via a compact series of operations. In Hoppe's scheme, the single topology preserving operation EdgeCollapse (and its inverse EdgeSplit) is sufficient to transform the full resolution mesh into a simpler base mesh (and the base mesh back to the full resolution mesh). Progressive meshes offer many attractive properties, including the ability to compactly store and incrementally transmit and reconstruct geometry. Such capability is important for network based rendering and data transmission.</p><p>In this paper we present a new algorithm that can modify the topology of a mesh in order to guarantee a requested reduction level. Moreover, the algorithm creates progressive representations by extending the pair of operations Edge Collapse/Split with another pair of operators: Vertex Split/Merge. The algorithm is fast by virtue of a local decimation scheme similar to <ref type="bibr" target="#b0">[1]</ref>. We begin by describing related background work, and then describe the algorithm from a high level, followed by a detailed look at each of its parts. We conclude by applying the algorithm to five data sets and report times to reduce the meshes at various levels of reduction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Objectives</head><p>The motivation for this work is to support interactive visualization of large geometric databases. These databases typically represent the design of industrial equipment such as aircraft engines or power generation equipment. Our approach is based on building level-of-detail (LOD) models for each part, ranging in complexity from full resolution to a bounding hull consisting of dozens of triangles. The size of our databases for a complete system may reach 100 million triangles and 25,000 separate parts, while an average database size is approximately 10 million triangles and 10,000 parts. Also, in an active design environment it is common to have a dozen or more variations of the same design, or multiple designs ongoing simultaneously. With this application in mind, we formulated the following objectives for our reduction algorithm:</p><p>• Guaranteed reduction level: Building a LOD database requires generating meshes of the correct complexity relative to every other level. In an automatic process with thousands of parts, only using an algorithm with a guaranteed reduction level will reliably construct a consistent database.</p><p>• Modify topology: Arbitrary reduction levels implies the need to modify topology. For example, to reduce a flat, square plate with a single hole that is represented by 1000 polygons to two triangles forming a square with no hole requires the elimination of the hole.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>• Progressive representation:</head><p>The decimation process must be encodable into a series of compact, incremental operations. This facilitates the transmission of the mesh across a network, and minimizes disk storage.</p><p>• Fast: We wish to construct an entire LOD database in a single day, or rapidly process parts as they are designed and submitted to the database. From our statistics cited previously, this requires a triangle processing rate of approximately 100 million triangles per day. At this rate we feel confident that we can manage a business-wide design process.</p><p>• Robust: Since the LOD database is built completely automatically, the algorithm must run without human intervention or error correction.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Background</head><p>In this section we briefly describe some related work that forms the basis of our progressive decimation algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Topology Modifying Algorithms</head><p>We began our work by investigating two important polygon reduction algorithms that modify topology. Rossignac <ref type="bibr" target="#b8">[9]</ref> uses a vertex merge technique, where local vertices can be identified using an octree or 3D bin array. Vertices lying close to each other are merged into a single vertex, and the topology of the affected triangles are then updated. This may consist of either triangle deletion (if two or three of the vertices are merged), or updating the connectivity list of the triangle. He et al. <ref type="bibr" target="#b9">[10]</ref> use a volume sampling approach, where the triangles are convolved into a volume to generate scalar values (e.g., scalar value may be distance from original mesh). Then an iso-surfacing technique such as marching cubes can be used to extract a surface approximating the original mesh.</p><p>Rossignac's method is capable of generating representations at any reduction level. Unfortunately, it is not amenable to a compact progressive operator. For example, if merging neighboring vertices eliminates 1000 triangles, we need to keep track of each triangle modified and its relationship to the merged vertices, and do this for each merging step of the algorithm. Another problem with this method is that points can be merged regardless of surface coherence. For example. points that lie close to one another (measured via Euclidean distance) but are far apart (via surface distance) or even on separate surfaces may be merged.</p><p>The volume sampling technique can generate representations at almost any level by judicious selection of the sampling (or volume) dimensions. Unfortunately, it is not possible to recover the original mesh using this technique, since the extracted iso-surface has no direct relation to triangles in the original mesh. Also, there is no method to control the number of triangles produced by the method, and the number of triangles may vary unpredictably as the volume dimensions are changed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Decimation</head><p>The decimation algorithm has been widely used because of its combination of desirable features: O(n) time complexity, speed, simplicity, and the ability to treat large meshes. In addition, it preserves high-frequency information such as sharp edges and corners, and creates reduced meshes whose vertices are a subset of the original vertex set, thereby eliminating the need to map vertex information. However, as originally presented the decimation algorithm is topology preserving and provides no progressive mesh representation.</p><p>The decimation algorithm proceeds by iteratively visiting each vertex in the triangle mesh. For each vertex, three basic steps are carried out. The first step classifies the local geometry and topology in the neighborhood of the vertex. The classification yields one of the five categories shown in <ref type="figure" target="#fig_0">Figure 1</ref>: simple, boundary, complex, edge, and corner vertex. Based on this classification, in the second step a local planarity measure is used to determine whether the vertex can be deleted. Although many different criterion are possible, distance to plane (for simple vertices) and distance to line (for edge and boundary vertices) has proven to be useful. If this decimation criterion is satisfied, in the third step the vertex is deleted (along with associated triangles), and the resulting hole is triangulated. The triangulation process is designed to capture sharp edges (for vertices classified edge and corner) and generally preserve the original surface geometry. (See <ref type="bibr" target="#b0">[1]</ref> for additional details.)</p><p>An attractive feature of the decimation algorithm is its relative speed. We used the decimation algorithm as the basis on which to build our progressive algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Progressive Meshes</head><p>A progressive mesh is a series of triangle meshes related by the operations</p><formula xml:id="formula_0">(1)</formula><p>where and represent the mesh at full resolution, and is a simplified base mesh. Here the mesh is defined in terms of its geometry , or vertex set in and is the mesh topology specifying the connectivity of the mesh triangles.</p><p>It is possible to choose the progressive mesh operations in such a way to make them invertible. Then the operations can be applied in reverse order (starting with the base mesh )</p><p>to obtain a mesh of desired reduction level (assuming that the reduction level is less than the base mesh ). Hoppe's invertible operator is an edge collapse and its inverse is the edge split (Edge Collapse/Edge Split) shown in <ref type="figure" target="#fig_4">Figure 5</ref>(a). (Note: Hoppe uses the terminology Edge Collapse/Vertex Split. We prefer our naming convention to simplify the naming of the vertex operators introduced later.) Each collapse of an interior mesh edge results in the elimination of two triangles (or one triangle if the collapsed vertex is on a boundary). The operation is represented by five values where is the vertex to collapse/split, is the vertex being collapsed to / split from, and and are two additional vertices to the left and right of the split edge. These two vertices in conjunction with and define the two triangles deleted or added. In Hoppe's presentation, represents vertex attribute information, which at a minimum contains the coordinates of the collapsed / split vertex .</p><p>A nice feature of this scheme is that a sequence of these operators is compact (smaller than the original mesh representation), and it is relatively fast to move from one reduction level to another. One significant problem is that the reduction level is limited by the reduction value of the base mesh</p><p>Since in our application we wish to realize any given reduction level, the base mesh contains no triangles</p><p>(3) (some vertices are necessary to initiate the edge split operations). Thus our progressive mesh representation consists of a series of invertible operations, without requiring any base mesh triangles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Algorithm</head><p>Our proposed algorithm is based on two observations. First, we recognized that reduction operations (such as edge collapse) reduce the high-frequency content of the mesh, and second, topological constraint can only be removed by modifying the topology of the mesh. The implication of the first observation is that "holes" in the mesh (see Plates 1(a)-(c)) tend to close up during reduction. The only reason they do not close completely is because topological modification is prevented. The second observation led us to realize that we could modify the topology by "splitting" the mesh, i.e., replacing one vertex with another for a subset of the triangles using the original vertex. We also realized that any collection of triangles, whether manifold or non-manifold, could be simplified by splitting the mesh appropriately. Thus we developed our algorithm to use topology-preserving operators whenever possible, to allow hole closing (or non-manifold attachments to form), and to split the mesh when further reduction was not possible.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Overview</head><p>The algorithm is similar to the decimation algorithm. We begin by traversing all vertices, and classify each vertex according to its local topology and geometry. Based on this classification, an error value is computed for the vertex. The vertex is then inserted into a priority queue, where highest priority is given to vertices with smallest error values.</p><p>Next, vertices are extracted from the priority queue in order. The vertex is again classified, and if of appropriate classification, an attempt is then made to retriangulate the loop formed by the triangles surrounding the vertex. Unlike the decimation algorithm, where the hole is formed by deleting the vertex and triangles, in our algorithm the retriangulation is formed by an edge collapse. Note that in this process holes in the mesh may close, and non-manifold attachments may form.</p><p>If all allowable triangulations are performed and the desired reduction level is still not achieved, a mesh splitting operation is initiated. In this process, the mesh is separated along sharp edges, at corners, at non-manifold vertices, or wherever triangulation fails (due to no legal edge collapses). This process continues until the desired reduction rate is achieved.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Vertex Classification</head><p>Vertices are classified based on topological and geometric characteristics. Key topological characteristics are whether the vertex is manifold or non-manifold, or whether the vertex is on the boundary of the mesh. A manifold vertex is one in which the triangles that use the vertex form a complete cycle around the vertex, and each</p><formula xml:id="formula_2">M i M i V K , ( ) = M M n = ( ) M n 1 - … M 1 M 0 → → → → M M n M 0 V R 3 , K M 0 M 0 M 1 … M n 1 - M n → → → → M 0 Edge Collapse/Split (v s v t v l v r A ) , , , , v s v t v l v r v s v t A x v s M 0 . M M n = ( ) M n 1 - … M 1 M 0 M V ∅ , ( ) = ( ) → → → →</formula><p>edge attached to the vertex is used by exactly two triangles. A boundary vertex is used by a manifold semi-cycle (i.e., two of the edges on the mesh boundary are used by only one triangle). Note that a vertex with a single triangle attached to it is a boundary vertex. A vertex not falling into one of these two categories is non-manifold. Geometric characteristics further refine the classification. A feature angle (angle between the normals of two edge-connected triangles) is specified by the user. This parameter is used to identify sharp edges or corners in the mesh, and guide the triangulation process. Whether a triangle is degenerate is another important geometric characteristic. A degenerate triangle is one that has zero area, either because two or more vertices are coincident, or because the vertices are co-linear. (Although not common in most meshes, many CAD systems do produce them.) Proper treatment of degenerate triangles is necessary to implement a robust algorithm.</p><p>Vertices are classified into seven separate categories as shown in <ref type="figure" target="#fig_2">Figure 2</ref>. There are three base types: simple, boundary, non-manifold; and four types derived from the three base types: corner, interior edge, crack-tip, and degenerate. Interior edge vertices have two feature edges, and corner vertices have three or more feature edges (if simple), or one or more feature edges (if a boundary vertex).</p><p>Crack-tip vertices are types of boundary vertices, except that the two vertices forming the boundary edges are coincident. These form as a side effect of some splitting operations. These types must be carefully treated during triangulation to prevent the propagation of the crack through the mesh.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Error Measures</head><p>The computation of vertex error is complicated by the fact that the topology of the mesh is changing. Researchers such as <ref type="bibr" target="#b7">[8]</ref> and <ref type="bibr" target="#b10">[11]</ref> have devised elaborate techniques to limit the global error of a reduced mesh, but these methods depend on the topology of the mesh remaining constant. When the topology changes, it is hard to build useful simplification envelopes or to measure a distance to the mesh surface. Because of these considerations, and because of our desire for rapid decimation rates, we choose to retain the distance to plane and distance to line error measure employed in the decimation algorithm <ref type="figure" target="#fig_0">(Figure 1</ref>). Our only modification to the process is to esti-mate the error of a vertex connected to a single triangle differently. Instead of using distance to line that a boundary vertex would use, we compute an vertex error based on the triangle area which is an effective edge length. This error measure has the effect of eliminating small, isolated triangles first.</p><p>One improvement we made to the process of error computation is to distribute and accumulate the error of each deleted vertex. The idea is as follows: we maintain an accumulated error value for each vertex . When a vertex connected to is deleted via an edge collapse, the error is distributed to using</p><p>Thus the total error is a combination of the local error (i.e., distance to plane or distance to edge measure) plus the accumulated error value at that vertex. The error at each vertex is initially zero, but as the mesh is reduced, regions that are non-planar will generate errors, and therefore propagate the error to neighboring vertices. <ref type="figure">Figure 3</ref> illustrates this process on a 1D polyline and 2D surface mesh.</p><p>A nice feature of this approach is that it is relatively simple to compute a global error measure. As a vertex is deleted and the hole re-triangulated, the actual error to the re-triangulated surface (versus the estimated error ) is computed. (The error is computed by determining the minimum distance from the deleted vertex to the re-triangulated surface.) Then, the accumulated error is actually a global error bounds. This global error measure is conservative, but it can be used to terminate the algorithm for applications requiring a limit on surface error. (Note: setting a limit on maximum error may prevent the algorithm from achieving a specified reduction value.)</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Priority Queue</head><p>A central feature of the algorithm is the use of a priority queue. We use an implementation similar to that described by <ref type="bibr" target="#b4">[5]</ref>, but modified to support the Delete(id) method, where id specifies a vertex not necessarily at the top of the queue. The implementation is based on a well-balanced, semi-sorted binary tree structure, represented in a contiguous array. In addition, we have another array indexed by vertex id, that keeps track of the location of a particular id   in the priority queue array. <ref type="figure" target="#fig_3">Figure 4</ref> illustrates the data structure. (Note that the introduction of the priority queue means the time complexity of the algorithm is O(n log n) as compared to the O(n) of the decimation algorithm.)</p><formula xml:id="formula_4">v i v j v i e j v</formula><p>The addition of the Delete(id) method is necessary because of the incremental nature of the progressive decimation algorithm. When a vertex is deleted (via an edge collapse), both the local topology and geometry surrounding the vertex are modified. The effect is that the vertices directly surrounding the deleted vertex (i.e., those connected by an edge) have their topology and geometry modified as well. Thus the error values of these vertices must be recomputed. This means that the surrounding vertices are first deleted from the queue, the error is recomputed, and the vertices are reinserted back into the priority queue.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Triangulation</head><p>A vertex marked for deletion is eliminated by an edge collapse operation as shown in <ref type="figure" target="#fig_4">Figure 5(a)</ref>. We identify the edge to collapse (and the vertex ) by identifying the shortest edge that forms a valid split. If feature edges are present, we choose the shortest feature edge. This is not an optimal scheme, but when used with small feature angles gives satisfactory results. We chose this simple approach because of our requirements on triangle processing rate.</p><p>A valid split is one that creates a valid local triangulation (i.e., triangles do not overlap or intersect). The edge collapse may modify the global topology of the mesh, either by closing a hole or introducing a non-manifold attachment. Non-manifold attachments may occur, for example, when a vertex at the entrance of a tunnel is deleted, and the tunnel entrance collapses to a line. (See <ref type="figure" target="#fig_4">Figure 5(c)</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>and (d).)</head><p>We use a half-space comparison method to determine whether an edge collapse is valid. To determine if a vertex forms (in conjunction with ) a valid split, we define the loop of vertices connected to as . An edge collapse is valid when all planes passing through the vertices for and normal to the average plane normal separate the vertex loop into two non-overlapping subloops. This comparison can be computed by creating the split planes and evaluating the plane equation . The sub-loops are non-overlapping when all vertices in one sub-loop evaluate either positive or negative, and all vertices in the other loop evaluate to the opposite sign.</p><p>As we mentioned earlier, crack-tip vertices must be carefully triangulated to avoid propagating a crack through the mesh. Crack-tip vertices are treated like simple vertices by temporarily assuming that the two coincident vertices are one vertex. Then, if a valid split can be found, the two coincident vertices are merged with a Ver-texMerge, followed by an EdgeCollapse. Although this may reverse a previous VertexSplit operation, it does eliminate a vertex and two triangles and prevent the crack from growing. Eventually changes in the local topology and geometry will either force the crack to grow or to close up. The process will eventually terminate since the mesh will eventually be reduced to a desired level, or will be eliminated entirely.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Vertex Splits</head><p>A mesh split occurs when we replace vertex with vertex in the connectivity list of one or more triangles that originally used vertex <ref type="figure" target="#fig_5">(Figure 6(a)</ref>). The new vertex is given exactly the same coordinate value as . Splits introduce a "crack" or "hole" into the mesh. We prefer not to split the mesh, but at high decimation rates this relieves topological constraint and enables further decimation. Splitting is only invoked when a valid edge collapse is not available, or when a vertex cannot be triangulated (e.g., a non-manifold vertex). Once the split operation occurs, the vertices and are re-inserted into the priority queue.</p><p>Different splitting strategies are used depending on the classification of the vertex <ref type="figure" target="#fig_5">(Figure 6(b)</ref>). Interior edge vertices are split along the feature edges, as are corner verti-   </p><formula xml:id="formula_5">e i v i , ( ) 0 e i v i , ( ) 1 e 0 v 0 , ( ) 2 … e i v i , ( ) m 1 - e i v i , ( ) m Root Level 1 Children j v 0 ( ) 2 = j v 1 ( ) j v 2 ( ) … j v n 1 - ( ) j v n ( )</formula><formula xml:id="formula_6">v t v s v t , ( ) v 1 v t = v s v s L i v 1 v 2 … v n , , , ( ) = p i v t v j , ( ) 3 j n 1 - ≤ ≤ N i l i n 3 - p i N i v j v t - ( ) ⋅ = a)</formula><formula xml:id="formula_7">v l v r v t v t v 1 = v 3 l l 3 v 1 v 3 v 2 , , ( ) = l r 3 v 1 v 5 v 4 v 3 , , , ( ) = l l 4 l r 4 v 5 v 2 v 4 Invalid v s v t v s v t v s v s v t</formula><p>ces. Non-manifold vertices are split into separate manifold pieces. In any other type of vertex splitting occurs by arbitrarily separating the loop into two pieces. For example, if a simple vertex cannot be deleted because a valid edge collapse is not available, the loop of triangles will be arbitrarily divided in half (possibly in a recursive process).</p><p>Like the edge collapse/split, the vertex split/merge can also be represented as a compact operation. A vertex split/ merge operation can be represented with four values as shown in <ref type="figure" target="#fig_5">Figure 6(a)</ref>. The vertices and define a sweep of triangles (from to ) that are to be separated from the original vertex (we adopt a counter-clockwise ordering convention to uniquely define the sweep of triangles).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.7">Progressive Mesh Storage</head><p>The storage requirements for a progressive mesh are smaller than the standard triangle mesh representation schemes. We estimate the storage requirements as follows. A mesh generally consists of about vertices and triangles, for a total of words of storage using a standard scheme of three vertex indices per triangle, and three coordinate values per vertex, each stored as one word of information. Using a progressive mesh representation, each edge split requires at a minimum the coordinates and vertex indices , , , and , and creates two triangles and one vertex, at a cost of words of storage. A vertex split requires the four vertex indices , , , and , and typically no more than splits are required to reduce the mesh to . We can then estimate the storage requirements to total words, for a savings of 11% over the standard scheme. Note that even though the vertex split requires additional storage over edge collapse, it does allow us to virtually eliminate the cost of representing the base mesh.</p><p>Further savings are possible by carefully organizing the order of the playback operations. For example, by renumbering the vertices after the forward progression is com-plete, it is possible to eliminate the vertex index .</p><p>As <ref type="bibr" target="#b6">[7]</ref> describes, additional storage savings are possible based on the coherence of local topological operations, and by 16-bit quantization and compression of the coordinate values. We can also take into account the number of bits required for a vertex index and use smaller word sizes, if appropriate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.8">Error Inflection Points</head><p>An error inflection point occurs when the ratio of the error is greater than a user-defined value <ref type="bibr" target="#b5">(6)</ref> The importance of inflection points is that they mark abrupt transitions in the error of the mesh, and often correspond to significant changes in the appearance of the mesh. Thus, by tracking these inflection points, we can find natural points at which to generate LOD's for a particular part. For example, the first error inflection point always occurs at the point in which non-zero error is introduced. Geometrically, this corresponds to the point where all co-planar triangles have been removed from the interior of the mesh, and all co-linear vertices are removed from the boundary of the mesh. This is an important point in the reduction process, since the reduced model is indistinguishable from the original mesh using typical surfaceshading techniques.</p><p>We use error inflection points to build other levels in our sequence of LOD models. For a requested reduction level , we use the mesh with the closest inflection point</p><p>Typical values of range from 10 to 100, and are empirically determined.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.9">A Variation In Strategy</head><p>We found a variation of our splitting strategy to work well for a certain class of problems. In this variation, we presplit the mesh along feature edges, at corners, and at nonmanifold vertices. This strategy works well for objects with large, relatively flat regions, separated by thin, small surfaces. This is because splitting isolates regions from one another, thereby preventing the distortion of the mesh due to errors from edge collapse across the thin surfaces. An example of this behavior can be seen in Color Plate 2, where the triangles forming the thin edges of the plate disappear before the much larger triangles forming the faces of the plate.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Results</head><p>We implemented the algorithm as a C++ class in the Visualization Toolkit (vtk) system <ref type="bibr" target="#b5">[6]</ref>. The algorithm is relatively compact requiring less than 2 KLines of code (including the priority queue implementation). No formal optimization of the code was attempted other than the usual compiler optimization. All test results are run on a  </p><formula xml:id="formula_9">v r v l v s Split Merge v l v r v t v</formula><formula xml:id="formula_10">Vertex Split/Merge (v s v t v l v r ) , , , v l v r v r v l v s n 2n 9n v s v t v l v r 7n v s v t v l v r n 4 ⁄ M 0 8n v t E i E r e i 1 + e i -----------E r &gt; L k M j M j : E j L k - E i L k - for all k i ≤ j n ≤ , ≤ E r</formula><p>190 MHz R10000 processor (compiled and run in 32-bit mode) with 512 MBytes of memory.</p><p>We choose to test the algorithm on five different models. The first two are shown in Color Plates 1 and 2, and are a shell mesh and plate with seven holes. The next two models are extracted from CAD systems. The first is a heat exchanger with 11,006 original polygons. The next is a turbine shell consisting of 314,393 polygons. Finally, the last model is very detailed turbine blade consisting of 1.68 million triangles. The data was obtained by generating an isosurface from a 512 x 512 x 300 industrial CT scan of the part. The ability to modify topology provides us with reduction levels greater than could be achieved using any topology preserving algorithm. <ref type="figure" target="#fig_3">Figure 4</ref> clearly demonstrates this since the maximum topology preserving reduction we could obtain was r=0.404. We were able to more than double the reduction level and still achieve a reasonable representation.</p><p>At extreme reduction levels the quality of the mesh varied greatly depending on the model. In some cases a few large triangles will "grow" and form nice approximations (e.g., the plate and shell). In other cases, the mesh is fragmented by the splitting process and does not generate larger triangles or good approximations. But in each case we were able to recognize the part being represented, which is sufficient for initial camera positioning and navigation. We were generally pleased with the results of the algorithm, since the creation of non-optimal meshes is well balanced by the algorithm's speed, ability to process large meshes, and robustness.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>We have described a topology modifying decimation algorithm capable of generating reductions at any level. The algorithm uses the invertible progressive operators Edge Collapse/Split and Vertex Split/Merge to construct compact progressive meshes. The algorithm has a high enough polygonal processing rate to support a large scale design and visualization process. We have found it to be an invaluable tool for creating LOD databases. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Model Number Triangles</head><p>Reduction 0.   </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Overview of the decimation algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 .</head><label>2</label><figDesc>Vertex classification. Crack tip vertices shown displaced to emphasize topological disconnect.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 .</head><label>4</label><figDesc>Modified priority queue implementation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 5 .</head><label>5</label><figDesc>An edge collapse and split Triangulation via edge collapse a hole d) Forming a non-manifold attachment b) Valid and invalid splits Collapse Split</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 .</head><label>6</label><figDesc>Mesh splitting operations. Splits are exaggerated. a) A vertex split and merge</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 7</head><label>7</label><figDesc>shows elapsed wall clock time in seconds for these five examples at reduction levels of 0.50, 0.75, 0.90, and 1.00 (elimination of all triangles). We also show the number of edge collapses and vertex splits required at each level of reduction.Color Plates 3(a)-(f) show results for the heat exchanger.Figures 8(a)-(f)show results for the turbine shell.Figures 9(a)-(f)show the results for the turbine blade. Note that in each case the onset of vertex splitting is shown. In some of these color plates the red edges are used to indicate mesh boundaries, while light green indicates manifold, or interior edges.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 7 .</head><label>7</label><figDesc>Results for five different meshes. Times shown are elapsed seconds. Number of edge collapses and vertex splits are also shown. The rate is the maximum number of triangles eliminated per elapsed minute.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 -</head><label>8</label><figDesc>Turbine shell shown at various reduction levels. Shell has many features requiring vertex splitting. -up of edges showing holes leading to interior c) 75% reduction, 420,867triangles</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 9 -Plate 1 -Plate 2 -Plate 3 -</head><label>9123</label><figDesc>Turbine blade shown at various levels of reduction. Data derived from 512 2 by 300 CT scan.d) Shortly before splitting 134,120 triangles, 92% reduction e) 95% reduction, 84,173 triangles f) 99.5% reduction, 8,417 triangles Topological constraints prevent further reduction (shell with holes). Red edges are on the boundary of the mesh, light green edges are in the interior of the mesh. Sharp edge splits and hole elimination (thin plate with holes). (b) is a close-up of the mesh showing the how the hole triangles are disconnected from the top plate. Heat exchanger at different levels of reduction. (c) shows the edges that are split at the onset of edge splitting. d) Reduction 90%, 1,100 triangles e) Reduction 95%, 550 triangles f) Reduction 98%, 220 triangles</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>Computing and distributing error.</figDesc><table><row><cell cols="3">Error distributed to surrounding vertices Figure 3. Error = e i + e j e i e i e k e j Error = e i + e k</cell></row><row><cell></cell><cell></cell><cell>i</cell></row><row><cell>e i</cell><cell>=</cell><cell>e i e j +</cell></row><row><cell>e i</cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell>ê j</cell></row><row><cell></cell><cell></cell><cell>e j</cell></row><row><cell></cell><cell>ê j</cell><cell></cell></row></table><note></note></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Decimation of triangle meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Zarge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="65" to="70" />
			<date type="published" when="1992-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Re-Tiling of polygonal surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="55" to="64" />
			<date type="published" when="1992-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Mesh optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Derose</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Duchamp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Mcdonald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Stuetzle</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics Proceedings (SIG-GRAPH &apos;93)</title>
		<imprint>
			<date type="published" when="1993-08" />
			<biblScope unit="page" from="19" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Geometric optimization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hinker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Visualization &apos;93</title>
		<meeting>of Visualization &apos;93</meeting>
		<imprint>
			<date type="published" when="1993-10" />
			<biblScope unit="page" from="189" to="195" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Data Structures and Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">V</forename><surname>Aho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">E</forename><surname>Hopcroft</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Ullman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">The Visualization Toolkit An Object-Oriented Approach To 3D Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">M</forename><surname>Martin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1996" />
			<publisher>Prentice-Hall</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<title level="m">Progressive Meshes. Proc. SIGGRAPH &apos;96</title>
		<imprint>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="99" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Varshney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Brooks</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Wright</surname></persName>
		</author>
		<title level="m">Simplification envelopes. Proc. SIG-GRAPH &apos;96</title>
		<imprint>
			<date type="published" when="1996-08" />
			<biblScope unit="page" from="119" to="128" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Multi-resolution 3D approximations for rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rossignac</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Borel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Modeling in Computer Graphics</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993-07" />
			<biblScope unit="page" from="455" to="465" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Voxel based object simplification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>He</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">A</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Varshney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Visualization &apos;95</title>
		<meeting>of Visualization &apos;95</meeting>
		<imprint>
			<date type="published" when="1995-10" />
			<biblScope unit="page" from="296" to="303" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Mesh reduction with error control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Liebich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Strasser</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Visualization &apos;96</title>
		<meeting>of Visualization &apos;96</meeting>
		<imprint>
			<date type="published" when="1996-10" />
			<biblScope unit="page" from="311" to="318" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Fast polygonal approximation of terrains and height fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Heckbert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
		<idno>CMU-CS-95-181</idno>
		<imprint>
			<date type="published" when="1995-08" />
		</imprint>
		<respStmt>
			<orgName>Carnegie Mellon University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
