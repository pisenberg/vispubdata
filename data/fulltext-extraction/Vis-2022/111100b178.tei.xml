<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 https://raw.githubusercontent.com/kermitt2/grobid/master/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Computing a Stable Distance on Merge Trees</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName><forename type="first">Brian</forename><surname>Bollen</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Pasindu</forename><surname>Tennakoon</surname></persName>
						</author>
						<author>
							<persName><forename type="first">Joshua</forename><forename type="middle">A</forename><surname>Levine</surname></persName>
						</author>
						<title level="a" type="main">Computing a Stable Distance on Merge Trees</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.7.2" ident="GROBID" when="2023-03-27T09:20+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Merge trees</term>
					<term>scalar fields</term>
					<term>distance measure</term>
					<term>stability</term>
					<term>edit distance</term>
					<term>persistence</term>
				</keywords>
			</textClass>
			<abstract>
<div xmlns="http://www.tei-c.org/ns/1.0"><p>Fig. <ref type="figure">1</ref>. Starting with a baseline scalar field and merge tree, a small perturbation may change the topology of a merge tree. The top graph plots the bottleneck, merge tree matching, and L ∞ distance between the baseline and 36 perturbed scalar fields which all exhibit a horizontal instability. The merge tree matching distance is shown here to lie between the bottleneck distance and the L ∞ distance even when faced with these instabilities.</p></div>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Topological descriptors in topological data analysis (TDA) have been used extensively to identify and summarize features of interest in scalar fields in a wide variety of domains such as nuclear energy <ref type="bibr" target="#b15">[16]</ref>, turbulent mixing <ref type="bibr" target="#b27">[28]</ref>, shape analysis <ref type="bibr" target="#b26">[27]</ref>, porous materials <ref type="bibr" target="#b24">[25]</ref>, combustion <ref type="bibr" target="#b7">[8]</ref>, and chemistry <ref type="bibr" target="#b21">[22]</ref>. Most topological descriptors fall into one of three categories: the set-based descriptors, such as the persistence diagram <ref type="bibr" target="#b10">[11,</ref><ref type="bibr" target="#b18">19]</ref>; the graph-based descriptors such as the Reeb graph <ref type="bibr" target="#b31">[32,</ref><ref type="bibr" target="#b32">33,</ref><ref type="bibr" target="#b40">41]</ref>, contour tree <ref type="bibr" target="#b8">[9]</ref>, and merge tree; and the complex-based descriptor such as the Morse-Smale complex <ref type="bibr" target="#b16">[17,</ref><ref type="bibr" target="#b23">24]</ref>. In a visualization setting, we are often posed with the question of how similar two datasets are to one another. Since these topological descriptors have been used for individual analysis of features in the dataset, we can use measures of similarity between the topological descriptors to produce a similarity measure between the underlying datasets <ref type="bibr" target="#b42">[43]</ref>. For instance, on persistence diagrams, distances such as the bottleneck distance and Wasserstein distance have been used effectively to gauge this similarity. Graph-based structures have also seen a wide variety of distances such as the interleaving <ref type="bibr" target="#b11">[12,</ref><ref type="bibr" target="#b28">29]</ref>, functional distortion <ref type="bibr" target="#b3">[4]</ref>, universal <ref type="bibr" target="#b4">[5]</ref>, and multiple edit distances <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15]</ref>. These graph-based and set-set based descriptor distances have all been proven to be stable -a property which indicates that the distance is robust to perturbations of the underlying dataset. Furthermore, the graph-based distances have all been shown to be more discriminative than the bottleneck distance, i.e. they can discern between differences in the datasets which the bottleneck distance may not. The combination of retaining stability and discriminativity to the bottleneck distance makes graph-based distances desirable.</p><p>However, these theoretical distances all have related problems which imply that these distances are computationally complex. For example, the functional distortion distance is a version of the Gromov-Hausdorff distance <ref type="bibr" target="#b20">[21]</ref> which is known to be NP-hard to approximate within a factor of 3 <ref type="bibr" target="#b0">[1]</ref>. Similarly, the Reeb graph edit distance is heavily related to the graph edit distance (GED) which is known to be NP-hard <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b44">45]</ref> and determining if two Reeb graphs have an interleaving distance of ε is known to be NP <ref type="bibr" target="#b11">[12]</ref>.</p><p>In order to construct similarity measures which are computationally feasible, researchers have constructed new distances on the graphbased descriptors (most notably the merge tree) which have ultimately loosened the restrictions on stability while attempting to instead only maintain discriminativity to the bottleneck distance <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b33">34,</ref><ref type="bibr" target="#b35">36]</ref>. These distances sacrifice theoretical properties for computational feasibility. In this work, we ask if it is possible to construct a distance on merge trees that is still practical to use despite bounded computational complexity. We couple this with an approximation bound on this distance based on persistence simplification.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Contributions</head><p>We choose to focus our efforts on constructing a distance which can experimentally be shown to retain stability and discriminativity. To the best of our knowledge, this is the first distance with an implementation which is shown to be both discriminative and stable. Instead of designing a distance for all graph-based descriptors, we follow the lead of several other experimental distances <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b35">36]</ref> and focus on the simplest -the merge tree. Our algorithm matches the features of one merge tree to another and computes a cost of this matching which is heavily inspired by the universal distance <ref type="bibr" target="#b1">[2]</ref>.</p><p>More specifically, this work will contribute the following:</p><p>• Define an extended semipseudometric on merge trees by first encoding the features of the merge tree using branch decomposition trees;</p><p>• Construct an algorithm for this distance which utilizes the A*search algorithm to find a matching between vertices of two branch decomposition trees;</p><p>• Prove that persistence simplification of the dataset increases our distance by at most half the simplified value -allowing us to move larger datasets into more practical settings;</p><p>• Experimentally show that this distance is stable and more discriminative than the bottleneck distance while still retaining a similar "largest feature difference" approach to similarity measuring;</p><p>• Show the usefulness of stable, discriminative distances on several datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK 2.1 Graph-based Topological Descriptors</head><p>Graph-based topological descriptors include merge trees (sometimes specifically referred to as split trees or join trees), Reeb graphs, contour trees, and mapper graphs. Each descriptor is designed to show the changes of the topological structure in the underlying dataset. Reeb graphs are, arguably, the most complex descriptor in this family. Reeb graphs contract each component of each level set into a single point. The contour tree is simply the Reeb graph defined on a simply connected domain -making the contour tree a well-defined tree rather than a directed multigraph. Merge trees are then the simplest (both in structure and in computational cost) of these in that it encodes the sublevel (or superlevel) set topology rather than the levelset topology.</p><p>The visualization community has a long history of providing effective computations of these descriptors as well as using them for data analysis. Heine et al. recently surveyed many of their uses <ref type="bibr" target="#b25">[26]</ref>.</p><p>In this section, we highlight some of the more recent works as they relate to applications of level set topology, rather than providing an exhaustive survey. Oesterling et al. construct topological landscapes of high-dimensional point clouds using join trees <ref type="bibr" target="#b29">[30]</ref>. Bremer et al. capture the behavior of turbulent mixing by developing hierarchical techniques for merge trees <ref type="bibr" target="#b7">[8]</ref>. Thomas et al. explore symmetry detecting using contour trees <ref type="bibr" target="#b38">[39]</ref>. Widanagamaachchi et al. study atmospheric phenomena by constructing a tracking on merge trees <ref type="bibr" target="#b41">[42]</ref>. Yan et al. compute a structural average of merge trees for understanding statistical properties of collections <ref type="bibr" target="#b43">[44]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Distances on Merge Trees</head><p>Stability of merge trees was proven when the interleaving distance between merge trees was introduced <ref type="bibr" target="#b28">[29]</ref>. Afterwards, functional distortion distance was introduced for Reeb graphs <ref type="bibr" target="#b3">[4]</ref>, the interleaving distance was extended to Reeb graphs <ref type="bibr" target="#b11">[12]</ref>, and several edit distances were introduced for Reeb graphs <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15]</ref>. While the Reeb graphs are inherently different summaries of the scalar field, merge trees are still a 1-dimensional graph and thus many of the definitions introduced in these works can be applied directly to merge trees. Researchers have actually shown the equivalence of interleaving, functional distortion, and the universal distance on merge trees <ref type="bibr" target="#b1">[2]</ref>. Each of these aforementioned distances have been proven to be both stable and discriminative to the bottleneck distance <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b6">7,</ref><ref type="bibr" target="#b11">12,</ref><ref type="bibr" target="#b13">14,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b28">29]</ref>.</p><p>Unfortunately, implementations of these distances have been scarce due to their computational complexity. In order to have distances which are practical, other researchers have focused their efforts on defining distances specifically on merge trees due to their simplicity. As stated before, these distances loosen the restriction on either stability or discriminativity in order to have distances which are computationally feasible. To avoid confusion, we will call the collection of distances consisting of the interleaving, functional distortion, and universal distance as the theoretical merge tree distances. We call the collection of distinct distances we discuss below the experimental merge tree distances.</p><p>Sridharamurthy et al. introduced an edit distance between merge trees which is experimentally shown to be more discriminative than both the bottleneck and 1-Wasserstein distance <ref type="bibr" target="#b35">[36]</ref>. This distance loosens the restriction on stability which makes it computationally feasible. Cases of instability are still addressed by introducing an adjustable parameter which combines saddles which are within the parameters value -simplifying the topology of the merge tree. The distance was also proven to be a well-defined metric on the space of merge trees. This idea was later expanded upon with the introduction of the local merge tree edit distance -a well-defined metric specifically designed to study the local similarities at multiple resolutions rather than providing a global measure <ref type="bibr" target="#b36">[37]</ref>.</p><p>Beketayev et al. provides a computation of a similarity measure for merge trees by first computing all of its branch decomposition treesdata structures which encode features of the merge tree as nodes in a new tree -and then finding pairwise matchings between these trees. The matching imposes a restriction that if x matches to y and x is a child of x, then x must be matched to a child of y (or be deleted). This is similar to the 'ancestor preserving' restriction imposed by standard tree edit distance (TED) <ref type="bibr" target="#b37">[38]</ref>. Our distance that we propose in Sect. 4 similarly uses branch decomposition trees in order to encode the feature of a merge tree. We divert from this work by removing the 'ancestor preserving' restriction which allows us to maintain stability of our distance.</p><p>Saikia et al. <ref type="bibr" target="#b33">[34,</ref><ref type="bibr" target="#b34">35]</ref> produces a similar distance to the one defined by Beketayev et al. They introduce a dynamic programming algorithm to create an extended branch decomposition tree -a data structure which encodes similar data to the conglomerate of all possible branch decomposition trees without having to store all these possibilities in memory. They show the application of this distance on self-similarity of scalar fields and detecting periodicity in time-varying datasets.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">TECHNICAL BACKGROUND 3.1 Scalar Fields and Merge Trees</head><p>To ensure that our resulting structures are well-behaved, we elect to focus our attention towards piecewise linear-scalar fields: scalar fields in which the domain X is triangulable and the function f is piecewise linear. Furthermore, we will focus our work on scalar fields in which the domain is a simply connected, two-dimensional manifold and the function f is a simple Morse function <ref type="bibr" target="#b17">[18]</ref>. These conditions ensure that the merge tree is a well-defined, one-dimensional graph <ref type="bibr" target="#b11">[12]</ref>. Definition 1. A scalar field (equivalently an R-space) is a pair (X, f ) where X is topological space and f : X → R is a continuous real-valued function.</p><p>Definition 2. A sublevel set of X at a ∈ R, denoted as X a is the preimage of the set (−∞, a] under f . Similarly, a superlevel set of X at a is f −1 [a, ∞) and is denoted as X a . Definition 3. We define an equivalence relation ∼ f on X by stating that x ∼ f y if x, y ∈ X a and x and y both lie in the same connected component of the superlevel set. We define X f to be the quotient space X/ ∼ f and define f : X f → R to be the restriction of f to the domain X f . The pair S f := (X f , f ) is called the split tree of (X, f ). The join tree J f is defined analogously using sublevel sets rather than superlevel sets. The split and join tree make up the class of merge trees. We denote a general merge tree of the scalar field (X, f ) as</p><formula xml:id="formula_0">M f .</formula><p>In what follows, we will be working solely with the split tree. Some definitions, theorems, and parts of our algorithm work for both the join and split tree, while others are specific to the split tree due to aspects such as increasing paths from saddle to extrema rather than decreasing paths. However, if we were to negate the original function defined on the scalar field, we can provide a distance for the join tree as well. To this end, we will elect to use the term merge tree and use the notation M f for a merge tree defined on a scalar field (X, f ).</p><p>Since merge trees can be considered as labeled graphs, we will often denote the vertices and edges of M f as V (M f ) and E(M f ), respectively. From this, we can define the notion of merge tree isomorphism. Definition 4. Two merge trees M f and M g are isomorphic if there exists a bijection α : V (M f ) → V (M g ) such that 1) the edge e(u, u ) ∈ E(M f ) if and only if e(α(u), α(u )) ∈ E(M g ) and 2) for every u ∈ M f , we have f (u) = g(α(u)).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Persistence Diagrams and Bottleneck Distance</head><p>Instead of defining the persistence diagram on the scalar field, we elect to define the persistence diagram by using using the merge tree as a scalar field itself since it reduces the number of classes of points in the persistence diagram and overall makes the comparison between distances on persistence diagrams and distances on merge trees simpler; see Bollen et al. <ref type="bibr" target="#b6">[7]</ref> for a discussion on defining the persistence diagram of graph-based descriptors. For the sake of brevity, we show how to construct a persistence diagram from a merge tree and its properties rather than theoretical definitions.</p><p>The persistence diagram Dgm(M f ) of a merge tree M f is a multiset of points (a, b) which each represent a pair of vertices of the merge tree. These pairs intuitively represent different features of the merge tree. To determine which vertices are paired together, we introduce the elder rule.</p><p>Definition 5. The elder rule is a pairing scheme between saddles and extrema of a merge tree that says x is paired with y if there exists a monotone increasing path from y to x and if for all saddles y on the same path with f (y ) &gt; f (y), they are paired with an extrema x such that f</p><formula xml:id="formula_1">(x ) &lt; f (x). The persistence diagram is a multiset Dgm(M f ) where ( f (x), f (y)) ∈ Dgm(M f ) if x,</formula><p>y are a saddle extrema pair based on the elder rule with the addition of the pair ( f (g 1 ), f (g 2 )) where g 1 is the global minimum and g 2 is the global maxima. Persistence diagrams have been shown to be stable under the wellstudied bottleneck distance <ref type="bibr" target="#b9">[10,</ref><ref type="bibr" target="#b10">11]</ref>. The bottleneck distance assign a cost to a matching between the points of two persistence diagrams. We allow for each point to also be matched to an empty node which can be thought of as deleting or inserting that feature.</p><p>Definition 6 (Bottleneck Distance). Let D 1 , D 2 be two persistence diagrams and let λ denote an empty node. We define Di :</p><formula xml:id="formula_2">= D i ∪ {λ }. A matching M between D 1 and D 2 is a binary relation M ⊆ D1 × D2 such that each element from D 1 and D 2 appear in exactly one pair (x, y) ∈ M.</formula><p>The cost of a pair (x, y) ∈ M is defined as</p><formula xml:id="formula_3">c(x, y) = ⎧ ⎪ ⎨ ⎪ ⎩ max{|x 1 − y 1 |, |x 2 − y 2 |} x ∈ D 1 , y ∈ D 2 1 2 |x 1 − x 2 | x ∈ D 1 , y = λ 1 2 |y 1 − y 2 | x = λ , y ∈ D 2</formula><p>The cost of a matching M, denoted as c(M), is then the largest cost of all pairs in the matching.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Branch Decomposition Trees</head><p>The branch decomposition tree (BDT) is a data structure which, in topological data analysis, attempts to pair the saddles of contour trees or merge trees to the extrema of that tree. Each node in the BDT would then represent a feature of the original scalar field. Pascucci used the branch decomposition trees to inform a layout for complex contour trees with many self-intersections <ref type="bibr" target="#b30">[31]</ref>. Since then, BDTs have seen additional use as representations of merge trees for their comparison <ref type="bibr" target="#b5">[6,</ref><ref type="bibr" target="#b34">35]</ref>. Each merge tree or contour tree has precisely 2 n 2 −1 different possible BDTs, where n is the number of nodes <ref type="bibr" target="#b5">[6]</ref>. Often, a unique BDT is constructed by weighting the choice of pairing based on a particular measurement -such as persistence of the branch or the number of voxels of the branch in the scalar field <ref type="bibr" target="#b34">[35]</ref>. Definition 7. A branch is a monotone (in function value) path traversing a sequence of nodes in the merge tree M f . The first and last nodes of this sequence are called the endpoints of the branch. Definition 8. A branch decomposition of a merge tree is a set of branches such that every edge e ∈ E(M f ) appears in exactly one branch. For every hierarchical decomposition of a merge tree M f , we obtain a unique BDT b f . Each node u ∈ b f corresponds to two vertices of M f . If u ∈ b f is not the root node, then there is a corresponding saddle u s ∈ M f and a corresponding maxima u e ∈ MM f . The root node r ∈ b f corresponds to the global minimum r s ∈ M f and a maxima r e ∈ M f . We denote the set of all possible branch decomposition trees of a merge tree M f as B f . Fig. <ref type="figure" target="#fig_1">3</ref> shows the eight different BDTs for a merge tree with eight nodes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 9. A branch decomposition of a merge tree is a hierarchical decomposition if (1) there is exactly one branch which connects two extrema to one another (called the root branch and (2) every other branch connects an extrema to a node that is interior to another branch.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Definition 10. Let H f be a hierarchical decomposition of a merge tree</head><formula xml:id="formula_4">M f . The branch decomposition tree (BDT), b f , with respect to H f is a rooted tree b f = (V, E) where v = (v 1 , v 2 ) ∈ V represent the branches of H f .</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The edge e(v, u) ∈ E if and only if u has an endpoint interior to the branch v.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Stability and Discriminativity Definition 11. A distance d defined merge trees is said to be stable if and only if</head><formula xml:id="formula_5">d(M 1 , M 2 ) ≤ || f − g|| ∞ ,</formula><p>where f , g are the corresponding functions for the scalar fields of M 1 and M 2 , and M 1 and M 2 are defined on the same domain X.</p><p>Stability of a distance guarantees that point-wise perturbations introduced into the dataset will not drastically change the merge tree. Saikia et al. <ref type="bibr" target="#b33">[34]</ref> defined two different types of instabilities which are exhibited in merge trees: horizontal instabilities and vertical instabilities. Definition 12. Let (X, f ) be a scalar field with respective merge tree M f such that there exists a pair s 1 ,</p><formula xml:id="formula_6">s 2 ∈ V (M f ), with deg(s 1 ) = deg(s 2 ) = 3 and such that | f (s 1 ) − f (s 2 )| &lt; 2ε. If e(s 1 , s 2 ) ∈ E(M f ), then (X, f ) is horizontally ε-unstable.</formula><p>Definition 13. Let (X, f ) be a scalar field with respective merge tree M f such that there exists a pair of vertices m 1 ,</p><formula xml:id="formula_7">m 2 ∈ V (M f ), with deg(m 1 ) = deg(m 2 ) = 1 and such that | f (m 1 ) − f (m 2 )| &lt; 2ε. Let (s 1 , m 1 ) ∈ Dgm(M f ) and (s 2 , m 2 ) ∈ Dgm(M f ) be the persistence pairs corresponding to m 1 and m 2 , for some s 1 , s 2 ∈ V (M f ). If there exists monotone paths p 1,2 : s 1 → m 2 and p 2,1 : s 2 → m 1 , then (X, f ) is vertically ε-unstable,</formula><p>For our algorithm, we will use branch decomposition trees to organize the features of the scalar field. Due to this setup, we may have a situation where a small change in the function values of extrema switches their total ordering -possibly altering the topology of BDTs. This is called a vertical instability. Fig. <ref type="figure" target="#fig_2">4</ref> depicts the affects of perturbations in a vertical and horizontal manner on a function f . Definition 14. A distance d defined on merge trees is said to be more discriminative than a baseline distance d 0 if there exists some constant c &gt; 0 such that</p><formula xml:id="formula_8">d 0 (M f , M g ) ≤ c • d(M f , M g ),</formula><p>for all merge trees M f , M g , and if there does not exist a constant c such that d 0 = c • d. If a similarity measure is strictly bounded below by a baseline distance (up to a constant c), then there are cases in which the baseline distance is not able to discern between two merge trees while the distance d does detect some dissimilarity. Furthermore, this implies that if the distance d detects no difference between two merge trees, then the baseline will not detect any difference as well.</p><p>A core position on discriminativity being desirable is that we expect these merge tree distances to inherently be more computationally complex than persistence diagram distances since the graph-based descriptors are strictly more complex than set-based descriptors. Thus, these merge tree distances will trade off their computational efficiency for encoding more information in the similarity measure. As with the theoretical merge tree distances, we will use the bottleneck distance as our baseline since the theoretical merge tree distance and bottleneck distance all use a "max-feature-difference" approach to similarity measuring.</p><p>A similar notion to discriminativity is isomorphism invariance.</p><p>Definition 15. A distance d on merge trees is isomorphism invariant if d(M f , M g ) = 0 if and only if M f and M g are merge tree isomorphic.</p><p>It has been shown that the bottleneck distance is not isomorphism invariant on the space of merge trees while all of the theoretical graphbased distances are <ref type="bibr" target="#b6">[7]</ref>. The merge tree edit distance is also isomorphism invariant <ref type="bibr" target="#b35">[36]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Zigzag Diagrams</head><p>The universal distance (originally referred to as the Reeb graph edit distance <ref type="bibr" target="#b4">[5]</ref>) is a stable, discriminative distance defined on Reeb graphs and merge trees which has been shown to be the largest stable distance defined on Reeb graphs -a property known as universality. On merge trees, it was shown to be equivalent to the interleaving and functional distortion distance <ref type="bibr" target="#b1">[2]</ref> -thus making all of these distances universal.</p><p>The universal distance is defined by constructing a zigzag diagram of topological spaces which connects a source merge tree M f to its target M g . These zigzag diagrams can be intuitively thought of as a sequence of operations carrying one merge tree to another. We use a simplified version of the zigzag diagram for use with our distance. The term carry is used to state that we are transforming a source merge tree M f into a merge tree M which is isomorphic to M g .</p><formula xml:id="formula_9">Definition 16. Let M f , M g be two merge trees. A zigzag diagram Z is a sequence of merge trees M = {M f = M 1 , M 2 ,...,M n−1 , M n = M g }</formula><p>coupled with a sequence of 1-dimensional graphs X = {X 1 ,...,X n−1 } such that for each X i , there are two valid maps q i,i :</p><formula xml:id="formula_10">V (X i ) → V (M i ), q i,i+1 : V (X i ) → V (M i+1</formula><p>) which respect edge assignments. That is, if e(x j , x k ) ∈ X i , then e(q i,i (x j ), q i,i (x k )) ∈ M i . The sequence X will be called the connecting spaces of Z while M is called the merge trees of Z Each merge tree M i ∈ M will have an associated function f i . In general, these merge trees need not be Morse. Specifically, we will have merge trees with vertices of degree 4 which is not permitted under the definition of Morse functions on 2-manifolds. The connecting spaces are responsible for changing adjacencies in the merge trees. Fig. <ref type="figure" target="#fig_3">5</ref> depicts two different zigzag diagrams. The first carries a merge tree M f to M g , while the bottom diagram is in reverse order. Definition 17. The limit L of a zigzag diagram Z with n merge trees is the (n − 1)-dimensional space where x = (x 1 ,...,x n−1 ) ∈ L if q i,i+1 (x i ) = q i+1,i+1 (x i+1 ) for all x i . We define y i as y i = q i,i (x i ).</p><p>Definition 18. The spread S of an element x ∈ L is the difference between the maximum function value and minimum function value it attains in the zigzag diagram. That is,</p><formula xml:id="formula_11">S(x) = max i=1,...,n f i (y i ) − min i=1,...,n f i (y i ).</formula><p>The cost of the zigzag diagram Z is then the largest spread of its limit</p><formula xml:id="formula_12">L. c(z) = max x∈L S(x).</formula><p>When the choice of zigzag diagram is not clear, we use the notation L(Z) to denote the limit of the zigzag diagram Z. See Appendix A.2 for another example of a zigzag diagram with the corresponding spread.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">MERGE TREE MATCHING DISTANCE</head><p>The bottleneck distance constructs a similarity measure between scalar fields by 1) effectively encoding the features of the scalar field as a multiset of points, 2) constructing a way to match the encoded features of one scalar field to the features of another, 3) computing a cost on this matching by computing the largest difference between two matched features, and 4) taking the distance to be the lowest cost over all possible matchings. The theoretical merge tree distances can be thought of in a similar fashion. For example, the universal distance requires a choice of which features to transform into others, provides a way to carry out this transformation by using zigzag diagrams, and then computes a cost of this zigzag diagram <ref type="bibr" target="#b4">[5]</ref>.</p><p>Our distance is motivated by three main objectives:</p><p>• create a distance which is similar to the bottleneck distance and the theoretical merge tree distances in that it 1) properly encodes the features of the merge tree, 2) matches features of one merge tree to another, 3) assigns a cost to this matching by computing the largest feature difference, and 4) minimizes this cost over all possible matchings;</p><p>• construct it in such a way that it is isomorphism invariant on the set of merge trees as well as being more discriminative than the bottleneck distance; and</p><p>• make sure that the distance handles cases of instability correctly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Distance Definition</head><p>When constructing a distance between merge trees, we need to make sure that the distance captures the difference based on the relationship between features that are in the original scalar field rather than solely on the paired critical points. We encode this hierarchical relationship between features using the BDT, which also captures topological features (pairs of critical points) as individual vertices in the BDT. Unlike persistence diagrams, there are many different BDTs for each merge tree. Using only one can lead to vertical instabilities in the distance. Thus, in order to adequately find the distance between two merge trees, enumeration of all the BDTs is needed, similar to Beketayev et al. <ref type="bibr" target="#b5">[6]</ref>. Let M f , M g be two merge trees with respective sets of BDTs B f , B g . A matching between a fixed b f ∈ B f and b g ∈ B g gives us a matching between the features of M f and M g . Definition 19. Let M f , M g be two merge trees with respective sets of BDTs B f , B g . Let b 1 ∈ B f , b 2 ∈ B g be two BDTs and let λ be an empty node not in V (b 1 ) nor V (b 2 ). We let x e , x s denote the extrema and saddle nodes of a vertex x ∈ V (b i ). We define bi := b i ∪ {λ }. A matching M between b 1 and b 2 is a binary relation M ⊆ b1 × b2 such that the following conditions hold:</p><formula xml:id="formula_13">1. (r 1 , r 2 ) ∈ M, where r 1 ∈ V (b 1 ), r 2 ∈ V (b 2 ) are the respective roots of b 1 , b 2 .</formula><p>2. Each element in V (b 1 ) and V (b 2 ) appear in exactly one pair in M.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.">If</head><formula xml:id="formula_14">(x, λ ) ∈ M, then ( f (x e ), f (x s )) ∈ Dgm(M f ). 4. If (λ , y) ∈ M, then (g(y e ), g(y s )) ∈ Dgm(M g ) .</formula><p>A partial matching M is a matching between BDTs with condition 1) loosened to have each element of V (b 1 ) and V (b 2 ) appear in at most one pair of M .</p><p>Elements of a matching M fall into three different categories: insertion pairs which have the form (λ , v), deletion which pairs have the form (u, λ ), and relabel pairs which have the form (u, v). If (u, v) ∈ M and (u p , v p ) / ∈ M, where u p , v p are the parents of nodes u, v, then (u, v) is further categorized as a movement relabel pair.</p><p>An induced zigzag diagram is the zigzag diagram which arises from carrying one merge tree to another. This induced zigzag diagram follows the protocol that we apply insertions, non-movement relabels, movement relabels, and then deletions. We apply insertions first and deletions last since we cannot create disconnected merge trees in our zigzag diagram.</p><p>Each matching M between two BDTs b i ∈ B f ,b j ∈ B g induces two zigzag diagrams: the forward zigzag diagram Z f ,g from M f to M g , and the backward zigzag diagram Z g, f from M g to M f . The difference in these two induced zigzag diagrams is when the relabel pairs are applied. Taking the minimum cost over the forward and backward zigzag diagram ensures that we handle the instability in a way that keeps the distance below the L ∞ distance. Fig. <ref type="figure" target="#fig_3">5</ref> depicts an example of the possible difference. Since these merge trees are horizontal εunstable, we need to make sure that our distance is less than or equal to ε for us to have a distance below the L ∞ distance. In this case, ε = | g(y 1 ) − g(y 2 )|. Note that the backward zigzag diagram has a spread less than ε.</p><p>We define the cost of a matching as follows:</p><p>Definition 20. The cost of a matching M is the minimum value between the costs of the induced zigzag diagrams. That is,</p><formula xml:id="formula_15">c(M) = min Z∈{Z f ,g ,Zg, f } c(Z) = min L∈{L(Z f ,g ),L(Zg, f )} max x∈L(Z)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>S(x)</head><p>Definition 21. The merge tree matching distance is defined as the minimum cost of all matchings between all pairs of BDTs. That is,</p><formula xml:id="formula_16">d M (M f , M g ) = min bi∈B f ,b j ∈Bg min M∈Mi, j c(M),</formula><p>where M i, j denotes the set of all possible matchings between b i ∈ B f and b j ∈ B g .</p><p>Proposition 22. The merge tree matching distance is isomorphism invariant. That is, d M (M f , M g ) = 0 if and only if M f and M g are merge tree isomorphic.</p><p>Proof. Suppose M f and M g are isomorphic. Then, each have identical sets of BDTs. Let b f , b g be two such identical BDTs of M f , M g , respectively. We define M to be the matching induced by the isomorphism between b f and b g . Since they are isomorphic trees, there are no movement relabels in the induced zigzag diagram. Then, the induced zigzag diagrams will both consist of only the single merge tree since M f and M g are already isomorphic to one another. Now, suppose that The connecting spaces are viewed as 1-dimensional graphs in between each of the merge trees of the sequence. Here, we always have the mapping x i → y i for all maps from the connecting spaces to the respective merge trees. With horizontal instabilities, it is desirable that moving the branch e(y 2 , y 3 ) has a cost equal to the largest difference between moving y 2 up to its final position or y 1 down to its final position. Z f ,g achieves this cost, while Z g, f achieves a larger cost due to relabeling the saddle downwards to begin with, and then performing the movement.</p><p>the merge tree matching distance between M f and M g is 0. Then, there must exist a pair of BDTs b f and b g such that the matching induces no deletions, insertions, movement relabels, or relabels which incur a cost. Thus, b g and b g must be tree isomorphic as well as having the same values on each of their corresponding saddles and extrema. Thus, M f and M g must also be isomorphic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">ALGORITHM</head><p>Our algorithm is dependent on finding the cheapest matching between the vertices of all possible BDTs of two input merge trees. We are motivated by the well-studied graph edit distance (GED) in order to solve this. As stated in Section 4, the BDTs allow us to convert merge trees into data structures where the features of interest are now single vertices rather than pairs of vertices. GED has a similar problem statement: given two graphs G 1 and G 2 , find a matching between their vertices by deducing an edit sequence between the graphs. From this edit sequence a cost is computed. Our algorithm is split into three main components:</p><p>1. Construction of all BDTs from the input merge trees M f ,M g .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>Finding full matchings between two BDTs b f ,b g using the A* algorithm.</p><p>3. Computing the cost of a full matching M between b f and b g by first constructing the elements of the limit L(Z).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Constructing All Branch Decomposition Trees</head><p>Suppose we have a merge tree M f . As an example, we describe how to construct a persistence-based BDT. We first take the global min v 0 and find the path p v0,vn to the global max v n . The pair (v 0 , v n ) is placed as the root of the BDT. For every vertex v along this path, we recursively call the construction of the BDT algorithm with v being the new root. Each node v ∈ p v0,vn contributes a single child node to the root node.</p><p>The algorithm ends when all nodes are paired.</p><p>For general BDTs, we must consider every maxima v that is in the up-path of a root u as a possible pairing rather than just the global maxima of that branch. In order to avoid redundant computations of the same branches, we add another recursive layer to the BDT algorithm.</p><p>Suppose that (v s , v e ) is a pair corresponding to a branch B which has just been placed into a BDT b. For computation of a single BDT, we would recursively call this operation for all v ∈ p vs,ve . However, we know that for every node (v s , v e ), there are multiple different configurations of its children. To avoid redundant computations, we generate a specific number of BDTs for each possible pairing of a saddle v, for each v ∈ p vs,ve . First, assume v is the only vertex in p vs,ve which is not one of the endpoints. Let {u 1 ,...,u m } be the set of extrema in the up-path of v. For each pair (v, u i ), we construct a new copy of b and add (v, u i ) as the child of (v s , v e ). Now, suppose instead that {v 1 ,...,v k } is the set of vertices in p vs,ve which are not the endpoints. We proceed to carry out the same step as if there was only one non-endpoint vertex v, except instead of making m copies of b, we need to make a copy for the possible combinations of choices of extrema pairing for all v i ∈ {v 1 ,...,v k }. More specifically, if m i denotes the number of extrema that v i can be paired with, we make</p><formula xml:id="formula_17">m 1 • m 2 • ... • m k−1 • m k copies of b.</formula><p>Each b gets a unique set of nodes added as the children of (v s , v e ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Finding the Best Matching Using A*</head><p>The A* algorithm maintains a priority queue Q which holds a list of partial matchings M with a current cost c(M ). Since our distance requires the full matching before a true cost can be determined, we use the bottleneck distance between the currently matched nodes in order to under approximate cost. More specifically, let P be a partial matching between b f and b g . Then c(M ) = max (u,v)∈M c(u, v), where c(u, v) is the cost function in Equation <ref type="formula">6</ref>. As stated earlier, providing an under approximation to the true cost will guarantee that we still reach an optimal solution. However, since our under approximation will not necessarily converge to the true cost when we reach a full matching (unlike standard GED), we have to have an additional step which computes the true cost of the matching and to determine whether to continue finding better matchings dependent on this cost. Appendix A.3 shows an overview of our A* algorithm with this additional module.</p><p>The efficiency of A* is heavily dictated by introducing pruning techniques to reduce the number of possible matchings and using a good heuristic function which approximates the future cost along a particular path in the search tree. In our case, we can effectively prune the search space by not matching two nodes to one another if it would be cheaper to simply insert or delete both the nodes. As for a heuristic function, we introduce the function h(M ) which finds the lowest possible future cost based on the fact that if b f has n unmatched nodes and b g has m unmatched nodes, we must insert or delete the difference in the number of nodes. See Appendix A.1 for more information on our pruning and heuristic function. As opposed to GED, our "approximate cost" would then be max{c(M ), h(M )} rather than c(M ) + h(M ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Computing the Cost by Constructing the Limit L(Z)</head><p>Let b f and b g be the branch decomposition trees that we are comparing and let M be the current full matching between them. As stated before, the forward zigzag diagram Z f ,g is constructed by applying insertions, non-movement relabels, movement relabels, and then deletions to b f which ultimately creates b g . Just as the graph edit distance can be thought of as constructing edit sequences to carry one graph to another, our distance can be thought of as altering the branch decomposition b f with this set of operations in order to construct b g .</p><p>There is a one-to-one mapping between the vertices of any two connecting spaces. Thus, we keep the labeling of each connecting space the same. When we say that x i = x j for two vertices in different connecting spaces, this implies that i = j. We denote the set of vertices in the connecting spaces as V (X).</p><p>Let x i , x i+1 be vertices of X i , X i+1 , respectively. Note that</p><formula xml:id="formula_18">x i = {x 1 i ,...,x n−1 i</formula><p>} is an element of L(Z) for all x i ∈ V (X). Additional elements are added if q i,i+1 (x i ) = q i+1,i+1 (x i+1 ), for some x i ∈ X i and x i+1 ∈ X i+1 where x i = x i+1 . We call these swaps. For example, Fig. <ref type="figure" target="#fig_3">5</ref> has a swap in both the forward and backward zigzag diagram. For the forward zigzag diagram, a swap occurs in M 3 where q 1,2 (x 1 ) = q 2,2 (x 2 ). This implies {x 1 , x 1 , x 2 } is also an element of the limit. For every swap, there are two options to continue constructing the limit: continue with the same vertex or move to the swapped vertex.</p><p>In what follows, each pair (u, v) ∈ M would create at least one connecting space and one merge tree. If (u, v) is a movement relabel, we may create more. Each time we would create a merge tree and Fig. <ref type="figure">6</ref>. A depiction of a movement and how we record the swaps and intersection. The branch labeled u ∈ b k is matched with the branch labeled v ∈ b g , but their parents are not matched with each other. We find the path from the parent of u, denoted as u p , to the node which matches with the parent of v, denoted as u p . This requires us to have the branch u = (x 3 , x 5 ) to pass the saddle x 2 and then pass x 1 . Note that r f is the intersection and thus its saddle is not recorded as a swap.</p><p>connecting space, instead we create a copy the previous BDT and alter it according to the pair (inserting a node, deleting a node, relabeling, or moving a node). By the end of the algorithm, we are left with a set of BDTs</p><formula xml:id="formula_19">{b f = b 1 , b 2 ,...,b m−1 , b m = b g }</formula><p>and a list S of length m which will contain our swaps. These two data structures are enough to determine the elements of L(Z).</p><p>To begin, we construct a copy of b f and apply all n insertions. We sort the list of insertions by increasing depth order to make sure that if u is to be inserted on u , then u already exists. Non-movement relabels are then conducted in no particular order.</p><p>Let b k be the current BDT. In a movement relabel, we have a source branch u ∈ b k , its parent u p ∈ b k , a target branch v ∈ b g and the parent of the target v p ∈ b g . Let u be such that (u , v) ∈ M and u p be such that (u p , v p ) ∈ M. Our goal is then to move u to have parent u p . We find the path ρ : u p u p . The node closest to the root of b k in depth is known as the intersection. The intersection is the branch where u does not need to attach to its saddle. For every other branch w in the path ρ, we know we must add an additional connecting space and add the swap tuple (u s , w s ), where u s and w s are saddles of the respective merge trees, to the list. Fig. <ref type="figure">6</ref> depicts an example of recording the intersection and swaps for moving a Movement relabels need to be conducted in an order that makes sure that the BDT stays connected. Our A* algorithm has the restriction that if u is an ancestor of u , then u cannot become a descendant of u since it is suboptimal (i.e. another choice of BDT should be used if this is the case). However, once we begin altering the original BDT, there are situations where this u needs to be moved onto its parent. To alleviate this, we maintain another priority queue which holds all the movements, first ranked by the depth to the root. If we were to apply a movement, we check if this disconnection will occur. If so, we push the movement pair back into this priority queue with a lower priority index and move onto the next movement.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Putting It All Together</head><p>Algorithm 1 shows the pseudocode of how we first choose pairs of branch decomposition trees and then subsequently feed these pairs into our A* algorithm. Note that we introduce a "cutoff" variable which indicates when to stop the A* computation of a pair of BDTs. If the cheapest current matching is ever larger than this cutoff, we stop the computation and move onto the next pair.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">PERSISTENCE SIMPLIFICATION</head><p>Suppose we have two merge trees M f and M g whose distance d M is A. We can persistence simplify each by some 0 &lt; ε &lt; A to reduce its size -providing a graph which will be more readily computable by both direct computation. Our distance has the convenient property that a simplification by ε &gt; 0 will increase the distance by at most 1 2 ε. In the worst case scenario, we delete v. In this case, the largest increase from deletion of v and assigning u to v comes when they share a midpoint. Thus, the difference in deletion of v to the relabel is at most 1 2 ε. Simplification by the same value of ε is not necessary to achieve a bound on the distance. There may arise situations in which simplification by the same value of ε yields merge trees with too little information for data analysis. The less features that exist in the merge tree means the less information we may glean from the matching provided by the distance.</p><p>Corollary 24. Let M f , M g be two merge trees whose distance d M is A and let 0 &lt; ε 1 &lt; A and 0 &lt; ε 2 &lt; A be fixed. Then</p><formula xml:id="formula_20">A ≤ d M (P ε1 (M f ), P ε2 (M g )) ≤ A + 1 2 max{ε 1 , ε 2 }.</formula><p>Note that since the merge tree matching distance is always bounded below by the bottleneck distance, we can compute the bottleneck distance between the two merge trees and use the resulting value to gauge the value of ε.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">EXPERIMENTS</head><p>We implemented the algorithm described above using Python. We use the Topology Toolkit <ref type="bibr" target="#b39">[40]</ref> to visualize and extract merge trees from the input datasets. The bottleneck distance was computed in python through Persim <ref type="bibr" target="#b12">[13]</ref>. Each experiment was run using on a single AMD EPYC 7642 machine at 2.4GHz using 32 of the cores. We split the distance computations in batches to work on subsets of the data in parallel. Within a batch, we also took advantage of the on node parallelism to compute computing multiple distances at the same time. In each of these experiments, we have decided to apply persistence simplification in order to move our merge trees down to 14 nodes each.</p><p>In order to determine a size for the graphs which provided us with a good balance of computational feasibility and low persistence thresholding, we evaluated the computation times of 8,10,12,14,16 and 18 node graphs and the corresponding persistence thresholds which achieved these sizes. We randomly pulled 175 pairs of scalar fields from our shape comparison experiment (Sect. 7.1) and computed the distance between pairs to track the average computation time. Fig. <ref type="figure" target="#fig_5">8</ref> shows these values as line charts. We can see that using 16 and 18 node graphs begins to increase the computation time dramatically while the Fig. <ref type="figure">7</ref>. Two distance matrices of computing distance on the average geodesic scalar field of the TOSCA non-rigid world dataset. The left is using our merge tree matching distance. The right is the merge tree edit distance from Sridharamurthy et al. <ref type="bibr" target="#b35">[36]</ref>. persistence simplification needed to attain 16 and 18 node graphs is only slightly less than the persistence simplification value needed to attain 14 node graphs. For reference, the average difference between the global min and global max for this subset of the data was 272.79.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Shape Comparison</head><p>We took the TOSCA non-rigid world dataset, which contains a collection of shapes of animals and humans in different poses, and then we computed the average geodesic distance on each of them using the method suggested by Hilaga et al. <ref type="bibr" target="#b26">[27]</ref>. We randomly sampled a subset of 100 vertices from each mesh, calculated the geodesic distance from every vertex to the subset and then took the average. Next we persistence simplified the data, by using a custom threshold for each mesh so that we get 14 nodes in the split tree. The largest persistence simplification value was 7.34 which implies that the distances we have computed are at most 3.67 above the true distance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1.1">Results</head><p>We computed pairwise distance between 132 shapes, separating the 17424 distance computations into 12 batches. Each batch, with on-node parallelization from the 32 cores, took an of average 44.84 minutes. Fig. <ref type="figure">7</ref> shows the pairwise distances computations of our merge tree matching distance compared to the merge tree edit distance from Sridharamurthy et al. <ref type="bibr" target="#b35">[36]</ref>. We note that the distance matrix for merge to the rest of the shape dataset. We note that the horse pairs produce the same distance as the bottleneck distance. This is possibly due to few, if any, topological changes to get from one pose of the horse to another pose. Any of the topological changes must be outweighed non-movement relabels, insertions, or deletions. tree edit distance produced here differs from the distance matrix produced in their original paper. This can be due to several reasons: 1) we used more vertices of the scalar field in order to compute the average geodesic distance, 2) the merge tree edit distance does not simplify the resulting scalar field, and 3) a difference in color scale.</p><p>We can expect a difference between our distance and the merge tree edit distance due to our distance being more stable as well as merge tree distance summing the values of the feature differences rather than taking the largest feature difference.</p><p>We would like to note that our distance and the merge tree edit distance produce similar global patterns. For example, comparisons to the seahorse produce relatively large distances and comparisons between humanoid shapes produce relatively low distances. In our distance matrix, we can see that there is a low distance for comparison between two of the same classes of shapes, regardless of the pose it takes. Another interesting point is the relationship between the centaur to other shapes. The shape has a similar distance to each of the other shapes, besides the seahorse and shark, which may be expected due to half of the centaur's shape being similar to each of the other shapes.</p><p>In Fig. <ref type="figure">9</ref>, we depict the bottleneck distance compared to our merge tree matching distance for a single horse and single seahorse to all other poses. We note that the only time that our distance achieves the bottleneck distance exactly is when we compare the horse to other horse poses, centaur poses, or seahorse. This is likely due to the large features being able to be matched to one another with little need for adjacency changes. The case is similar for the seahorse pose.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">von K árm án Vortex Street</head><p>We obtained a von Kármán Vortex Street dataset from <ref type="bibr" target="#b22">[23]</ref> and calculated the vorticity scalar field for a set of uniformly sampled timesteps.</p><p>Then we persistence simplified each timestep so that the resulting merge would have exactly 14 nodes. Since we were only planning on obtaining 14 nodes, we decided to clip the vortex data so that more information from the clipped timestep could be obtained. Then we computed the pairwise distance using our distance between time-steps. The distance matrix is shown in Fig. <ref type="figure" target="#fig_7">10</ref>. The largest persistence simplification value was 6.60, which implies that the distances we have computed are 3.30 above the true distance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2.1">Results</head><p>As shown in Fig. <ref type="figure" target="#fig_7">10</ref> (right) we can see that there is an initial time period where there are no vortices in the data. This is reflected in the upper left hand cluster of the distance matrix in Fig. <ref type="figure" target="#fig_7">10</ref> (left) which shows low distance values between early consecutive timesteps.</p><p>Once the vortices have started forming, we can see that their positions periodically alternate as the vortices move forward. The collection of alternating high and low values in the bottom right section of the distance matrix demonstrates this periodicity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Stability Testing</head><p>To test the stability of our distance, we constructed a baseline scalar field (X 0 , f 0 ) with three maxima, two saddles, and the global minimum.</p><p>The two connected saddles are within ε of each other -making the scalar field horizontally ε-unstable. We generated 36 new scalar fields by applying a random plane multiplied by a Gaussian, to simulate random noise. The bottleneck, merge tree matching, and L ∞ distance was computed for each scalar field when compared to the baseline and plotted in Fig. <ref type="figure" target="#fig_4">1</ref>. We found that, as desired, our distance lay between the bottleneck and L ∞ distance.</p><p>The perturbation was chosen with several specifics in mind in order to correctly mimic the case of horizontal stability. Let ε = | f (x 2 ) − f (x 1 )|. The extrema x 3 , x 4 , x 5 are assigned function values such that each are more than 2ε greater than their connected saddle. Otherwise, the perturbation which we apply would create a new scalar field (X, g) such that deletion of e(x 2 , x 4 ), inserting e(y 2 , x 4 ), and adjusting the function value of x 1 to be the function value of y 1 would be optimal. Furthermore, since we wanted to focus on horizontal instabilities in this experiment, we made sure that the difference between x 5 and x 3 is larger than ε. Otherwise, the perturbation would essentially just be "reflecting" the merge tree, i.e. mapping x 3 to y 5 x 5 to y 3 .</p><p>It is worth noting that if there was no topology change in the data and our perturbation was only causing differences in function value, then our merge tree matching distance would be equal to the bottleneck distance. Thus, this distance is sufficiently capturing a perturbation which changes the topology of the merge tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">DISCUSSION</head><p>Here we have constructed a distance on merge trees which has experimentally been shown to be both stable and more discriminative than the bottleneck distance. Not only was our distance less than the L ∞ distance during our experimentation, but it was specifically designed to identify and quantify scenarios where perturbations in the dataset may cause topological changes in the merge tree or pairing changes in the persistence diagram and branch decomposition trees.</p><p>Properties of a Metric While we do not explicitly prove the triangle inequality and symmetry property, we would like to note that we verified that these properties hold on each of the datasets that we provided here. Comparison to Beketayev Distance Beketayev et al. introduced a distance on merge trees which also computes and compares all branch decomposition trees to one another <ref type="bibr" target="#b5">[6]</ref>. They are able to reduce the computation time of comparing all BDTs by not repeating comparisons of subtrees of specific BDTs. One fundamental difference that makes this possible is that once a node x is paired to a node y, the children of x must be mapped to the children of y, or be inserted/deleted. In our case, we cannot necessarily re-utilize comparisons of BDT subtrees since our nodes are always able to be mapped outside of any given subtree. This particular restriction of ancestor-descendant relationships is exactly what may cause horizontal instabilities while reducing the computation time. It is for a similar reason that a direct application of tree edit distance is unstable on merge trees.</p><p>Translation to Contour Trees and Reeb Graphs When translating to contour trees and Reeb graphs, the A* algorithm would still be able to adequately match features of one graph-based descriptor to another. Furthermore, we can introduce additional pruning since these theoretical graph-based distances always have the restriction that we cannot match features of different types to one another (e.g. an up-leaf cannot be matched to a down-leaf in a contour tree or Reeb graph). The hurdle that we run into is that of properly encoding the features of these descriptors. There is some nuance on choosing the pairing in contour trees. For example, the path from the global min to the global max may be a non-monotone path. To the best of our knowledge, there has been no generalization of the BDT for Reeb graphs.</p><p>Scalability We would like to make note that our algorithm still suffers from the issue of scalability. While a strength of our approach is that we can use persistence simplification to reduce the number of vertices while retaining accuracy, even small increases in the size of the merge tree may cause our computation time to increase in an exponential fashion (see Fig. <ref type="figure" target="#fig_5">8</ref>). Nevertheless, while analysis of small trees may be practical in some settings, we see developing a more efficient approach as an important, open challenge.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Fig. 2. A merge tree M f with its accompanying persistence diagram Dgm(M f ). The square point of Dgm(M f ) represents the pairing of the global min and global max.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Fig. 3. Set of possible branch decomposition trees for a single merge tree M f .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>Fig.4. Three functions, f , g, h all defined on the same domain X. The functions g and h are perturbed version of f , where g presents a vertical instability and h presents a horizontal instability. The corresponding branch decomposition trees are the unique BDTs determined by the persistence of each feature.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .</head><label>5</label><figDesc>Fig. 5. Depiction of the forward zigzag diagram Z f ,g (top) and the backward zigzag diagram Z g, f (bottom) of a matching between merge trees.The connecting spaces are viewed as 1-dimensional graphs in between each of the merge trees of the sequence. Here, we always have the mapping x i → y i for all maps from the connecting spaces to the respective merge trees. With horizontal instabilities, it is desirable that moving the branch e(y 2 , y 3 ) has a cost equal to the largest difference between moving y 2 up to its final position or y 1 down to its final position. Z f ,g achieves this cost, while Z g, f achieves a larger cost due to relabeling the saddle downwards to begin with, and then performing the movement.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Algorithm 1 mergeTreeMatchingDistance</head><label>1</label><figDesc>Input: Two merge trees M f , M g Output: Merge tree matching distance between M f , M g 1:B f = ConstructBDTs(M f ), B g = ConstructBDTs(M g ), cutoff = 0 2: for b f ∈ B f do 3: for b g ∈ B g do 4: currCost,completeMatch = aStar(b f ,b g ,cutoff) return dist Theorem 23. Let M f , M g be two merge trees whose distance d M is A and let 0 &lt; ε &lt; A be fixed. Then A ≤ d M (P ε (M f ), P ε (M g )) ≤ A + 1 2 ε.Proof. Let b f , b g be the optimal branch decomposition choices along with the optimal matching M. Suppose u = (u s , u e ) ∈ V (b f ) and | f (u s ) − f (u e )| &lt; ε. Then, persistence simplifying M f by ε removes u from b f and removes the pair (u, * ) ∈ M, where * may be the empty node λ or some node v ∈ V (b g ). If (u, λ ) ∈ M, then removal of the pair via simplification will not increase the distance since 1 2 | f (u s ) − f (u e )| &lt; ε &lt; A and therefore cannot be the largest cost pair in M. Now, suppose (u, v) ∈ M. If |g(v s ) − g(v e )| &gt; ε, then the cost may change depending on where v is now assigned.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 8 .</head><label>8</label><figDesc>Fig. 8. (left) The average computation times for a subsample of the shape comparison dataset with graph sizes 8, 10, 12, 14, 16, and 18. (right) The corresponding average persistence simplification values for this subsample of data.</figDesc><graphic url="image-21.png" coords="8,73.45,346.26,103.43,68.37" type="bitmap" /></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig.</head><label></label><figDesc>Fig. Comparison of single horse pose and single seahorse poseto the rest of the shape dataset. We note that the horse pairs produce the same distance as the bottleneck distance. This is possibly due to few, if any, topological changes to get from one pose of the horse to another pose. Any of the topological changes must be outweighed non-movement relabels, insertions, or deletions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 10 .</head><label>10</label><figDesc>Fig. 10. (Left)Pairwise distances between entries in 2-dimensional von K árm án vortex street. (Right) Three different timesteps of the von K árm án vortex street which depict the evolution of the vortices.</figDesc><graphic url="image-32.png" coords="9,336.83,159.14,86.29,57.31" type="bitmap" /></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>We thank Raghavendra Sridharamurthy and Vijay Natarajan for providing the comparison results of their algorithm <ref type="bibr" target="#b35">[36]</ref> on experiment used in Sect. 7.1. We also thank our anonymous reviewers for provided their detailed feedback and suggestions. This work is supported in part by the U.S. Department of Energy, Office of Science, Office of Advanced Scientific Computing Research, under Award Number(s) DE-SC-0019039.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Computing the Gromov-Hausdorff distance for metric trees</title>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">K</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Fox</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Nath</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Sidiropoulos</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Algorithms</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<date type="published" when="2018-04">apr 2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Quasi-universality of reeb graph distances</title>
		<author>
			<persName><forename type="first">U</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">B</forename><surname>Bjerkevik</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Fluhr</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">38th International Symposium on Computational Geometry, SoCG 2022</title>
		<title level="s">18. Schloss Dagstuhl -Leibniz-Zentrum für Informatik</title>
		<editor>
			<persName><forename type="first">X</forename><surname>Goaoc</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">M</forename><surname>Kerber</surname></persName>
		</editor>
		<meeting><address><addrLine>Berlin, Germany</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2022">June 7-10, 2022. 2022</date>
			<biblScope unit="volume">224</biblScope>
			<biblScope unit="page" from="1" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">An Edit Distance for Reeb Graphs</title>
		<author>
			<persName><forename type="first">U</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><forename type="middle">D</forename><surname>Fabio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Landi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics Workshop on 3D Object Retrieval. The Eurographics Association</title>
				<editor>
			<persName><forename type="first">A</forename><surname>Ferreira</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">A</forename><surname>Giachetti</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">D</forename><surname>Giorgi</surname></persName>
		</editor>
		<imprint>
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Measuring distance between Reeb graphs</title>
		<author>
			<persName><forename type="first">U</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">X</forename><surname>Ge</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Annual Symposium on Computational Geometry -SOCG&apos;14</title>
				<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The Reeb graph edit distance is universal</title>
		<author>
			<persName><forename type="first">U</forename><surname>Bauer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Landi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Mémoli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Foundations of Computational Mathematics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page">2020</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Measuring the distance between merge trees</title>
		<author>
			<persName><forename type="first">K</forename><surname>Beketayev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Yeliussizov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Morozov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><forename type="middle">H</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Topological Methods in Data Analysis and Visualization III, Theory, Algorithms, and Applications</title>
				<editor>
			<persName><forename type="first">P</forename><surname>Bremer</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">I</forename><surname>Hotz</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</editor>
		<editor>
			<persName><forename type="first">R</forename><surname>Peikert</surname></persName>
		</editor>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2014">2014</date>
			<biblScope unit="page" from="151" to="165" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">Reeb graph metrics from the ground up</title>
		<author>
			<persName><forename type="first">B</forename><surname>Bollen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><forename type="middle">W</forename><surname>Chambers</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Levine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Munch</surname></persName>
		</author>
		<idno>CoRR, abs/2110.05631</idno>
		<imprint>
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Interactive exploration and analysis of large-scale simulations using topologybased data segmentation</title>
		<author>
			<persName><forename type="first">P.-T</forename><surname>Bremer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tierny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Day</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Bell</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vis. Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="1307" to="1324" />
			<date type="published" when="2010">2010</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Computing contour trees in all dimensions</title>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Carr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Snoeyink</surname></persName>
		</author>
		<author>
			<persName><forename type="first">U</forename><surname>Axen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Geom</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="75" to="94" />
			<date type="published" when="2003">2003</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Stability of persistence diagrams</title>
		<author>
			<persName><forename type="first">D</forename><surname>Cohen-Steiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Edelsbrunner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Harer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete &amp; Computational Geometry -DCG</title>
		<imprint>
			<biblScope unit="volume">37</biblScope>
			<biblScope unit="page" from="263" to="271" />
			<date type="published" when="2005-01">01 2005</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Extending persistence using Poincaré and Lefschetz duality</title>
		<author>
			<persName><forename type="first">D</forename><surname>Cohen-Steiner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Edelsbrunner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Harer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Foundations of Computational Mathematics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="79" to="103" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Categorified Reeb graphs. Discrete &amp; Computational Geometry</title>
		<author>
			<persName><forename type="first">V</forename><surname>Silva</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Munch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Patel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2016">2016</date>
			<biblScope unit="page" from="1" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">Distances and represnetations of peristence diagrams</title>
		<author>
			<persName><forename type="first">P</forename><surname>Developers</surname></persName>
		</author>
		<ptr target="https://github.com/scikit-tda/persim" />
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
	<note>persim 0.3.1</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Reeb graphs of curves are stable under function perturbations</title>
		<author>
			<persName><forename type="first">B</forename><surname>Di Fabio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>And</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Landi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Mathematical Methods in the Applied Sciences</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<date type="published" when="2012-08">08 2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">The edit distance for Reeb graphs of surfaces</title>
		<author>
			<persName><forename type="first">B</forename></persName>
		</author>
		<author>
			<persName><forename type="first">Di</forename><surname>Fabio</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Landi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete &amp; Computational Geometry</title>
		<imprint>
			<biblScope unit="volume">55</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="423" to="461" />
			<date type="published" when="2016-01">jan 2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Visualizing nuclear scission through a multifield extension of topological analysis</title>
		<author>
			<persName><forename type="first">D</forename><surname>Duke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Carr</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Knoll</surname></persName>
		</author>
		<author>
			<persName><forename type="first">N</forename><surname>Schunck</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><forename type="middle">A</forename><surname>Nam</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Staszczak</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vis. Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2033" to="2040" />
			<date type="published" when="2012">2012</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Morse-Smale complexes for piecewise linear 3-manifolds</title>
		<author>
			<persName><forename type="first">H</forename><surname>Edelsbrunner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Harer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Natarajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the nineteenth annual symposium on Computational geometry, SCG &apos;03</title>
				<meeting>the nineteenth annual symposium on Computational geometry, SCG &apos;03<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2003">2003</date>
			<biblScope unit="page" from="361" to="370" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Computational topology: an introduction</title>
		<author>
			<persName><forename type="first">H</forename><surname>Edelsbrunner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">L</forename><surname>Harer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2022">2022</date>
			<publisher>American Mathematical Society</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Topological persistence and simplification</title>
		<author>
			<persName><forename type="first">H</forename><surname>Edelsbrunner</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><surname>Letscher</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Zomorodian</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discret. Comput. Geom</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="511" to="533" />
			<date type="published" when="2002">2002</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">Computers and Intractability; A Guide to the Theory of NP-Completeness</title>
		<author>
			<persName><forename type="first">M</forename><forename type="middle">R</forename><surname>Garey</surname></persName>
		</author>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">S</forename><surname>Johnson</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990">1990</date>
			<publisher>W. H. Freeman &amp; Co</publisher>
			<pubPlace>USA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Groups of polynomial growth and expanding maps (with an appendix by jacques tits)</title>
		<author>
			<persName><forename type="first">M</forename><surname>Gromov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Publications Mathématiques de l&apos;IH ÉS</title>
		<imprint>
			<biblScope unit="volume">53</biblScope>
			<biblScope unit="page" from="53" to="78" />
			<date type="published" when="1981">1981</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Characterizing molecular interactions in chemical systems</title>
		<author>
			<persName><forename type="first">D</forename><surname>Günther</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><forename type="middle">A</forename><surname>Boto</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Contreras-Garcia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J.-P</forename><surname>Piquemal</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Tierny</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vis. Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">20</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2476" to="2485" />
			<date type="published" when="2014">2014</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Generic objective vortices for flow visualization</title>
		<author>
			<persName><forename type="first">T</forename><surname>Gunther</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Gross</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Theisel</surname></persName>
		</author>
		<idno>141:1-141:11</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics (Proc. SIGGRAPH)</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A practical approach to Morse-Smale complex computation: Scalability and generality</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gyulassy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bremer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vis. Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1619" to="1626" />
			<date type="published" when="2008">2008</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Topologically clean distance fields</title>
		<author>
			<persName><forename type="first">A</forename><surname>Gyulassy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Duchaineau</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Natarajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Bringa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Higginbotham</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vis. Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="1432" to="1439" />
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">A Survey of Topology-based Methods in Visualization</title>
		<author>
			<persName><forename type="first">C</forename><surname>Heine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Leitte</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Hlawitschka</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Iuricich</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>De Floriani</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Scheuermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Hagen</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Garth</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="643" to="667" />
			<date type="published" when="2016">2016</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Topology matching for fully automatic similarity estimation of 3d shapes</title>
		<author>
			<persName><forename type="first">M</forename><surname>Hilaga</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Shinagawa</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Komura</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">L</forename><surname>Kunii</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH</title>
				<editor>
			<persName><forename type="first">L</forename><surname>Pocock</surname></persName>
		</editor>
		<meeting>SIGGRAPH</meeting>
		<imprint>
			<publisher>ACM</publisher>
			<date type="published" when="2001">2001</date>
			<biblScope unit="page" from="203" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Understanding the structure of the turbulent mixing layer in hydrodynamic instabilities</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">E</forename><surname>Laney</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bremer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mascarenhas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><forename type="middle">L</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vis. Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1053" to="1060" />
			<date type="published" when="2006">2006</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Interleaving distance between merge trees</title>
		<author>
			<persName><forename type="first">D</forename><surname>Morozov</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Beketayev</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Weber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of TopoInVis</title>
				<meeting>TopoInVis</meeting>
		<imprint>
			<date type="published" when="2013">2013</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Visualization of high-dimensional point clouds using their density distribution&apos;s topology</title>
		<author>
			<persName><forename type="first">P</forename><surname>Oesterling</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Heine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Janicke</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Scheuermann</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Heyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vis. Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="1547" to="1559" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<analytic>
		<title level="a" type="main">The toporrery: computation and presentation of multi-resolution topology</title>
		<author>
			<persName><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">K</forename><surname>Cole-Mclaughlin</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Scorzelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Mathematical Foundations of Scientific Visualization, Computer Graphics, and Massive Data Exploration</title>
				<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2009">2009</date>
			<biblScope unit="page" from="19" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<analytic>
		<title level="a" type="main">Robust on-line computation of reeb graphs: simplicity and speed</title>
		<author>
			<persName><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Scorzelli</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P</forename><surname>Bremer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Mascarenhas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page">58</biblScope>
			<date type="published" when="2007">2007</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Sur les points singuliers d&apos;une forme de Pfaff complètement intégrable ou d&apos;une fonction numérique</title>
		<author>
			<persName><forename type="first">G</forename><surname>Reeb</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1946">1946</date>
			<publisher>Acad. des Sci</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<analytic>
		<title level="a" type="main">Extended branch decomposition graphs: Structural comparison of scalar data</title>
		<author>
			<persName><forename type="first">H</forename><surname>Saikia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">H</forename><surname>Seidel</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Weinkauf</surname></persName>
		</author>
		<idno type="DOI">10.1111/cgf.12360</idno>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">06</biblScope>
			<biblScope unit="page">2014</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Global feature tracking and similarity estimation in time-dependent scalar fields</title>
		<author>
			<persName><forename type="first">H</forename><surname>Saikia</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Weinkauf</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">36</biblScope>
			<biblScope unit="page" from="1" to="11" />
			<date type="published" when="2017-06">06 2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Edit distance between merge trees</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sridharamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><surname>Masood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Kamakshidasan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Natarajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vis. Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="1" to="1" />
			<date type="published" when="2018">2018</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Comparative analysis of merge trees using local tree edit distance</title>
		<author>
			<persName><forename type="first">R</forename><surname>Sridharamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Natarajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vis. Comput. Graph</title>
		<imprint>
			<biblScope unit="page" from="1" to="1" />
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">The tree-to-tree correction problem</title>
		<author>
			<persName><forename type="first">K.-C</forename><surname>Tai</surname></persName>
		</author>
		<idno type="DOI">10.1145/322139.322143</idno>
	</analytic>
	<monogr>
		<title level="j">J. ACM</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="422" to="433" />
			<date type="published" when="1979-07">jul 1979</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<analytic>
		<title level="a" type="main">Symmetry in scalar field topology</title>
		<author>
			<persName><forename type="first">D</forename><forename type="middle">M</forename><surname>Thomas</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Natarajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vis. Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="2035" to="2044" />
			<date type="published" when="2011">2011</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">The Topology ToolKit</title>
		<author>
			<persName><forename type="first">J</forename><surname>Tierny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">G</forename><surname>Favelier</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><forename type="middle">A</forename><surname>Levine</surname></persName>
		</author>
		<author>
			<persName><forename type="first">C</forename><surname>Gueunet</surname></persName>
		</author>
		<author>
			<persName><forename type="first">M</forename><surname>Michaux</surname></persName>
		</author>
		<ptr target="https://topology-tool-kit.github.io/" />
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vis. Comput. Graph</title>
		<imprint>
			<date type="published" when="2017">2017</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">Loop surgery for volumetric meshes: Reeb graphs reduced to contour trees</title>
		<author>
			<persName><forename type="first">J</forename><surname>Tierny</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Gyulassy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Simon</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vis. Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1177" to="1184" />
			<date type="published" when="2009">2009</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Exploring the evolution of pressure-perturbations to understand atmospheric phenomena</title>
		<author>
			<persName><forename type="first">W</forename><surname>Widanagamaachchi</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Jacques</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Crosman</surname></persName>
		</author>
		<author>
			<persName><forename type="first">P.-T</forename><surname>Bremer</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Horel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">2017 IEEE Pacific Visualization Symposium (PacificVis)</title>
				<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2017">2017</date>
			<biblScope unit="page" from="101" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<analytic>
		<title level="a" type="main">Scalar field comparison with topological descriptors: Properties and applications for scientific visualization</title>
		<author>
			<persName><forename type="first">L</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">T</forename><forename type="middle">B</forename><surname>Masood</surname></persName>
		</author>
		<author>
			<persName><forename type="first">R</forename><surname>Sridharamurthy</surname></persName>
		</author>
		<author>
			<persName><forename type="first">F</forename><surname>Rasheed</surname></persName>
		</author>
		<author>
			<persName><forename type="first">V</forename><surname>Natarajan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">I</forename><surname>Hotz</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Comput. Graph. Forum</title>
		<imprint>
			<biblScope unit="volume">40</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="599" to="633" />
			<date type="published" when="2021">2021</date>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<analytic>
		<title level="a" type="main">A structural average of labeled merge trees for uncertainty visualization</title>
		<author>
			<persName><forename type="first">L</forename><surname>Yan</surname></persName>
		</author>
		<author>
			<persName><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Munch</surname></persName>
		</author>
		<author>
			<persName><forename type="first">E</forename><surname>Gasparovic</surname></persName>
		</author>
		<author>
			<persName><forename type="first">B</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Vis. Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">08</biblScope>
			<biblScope unit="page">2019</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<monogr>
		<title level="m" type="main">Comparing stars: On approximating graph edit distance</title>
		<author>
			<persName><forename type="first">Z</forename><surname>Zeng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">A</forename><surname>Tung</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName><forename type="first">J</forename><surname>Feng</surname></persName>
		</author>
		<author>
			<persName><forename type="first">L</forename><surname>Zhou</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009">2009</date>
			<publisher>PVLDB</publisher>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="25" to="36" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
