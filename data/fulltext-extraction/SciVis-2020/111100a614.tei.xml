<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Advanced Rendering of Line Data with Ambient Occlusion and Transparency</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Member, IEEE</roleName><forename type="first">David</forename><surname>Groß</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Chair of Computer Graphics &amp; Visualization</orgName>
								<orgName type="institution">TU-Dresden</orgName>
								<address>
									<settlement>Dresden</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Chair of Computer Graphics &amp; Visualization</orgName>
								<orgName type="institution">TU-Dresden</orgName>
								<address>
									<settlement>Dresden</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Stefan</forename><surname>Gumhold</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Chair of Computer Graphics &amp; Visualization</orgName>
								<orgName type="institution">TU-Dresden</orgName>
								<address>
									<settlement>Dresden</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
							<affiliation key="aff0">
								<orgName type="department">Chair of Computer Graphics &amp; Visualization</orgName>
								<orgName type="institution">TU-Dresden</orgName>
								<address>
									<settlement>Dresden</settlement>
									<country key="DE">Germany</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Advanced Rendering of Line Data with Ambient Occlusion and Transparency</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<note type="submission">received xx xxx. 201x; accepted xx xxx. 201x.</note>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T19:46+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Propeller</term>
					<term>Brain</term>
					<term>Aneurysm</term>
					<term>Convection</term>
					<term>Turbulence and Clouds Scientific visualization</term>
					<term>ray-casting</term>
					<term>line rendering</term>
					<term>transparency</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Fig. 1. Example renderings of the six data sets used during evaluation of our method, each rendered with local lighting, transparency and ambient occlusion. Data size ranges from approximately 100 thousand to 40 million segments.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>The efficient rendering of lines in 3D has become a valuable tool in scientific visualization. Simulations or the recording of data at higher resolutions generate increasingly large data sets. While local lighting is useful for perceiving the shape of individual lines, it is not sufficient to give an impression of large scale features like holes, rifts and cavities. Therefore, advanced effects from global illumination, like ambient occlusion or soft shadows, need to be applied to help discover these features. Furthermore, in densely sampled line sets inner structures of interest can be hidden by outside layers, hindering their perception and understanding. To overcome this problem the occlusion of structures needs to be reduced while still showing all of the data set, to preserve context. This can be achieved by applying transparency to the rendered geometry.</p><p>Several approaches exist for rendering lines. Most graphics APIs provide a line primitive type, which can be used to draw rasterized lines. This however, only allows to set a global line width given in pixels. Therefore all lines are displayed equally thick independent of perspective and distance to the camera. To overcome this issue, explicit geometry can be generated from the lines to render them as tubes. While feasible for smaller data sets, this approach can be impractical for large amounts of line segments, as a huge amount of geometry needs to be generated. This poses problems in memory consumption and rendering performance. An approach that does not suffer from the above mentioned problems is GPU-based ray casting <ref type="bibr" target="#b46">[45,</ref><ref type="bibr" target="#b48">47]</ref>. Here, first some proxy geometry -usually a camera facing billboard -is generated, which encompasses the primitive in screen space. In the fragment shader stage, for every generated fragment, a viewing ray can be calculated and tested for intersection with the primitive.</p><p>Incorporating global illumination effects in raster graphics is a challenging task, as only local geometry is accessible during the rendering procedure. Voxel-based global illumination <ref type="bibr" target="#b45">[44]</ref> is one method to provide the necessary global scene information during rendering. A simplified representation of the scene is generated, by rasterizing geometry into a voxel grid in a pre-processing step. To allow for the computation of ambient occlusion, the density of the geometry inside each voxel needs to be accumulated. Based on this density the amount of blocked light can be determined by tracing rays and sampling the voxel grid. This can be efficiently done on the GPU using voxel cone tracing <ref type="bibr" target="#b4">[5]</ref>, which utilizes a hierarchical voxel structure.</p><p>The use of transparency in raster graphics requires blending of fragments in correct visibility order with respect to the camera position. Techniques purely based on object-order sorting cannot guarantee this for arbitrary geometry. Existing solutions overcome this problem either by accumulating all fragments in a large list <ref type="bibr" target="#b3">[4,</ref><ref type="bibr" target="#b47">46]</ref> and sorting them per-pixel in a second step, or approximating visibility using different techniques. Collecting all fragments is an unbounded memory problem, as the total number of generated list entries is not known beforehand. In practical terms, the storage has to be limited and can therefore not guarantee to hold all values. Approximate methods work well in practice, but cannot always deliver accurate results.</p><p>In this work, we present a method to efficiently visualize large line data sets, like the ones shown in <ref type="figure">Fig. 1</ref>, using GPU-based ray casting. We use truncated cones with spherical caps, which we call rounded cones, to render individual line segments. This shape enables the use of a varying radius along the line and ensures a smooth connection between two successive tube segments. Voxel cone tracing is used, to add ambient occlusion to the final result. For transparency, we combine order dependent and independent methods. We assume high resolution line sets for our method, with lines being composed of relatively short segments, compared to the overall extents of the data. When sorted on a per-segment basis, most of the incorrectly ordered fragments will be locally confined. Correct order is restored by using a temporary buffer in which local visibility conflicts are resolved.</p><p>Our main contributions are:</p><p>• A method to calculate tightly aligned billboards for rounded cone primitives.</p><p>• A novel approach to calculate fragment visibility order in a single geometry pass, which combines methods from order dependent and order independent transparency.</p><p>• An acceleration technique based on culling line segments to improve rendering performance on highly dense data sets, both for opaque and transparent rendering.</p><p>The remaining paper is organized as follows: In Sect. 2 we review work that is related to ours. We present an overview of our method in Sect. 3. Sect. 4 describes our approach to transparent rendering of rounded cones as well as the culling methods used to speed up rendering. In Sect. 5 we describe implementation details for the GPUbased rendering. Sect. 6 shows the results of our method being applied to six real world data sets, with a discussion on findings and drawbacks of our method. Conclusion and future work are presented in Sect. 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>In this section we present a selection of related work discussing ray casting on the GPU, advanced methods for visualizing line data sets and techniques for transparent rendering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">GPU-based Ray Casting</head><p>Traditional GPU-based rendering uses explicit geometry composed of triangle meshes. For simpler primitive shapes the approach of using an implicit representation of their geometry and performing ray casting on the GPU can be used to improve rendering efficiency and quality. While a bounding box is always applicable to produce the required fragments for ray casting, several methods have been presented to create much simpler or tighter proxy geometry.</p><p>A method for sphere primitives has been presented by Sigg et al. <ref type="bibr" target="#b40">[40]</ref> and Reina <ref type="bibr" target="#b33">[34]</ref>. Both show analytic formulations for finding the four corner points of a perspectively correct image-space bounding box. Gumhold <ref type="bibr" target="#b13">[14]</ref> shows a technique for fast ray casting of ellipsoids on the GPU. The same is achieved by Klein and Ertl <ref type="bibr" target="#b20">[21]</ref> by using different proxy geometry. Efficient quadrilateral billboards for cylinders are both covered by Wu et al. <ref type="bibr" target="#b48">[47]</ref> and Toledo and Levy <ref type="bibr" target="#b46">[45]</ref>. The latter work also uses optimized bounding geometry for cone sections and torus slices. They apply their ray casted primitives to produce high quality visualizations of industrial structures. While their cylinder billboard scheme could be adopted to work with rounded cones, we refrained from doing so. Using our method only requires a single quad to encompass all of the cones geometry and prevents the need to use additional proxy geometry for the caps. Most importantly to us, it also does not produce highly trapezoidal shapes for steep viewing angles, which is a prerequisite for our culling scheme presented in Sect. 4.3. In <ref type="bibr" target="#b10">[11]</ref>, Falk et al. present a method to transfer any bounding geometry to a screen-space bounding box. While this is not guaranteed to reduce the amount of generated fragments, it can dramatically simplify the required geometry.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Rendering of Line Sets</head><p>Illumination is a key aspect of helping in understanding a 3D scene. When using traditional line rasterization however, no 3D geometry is created and thus no normals are present for local lighting calculation. Zöckler et al. <ref type="bibr" target="#b49">[48]</ref> overcome this issue by creating a definition for finding normal vectors on rasterized lines, which are coplanar with the light source direction. Precalculated textures are used to speed up rendering. An advancement to this method is presented by Mallo et al. <ref type="bibr" target="#b23">[24]</ref>, by defining a view dependent tangent frame for lines and a lighting model that averages reflectance over infinitesimally small cylinders. Preintegrated lighting information is stored in textures to enable efficient rendering supporting multiple light sources.</p><p>As simple line rasterization is limited, methods have been proposed that generate geometry from the line primitives. Kuhn et al. <ref type="bibr" target="#b21">[22]</ref> use view aligned triangle strips to extend line width in image-space. They define a density on this strip based on the distance to the original line. Accumulation of multiple line strips emphasizes dense regions in the data set. Everts et al. <ref type="bibr" target="#b8">[9]</ref> implement a stylized rendering of wide lines with depth dependent halos and depth cueing. They also apply their method to point sets. In a later work, Everts et al. <ref type="bibr" target="#b9">[10]</ref> extend the stylized rendering to allow for mapping texture patterns like arrows onto lines. A parametrization based on data attributes is used to map local line features to styles. The usage of triangle strips to create the impression of tube geometry is shown by Stoll et al. <ref type="bibr" target="#b43">[43]</ref>. They show a hybrid approach to render generalized cylinders with varying color and radius with simple geometry. On areas where planar primitives do not suffice, they tessellate geometry on the CPU. Similar approaches are shown by Schirski et al. <ref type="bibr" target="#b37">[38]</ref> and <ref type="bibr" target="#b27">[28]</ref>. Explicit geometry is used by <ref type="bibr" target="#b18">[19]</ref>, where tubes are created as triangle meshes.</p><p>To display lines as tubes without the need for generating explicit geometry, one can use ray tracing as shown in a recent work by Han et al. <ref type="bibr" target="#b16">[17]</ref>. Their CPU-based implementation allows for high-performance visualization of generalized tube primitives and supports varying radii, bifurcations and transparency. An optimized GPU-based implementation of tube ray tracing is given by Kanzler et al. <ref type="bibr" target="#b17">[18]</ref>. They encode line data into a voxel grid and encode the lines by discretizing their positions onto voxel boundaries. The voxel grid is used for accelerating the ray tracing process and to generate a density representation, which is further used for ambient occlusion and soft shadow effects. While the process of discretization reduces memory footprint, it also greatly influences visualization quality especially on low resolutions. Schussman and Ma <ref type="bibr" target="#b38">[39]</ref> also use a voxel representation, which additionally captures directional anisotropy using spherical harmonics. Traditional volume rendering is used for visualization.</p><p>The usage of transparency in line rendering is both discussed in <ref type="bibr" target="#b14">[15]</ref> and <ref type="bibr" target="#b28">[29]</ref>. In the former work by Günther et al., an optimization process for determining view dependent transparency is presented. They allow for a user defined importance score to influence visibility calculation. Mishchenko and Crawfis <ref type="bibr" target="#b28">[29]</ref> conduct a user study on the effectiveness of transparency in streamline rendering measuring the users ability to discern different flow directions. So far, a multitude of transparent rendering methods has been proposed. An overview of these methods as used in line rendering, as well as a performance evaluation, is given by Kern et al. <ref type="bibr" target="#b18">[19]</ref>.</p><p>Eichelbaum et al. <ref type="bibr" target="#b5">[6]</ref> present LineAO, a screen-space solution to incorporate ambient occlusion in line rendering. They extend traditional screen-space ambient occlusion by sampling on multiple hemispheres and using distance based weighting. An object-space method based on voxel cone tracing <ref type="bibr" target="#b4">[5]</ref> for particle data is shown by Staib et al. <ref type="bibr" target="#b41">[41]</ref>. In addition they incorporate ambient illumination effects. Respectively, we apply voxel cone tracing to calculate ambient occlusion on a objectspace level to our rounded cone rendering.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Transparency</head><p>Correct transparency in raster graphics involves visibility sorting on a per fragment basis. Carpenter <ref type="bibr" target="#b3">[4]</ref> presents the concept of the a-buffer, which can be used as additional storage during rendering to accumulate fragment information. For transparency, one can store fragment color and depth and render them in sorted order in a second pass. Yang et al. <ref type="bibr" target="#b47">[46]</ref> give an efficient way of implementing an a-buffer on modern GPUs, by using a global atomic counter and per-pixel linked lists. A similar method is proposed by Bavoil et al. <ref type="bibr" target="#b2">[3]</ref> with their idea of a k-buffer, which serves as read-modify-write memory of k entries per pixel. This way, only the nearest k fragments get stored and blended correctly, with the remaining fragments being blended heuristically. We extend on this idea by using the k-buffer as a means of intermediate storage to reorder fragments as they are produced and blend them in correct visibility order. The process of depth peeling (DP), Everitt <ref type="bibr" target="#b7">[8]</ref>, involves the use of a dual depth buffer and multiple render passes. Each pass extracts the next closest fragment by comparing its depth with the previously stored value in the second depth buffer.</p><p>Several methods have been presented to achieve plausible results using order independent transparency. Hybrid transparency by Maule et al. <ref type="bibr" target="#b24">[25]</ref> uses an exact compositing of a few foreground layers and a fast approximate method for the remaining fragments. By using a truncated a-buffer, memory needs stay bounded. McGuire and Bavoil <ref type="bibr" target="#b25">[26]</ref> apply weights to the blending operation based on the fragments occlusion and distance to the camera. Salvi and Lefohn <ref type="bibr" target="#b34">[35]</ref> employ an a-buffer implementation for their adaptive transparency technique, to build an approximate visibility function while accumulating fragments. In a second pass, fragments are blended in unsorted order using an additive blending operation. An approach using a per-pixel approximation of the transmittance function based on trigonometric or power moments is presented by Münstermann et al. <ref type="bibr" target="#b29">[30]</ref>. The usage of additive blending is enabled by logarithmic scaling of the transmittance function. Salvi and Vaidyanathan <ref type="bibr" target="#b35">[36]</ref> use a fixed-size storage per pixel to successively store layers and once full, blend the two most appropriate adjacent layers to keep memory needs bounded. Recently this method has been extended by Kern et al. <ref type="bibr" target="#b18">[19]</ref> to reduce its dependency on the order in which fragments are generated. Kern et al. introduce depth buckets as a means to segment the scene into depth intervals and perform multi-layer alpha blending inside each bucket. The resulting values in each bucket are then blended in front-to-back order. Contrary to these methods, we rely on geometry being rendered in visibility order, although this may produce wrong fragment order at first. We provide a solution to restore the visibility order of fragments without the need for approximate blending functions.</p><p>Stochastic transparency by Enderton et al. <ref type="bibr" target="#b6">[7]</ref> uses sub-pixel samples of transparent layers, with coverage relative to their opacity. The resulting image is created by averaging the samples. They provide a solution to reduce the noise inherent to this method. McGuire and Mara <ref type="bibr" target="#b26">[27]</ref> also use a sample-based approach and show techniques for realistic rendering of translucent phenomena.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">METHOD OVERVIEW</head><p>In this section we give an overview of our approach to render line sets with ambient occlusion and transparency. The whole process is shown in <ref type="figure" target="#fig_0">Fig. 2</ref>.</p><p>After loading the data and converting it to an internal format, we begin building the density volume. This is done by rasterizing the individual line segments as described in Sect. 5.3. This preprocessing step is performed only once per data set on the CPU. In order to render on the GPU, the prepared line data needs to be transferred into video memory. All of the proxy geometry needed for ray casting is generated on the GPU, so only the raw line data needs to be stored. Each line segment is defined by two positions, radii and RGBA color values. For opaque rendering these are stored in a vertex buffer object. A shader storage buffer object is used for transparent rendering instead (see Sect. 5.4).</p><p>During rendering the data is sorted according to the current view configuration. A fast GPU implementation is employed for this purpose, which directly uses the position buffer to calculate the distance values. As a result of the sorting process detailed in Sect. 4.1, an index buffer can now be used to render line segments in per-object visibility order. By only drawing successive parts of the index buffer, the geometry is split into distinct depth slices. This is a perquisite to employ our primitive culling scheme as described in Sect. 4.3.</p><p>After each depth slice is drawn to a frame buffer object, the appropriate culling mipmap is created using a fast compute shader implementation. This can be used for the next slice, where it is utilized to speed up rendering. To render the rounded cone primitives in each depth slice, the geometry shader is used for generating view aligned billboards, which act as proxy geometry for the ray casting process. We show our approach to generate these billboards in Sect. 5.1. Using the culling mipmap we can determine if primitives shall be ignored for further processing, in turn saving GPU cycles.</p><p>An intersection test between the viewing ray and the rounded cone is performed in the fragment shader for each fragment produced after rasterization. If successful, we compute local lighting and evaluate the ambient occlusion term using the precomputed density volume. Using the depth information, we insert each fragment into the k-buffer, ensuring that the entries are kept in sorted order (see Sect. 4.2). Fragments are discarded until the intermediate buffer is completely occupied, at which point the overflowing fragments get blended to the screen. The process repeats until every slice is drawn. To complete the image a full screen pass blends the remaining fragments in the k-buffer to the screen.</p><p>In the case of rendering fully opaque, the evaluation of the shading and ambient occlusion term is omitted until every slice is drawn. Instead the color, position and normal values are stored in frame buffer attachments and a full screen deferred shading pass is performed to limit costly calculations to visible pixels only.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">VISIBILITY SORTING</head><p>Our approach to transparent rendering is based on object order. This requires the rounded cones to be rendered according to their visibility to the view point. We sort primitives in front to back order, i.e. by increasing depth, to support our hierarchical culling strategy. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Sorting of Rounded Cone Primitives</head><p>For visibility sorting of the rounded cone primitives we use the minimum distance to the view point over the line segment connecting the cone's end points. To prevent reordering the whole data an index buffer is used for rendering, which holds two indices per line segment. It is possible to sort the index buffer directly, by rearranging both indices as a pair. However, keeping the amount of memory per sort element low is key to high sorting performance. We therefore use another index buffer with a single index per segment, to sort the segments by distance to the camera. By carefully choosing our indexing scheme as shown in <ref type="figure" target="#fig_1">Fig. 3</ref>, we can compute the final vertex indices from the sorted segment indices as L 0 (S i ) = 2S i and L 1 (S i ) = 2S i + 1. We finally render all line segments in a single indexed draw call with line primitives. While this method has the disadvantage of duplicated indices where two segments are connected, it allows for simple calculation of the index buffers without additional information on the GPU. Based on the sort criterion we use a GPU-based implementation of a prefix-sum radix sort similar to <ref type="bibr" target="#b15">[16]</ref>. Sorting is recomputed only after changes to the viewing parameters.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Fragment Sorting</head><p>If segments are very close or even overlap, a pure per primitive sorting can produce an incorrect fragment order. It is therefore necessary to rearrange these fragments into their appropriate order during rendering. Using additional read-modify-write memory during the render process, allows us to temporarily store and manipulate fragment data. This can be achieved by employing a variant of the k-buffer <ref type="bibr" target="#b2">[3]</ref>, which is able to store k entries for each pixel. The buffer is initialized to be empty upon each frame. Once the final color and depth value of a fragment is determined, it gets stored into the corresponding pixel buffer by following an insertion sort strategy, where all fragments with lower depth are moved by one slot in the list and the new one is inserted at the correct position. After k fragments have been generated for a specific pixel, the nearest will be pulled from the list, making room for the next fragment. Up to the k th fragment rendered per pixel, no output is written to the image, as all fragment values are stored to the intermediate buffer. After the whole geometry has been processed, each per-pixel buffer can have up to k entries, which have not yet been blended to the image. A second full-screen pass blends the fragment colors together, considering the correct visibility order, and writes them to the image.</p><p>When implemented on a GPU, two key problems to this approach arise. First, due to the parallel processing nature, more than one fragment falling into the same pixel can be generated at once, leading to race conditions when writing to the intermediate buffer. Second, the order in which geometry is processed cannot be guaranteed on the fragment level. Atomic operations can be used to overcome the first issue, as was shown by Liu et al. <ref type="bibr" target="#b22">[23]</ref>. They effectively peel of the front-most n layers using atomic compare functions while looping over the buffer entries. Each entry is represented by a 32-bit unsigned integer, packing compressed depth and color information. As depth information is stored in the most-significant bits, the per-pixel lists are always sorted in visibility order. Modern OpenGL Hardware supports atomic operations on 64-bit unsigned integers using the NV shader atomic int64 extension <ref type="bibr" target="#b31">[32]</ref>. We therefore pack the 32-bit depth information in the most significant bits of a 64-bit unsigned integer. The lower bits are filled by color values with each RGBA component mapped to <ref type="bibr">[0,</ref><ref type="bibr">255]</ref>. Using 64-bit instead of 32-bit unsigned integers allows us to keep full depth and sufficient color accuracy. Contrary to <ref type="bibr" target="#b22">[23]</ref>, we do not discard fragments overflowing from the per-pixel lists, but rather blend them to the screen.</p><p>After a fragment entry has been determined, it is stored in a temporary variable. We then loop over all k entries of the intermediate buffer, using an atomic max operation to compare the temporary variable to the one stored in the buffer. The process is stopped, when an empty slot is found or after looping over the whole buffer. Upon insertion of a new value into the buffer, the temporary variable will hold the entry with the smallest depth value and the entries will be sorted in depth-descending order. We restore the color information from the minimal entry and output the fragment.</p><p>OpenGL only guarantees to blend fragments in the order at which the objects they are generated from are drawn, but not how they are processed. Using this reordering strategy results in fragment shader invocations possibly writing fragments that originated from a different primitive. Solving this second problem can be accomplished by utilizing the ARB fragment shader interlock <ref type="bibr" target="#b19">[20]</ref> extension. The extension allows us to specify a critical section around the atomic loop used for sorting fragments. This ensures that, for two pairs of shader invocations overlapping the same pixel, only one is executing the atomic loop at a given time. Using this scheme, local ordering issues can be effectively overcome to produce correct transparency in a single geometry pass.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Culling of Primitives</head><p>The need for sorting objects using our approach to transparency enables the optimization of the rendering process. The general idea follows the one presented in Grottel et al. <ref type="bibr" target="#b11">[12]</ref>, where they render opaque particle data using a two-stage culling scheme. We adapt the vertex-level culling to work with rounded cones and our rendering method that supports transparent rendering. Drawing the primitives in a front-to-back manner allows to use information from geometry closer to the view point being used for successive objects. While rendering on the GPU, information from finished primitives is not readily available in the same render pass. We therefore split the scene into separate depth slices, drawing the front most slice first. Generating the slices is implicitly done by issuing multiple draw calls for successive parts of the index buffer, which prevents the need to split individual segments. It should be noted that the per-slice rendering is independent of the fragment sorting inside of the k-buffer. The buffer is not cleared between two slices and the final blend of the remaining fragments happens only after the last geometry slice is drawn. After each slice that is drawn, the frame buffer contains the according color and opacity information. Opacity values are then extracted and written into a separate 2D texture with filtering set to GL NEAREST. A compute shader implementation is used to generate mipmap levels for this texture, by combining 4 neighboring texels and choosing the minimum opacity value. We omit the first level of the mipmap, with full image resolution, to avoid copying large amounts of data and instead directly write to the second level. The minimumopacity mipmap is bound for rendering the next slice, where it can be sampled in the rounded cones shader program. After generating the image-space bounding quad, we transform this into a screen-aligned bounding box. Using the largest edge length of this bounding box, a mipmap level can be determined, whose texel size is greater or equal to this length. This way, the aligned bounding box overlaps a maximum of four texels of the mipmap level. Four texture samples are taken, each containing the minimum opacity value present in the pixel it covers. By taking the minimum of these samples, we can discard the primitive based on an opacity threshold, as further blending operations will only have a diminishing impact on the final color values. For our implementation we start culling at opacity values greater than 0.95. Primitives are discarded in the geometry shader by simply not writing any output. Through substitution of the minimum-opacity mipmap with a maximum-depth mipmap this optimization is also applicable to fully opaque rendering. The early-z test implemented on the GPU, is disabled when explicitly writing to the depth buffer, as done by the rounded cone ray casting approach. costly intersection tests are evaluated on fragments, that end up being occluded in the final image. A conservative depth estimate for each segment is made by choosing the closest of the two defining points and subtracting the maximum radius. This depth is then tested against the four texture samples. The primitive is discarded, when no sample has a depth value larger than the conservative estimate. In case of opaque rendering sorting is not strictly required, such that our culling technique introduces a notable overhead. We therefore only sort when larger changes in the camera position or view angle occur.</p><p>In addition to primitive-level culling we apply per-fragment culling using the minimum-opacity or maximum-depth mipmaps. This helps to remove invisible parts of primitives, which did not get removed in the previous step because of partial visibility. While this basically re-implements depth testing for opaque rendering, it also provides a way of discarding individual fragments when using transparency.</p><p>Through usage of the culling mipmaps, we can regain some of the lost performance in opaque rendering and speed up transparent rendering. The extension to culling whole primitives, in addition to only fragments, reduces the amount of geometry, that has to be produced by the geometry shader.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">GPU-BASED RAY CASTING OF ROUNDED CONES</head><p>Rendering the rounded cones is done using GL LINE primitives. The vertex stage is a simple pass-through shader, which receives a position, radius and color as input. The proxy geometry needed for ray casting is built on the fly in the geometry shader, following the algorithm described in Sect. 5.1, and assembled as a triangle strip conststing of 4 vertices. The geometry shader is set up to receive lines, so that both the start and end point variables are accessible. The ray primitive intersection is computed as described in Sect. 5.2. The resulting depth is converted to window coordinates and passed on to the k-buffer insertion described in Sect. 4.2.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Billboards</head><p>For efficient ray casting on the GPU, in the context of raster graphics, it is necessary to perform the intersection test on as few fragments as possible. In order to generate these fragments, some geometry needs to be generated beforehand, which covers the whole silhouette of the rounded cone in image space. Using a bounding box for this purpose is both easy to implement and guaranteed to fulfill this requirement. However, for rounded cones the same can be achieve by using a single quad. Our goal is to generate a quad that is aligned with the cones main axis in image space, tightly encompassing its silhouette while remaining close to rectangular even at steep viewing angles. While our billboards might closely resemble screen-space bounding boxes, like discussed in <ref type="bibr" target="#b46">[45]</ref>, at first glance (see <ref type="figure" target="#fig_3">Fig. 5</ref>), they actually differ from them in that they rotate with the cone in screen-space. This prevents the generation of unnecessary fragments, especially for long thin tubes.</p><p>The general idea behind our approach can be described as follows: The spherical caps of the rounded cone primitive define the start and end point of the cone along its main axis. We can therefore implicitly define spheres at both of the caps center positions. For each of these spheres we can calculate two points located on the silhouette as seen from the camera, making sure they are aligned with respect to the main axis. From the outermost points we can construct the four corners of the billboard. The following explanation details this process and applies to cones that fulfill the condition r 0 ≤ r 1 , with r 0 being the start cap radius and r 1 the end cap radius. We later show how to modify this approach to work in the case of r 0 &gt; r 1 .</p><p>Let a cone be defined by start and end position x 0 and x 1 . The direction of the cones main axis is defined as d = x 1 −x 0 . The directions from the start-and endpoint towards the view point e are given by d 0 = e − x 0 and d 1 = e − x 1 . We can then define support unit vectorŝ</p><formula xml:id="formula_0">v 0 ,v 1 andû viaû = d × d 0 • d × d 0 −1 v 0 = u × d 0 • u × d 0 −1 v 1 = u × d 1 • u × d 1 −1 .<label>(1)</label></formula><p>This way,û is always orthogonal to the cones main axis and botĥ v 0 andv 1 lie in the plane defined through e and u. As such, they appear parallel to the cones main axis, when projected into imagespace. Directions d 0 ,v 0 andû form a tangent space basis on the surface point x 0 of a sphere centered at e with radius d 0 . The same applies for x 1 .</p><p>The tangent space directions can be used to define corner points of the camera facing billboard for each sphere by scaling them accordingly. Due to perspective distortion however, the given start and end radius for the cone cannot be used directly. Instead, the radii must be calculated as to take perspective distortion into account. Starting from the view point e, a cone can be defined, which touches the sphere tangentially. Because of rotational symmetry around the axis defined by the line from e to x 0 , we can reduce this to a 2D problem. The process of calculating the corrected radius r 0 is illustrated in <ref type="figure" target="#fig_2">Fig. 4 (bottom right)</ref>. A line is defined, starting at e, touching the sphere tangentially. Together with r 0 and the spheres center point x 0 , a triangle can be constructed. Using the rule of three we can solve for the new radius:</p><formula xml:id="formula_1">r 0 d 0 = r 0 t 0 r 0 = d 0 • r 0 t 0 = d 0 • s 0<label>(2)</label></formula><p>with</p><formula xml:id="formula_2">t 0 = d 0 2 − r 0 2 .<label>(3)</label></formula><p>This approach differs from the one presented in <ref type="bibr" target="#b33">[34]</ref>, as our formulation gives us a scaling factor s 0 , and direct control over the distance at which we want to calculate r 0 . The corrected radius r 1 can be determined likewise. Now r 0 and r 1 can be used to scalev 0 andv 1 to fit to the spheres extents in direction of the cones main axis. We can now define four points as seen in <ref type="figure" target="#fig_2">Fig. 4</ref>, which delimit the cone start and end cap spheres on the plane defined by e and u in image space:</p><formula xml:id="formula_3">p 0 = x 0 + r 0 •v 0 , p 1 = x 0 − r 0 •v 0 , p 2 = x 1 + r 1 •v 1 , p 3 = x 1 − r 1 •v 1 .<label>(4)</label></formula><p>The corner positions c 0 to c 3 shown in <ref type="figure" target="#fig_3">Fig. 5</ref> will be calculated in the final step, by adding and subtracting the scaled directionû. However, r 0 and r 1 cannot be used for this purpose as the start and end radius of the rounded cone can be different. If this were the case, c 0 and c 1 would be located too close to the main axis and the lines connecting c 0 to c 2 and c 1 to c 3 would intersect the larger sphere centered at x 1 , as depicted by the red dotted line in <ref type="figure" target="#fig_3">Fig. 5</ref>.</p><p>A conservative adjustment of the scaling factors ofû has to be given. We do this by choosing the sphere with the largest image space projection using the scaling factors determined in Equation 2. By substituting d 0 and d 1 with 1 we can determine which sphere silhouette appears larger on screen, when both are at the same distance to the view point. The maximum of both scaling factors is defined as s m = max(s 0 , s 1 ). The scaled radii in direction u can then be determined as</p><formula xml:id="formula_4">r 0 = d 0 • s m and r 1 = d 1 • s m .<label>(5)</label></formula><p>All of the points p 0 to p 3 may be located on the silhouette of the rounded cone depending on view direction, though only two positions are going to fulfill this at any given time. <ref type="figure" target="#fig_2">Fig. 4</ref> shows a view configuration for which p 0 and p 3 are the delimiting positions of the silhouette. Due to the way v 0 is defined, p 0 is always located to the left of p 1 in image space. The same applies to p 2 and p 3 . Using this property we can determine the leftmost position of the cones projection by choosing between p 0 and p 2 and the rightmost position is given by either p 1 or p 3 . To chose p 0 over p 2 or vice versa we have to compare their distance to the cone center in image-space and choose the point with the largest distance. This is achieved by first generating a direction orthogonal to u and the camera view direction v via w =û ×v.</p><p>Then the scalar product is used to calculate the angles between p 0 and p 2 , as seen from the view point e, and w:</p><formula xml:id="formula_6">α 0,2 = p 0,2 − e p 0,2 − e , w w .<label>(7)</label></formula><p>By comparing both angles we can find the position of the leftmost point on the rounded cone silhouette and the corresponding radius with</p><formula xml:id="formula_7">(p s , r s ) = (p 0 , r 0 ), if α 0 ≤ α 2 (p 2 , r 1 ), otherwise .<label>(8)</label></formula><p>The same procedure is applied for p 1 and p 3 by calculating the angles α 1 and α 3 using Equation 7. The rightmost silhouette position p e and the corresponding radius r e are the determined via</p><formula xml:id="formula_8">(p e , r e ) = (p 3 , r 1 ), if α 1 ≤ α 3 (p 1 , r 0 ), otherwise .<label>(9)</label></formula><p>The corner positions for the image-space bounding box of the rounded cone are calculated as</p><formula xml:id="formula_9">c 0 = p s − r s •û, c 1 = p s + r s •û, c 2 = p e − r e •û, c 3 = p e + r e •û.<label>(10)</label></formula><p>As noted at the beginning of this section, this procedure works for rounded cones satisfying r 0 ≤ r 1 . To generalize the approach to arbitrary start and end radii, only requires to swap x 0 and x 1 as well as their radii.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Ray Intersection</head><p>After generating the view ray in the fragment shader the intersection with the rounded cone primitive needs to be determined. As the rounded cone is built from a truncated cone fitted with spherical caps, finding the intersection point of the combined primitive can be accomplished by testing against the simpler individual primitives. The final intersection can then be determined through a constructive solid geometry approach. Analytic formulations for ray-sphere and ray-cone intersections are well defined. This leaves the parameters for the truncated cone to be determined, such that the surface touches the spheres tangentially. The process is detailed in Han et al. <ref type="bibr" target="#b16">[17]</ref>. We decided on an optimized formulation of this idea, which we found to be optimal for our purposes <ref type="bibr" target="#b32">[33]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Ambient Occlusion</head><p>To incorporate ambient occlusion into the shading process, first a simplified representation of the scene needs to be created. Scene voxelization is done in a preprocessing step before rendering. As we only considered static data sets during our testing, we opted for a slower CPU-based implementation. The voxelized scene is stored in a single floating point component 3D texture of format GL RED. A target resolution is chosen, which specifies the number of grid cells along the dimension with the largest extent of the data set. The other dimensions are chosen to fit the whole data set with uniform voxels along these axes. By using a 3D texture, quadrilinear interpolation by the GPU can be used to blend between successive levels of detail in the voxel cone tracing step.</p><p>Voxelization is done per line segment, by traversing the grid using the algorithm detailed by Amanatides and Woo <ref type="bibr" target="#b1">[2]</ref>. Knowing the entry and exit point of the segment in each grid cell, we can determine the height and, through linear interpolation, the base and top radius of the corresponding truncated cone. The volume of this truncated cone divided by the voxel volume gives the approximate density contribution of each interval of the line segment. The contribution is further scaled by the opacity of the line at each intersection, which is interpolated from the start and end opacity. Density is accumulated at each voxel for all line segment intersections.</p><p>To apply voxel cone tracing similar to <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b41">41]</ref>, a hierarchical structure of the voxel density grid has to be generated. Coarser levels are created with half the resolution of previous levels by averaging density values. For our static test scenes, we decided on using the standard OpenGL function glGenerateMipmaps, as it generates a suitable mipmap-pyramid of the 3D texture, although faster solutions have been used in practice <ref type="bibr" target="#b41">[41]</ref>. Evaluation of the occlusion term is performed by tracing 3 cones tightly aligned around the surface normal. With cone <ref type="figure">6</ref>. Not clipping internal geometry for transparent lines leads to sphere artifacts (top left). By employing the clipping approach as seen in the bottom row, these can be successfully removed (top right).</p><formula xml:id="formula_10">x 1 x 2 x 3 x 0 n 1 n 0 Fig.</formula><p>opening angles ranging from 40 • to 60 • , a good approximation of the surrounding hemisphere can be achieved.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Fixing Overlapping Geometry</head><p>We chose rounded cones as our render primitive to depict line segments, because their spherical caps fill the gaps between two successive segments. This has the drawback of geometry overlapping at the point where two segments are connected, as can be seen in <ref type="figure">Fig. 6</ref>. Removing these overlaps is therefore necessary to give the impression of smoothly connected tubes.</p><p>The process is illustrated in <ref type="figure">Fig. 6</ref>. Let a segment be defined by two positions x 1 to x 2 and x 0 the previous, respectively x 3 the successive position in this line. We define clipping directions for the caps as</p><formula xml:id="formula_11">n 0 = − x 2 − x 0 x 2 − x 0 and n 1 = + x 3 − x 1 x 3 − x 1 .<label>(11)</label></formula><p>Through directions n 0 and n 1 , normals for two clipping planes are defined. These planes are positioned at x 1 and x 2 respectively. When a ray-primitive intersection occurs during rendering, we check if the intersection point lies in between these two planes.</p><p>As clipping the spherical caps is undesirable for segments located at the start and beginning of a line, we have to encode at which points they should be removed. This is done by moving all of the line positions to the positive half of the coordinate system in direction of the x-axis, thus leaving all x-components greater or equal than zero. The sign bit can then be utilized as a flag, indicating if the segment should be clipped at the corresponding position. As access to the adjacent segments is necessary to retrieve their positions, a shader storage buffer object is used to store vertex data -alternatively the GL LINES ADJACENCY primitive type can be used <ref type="bibr" target="#b0">1</ref> . Because we require the indices of successive line segments to be in strictly ascending order with increments of one (see Sect. 4.1), calculating the adjacent vertex indices is trivial. Special care must be taken before using the positional values in any computation, as the encoding has to be removed first by taking the absolute value of the x-component.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">RESULTS AND DISCUSSION</head><p>To test the effectiveness of our method, we created an implementation in C++ using the CGV-Framework <ref type="bibr" target="#b12">[13]</ref> using OpenGL as the graphics API. Our test system was equipped with an Intel Core i9-9900K with 8 × 3.6 GHz, 64 GB RAM and an Nvidia GeForce RTX 2080 Ti with 11 GB VRAM. The RTX feature set was not utilized during the rendering process. All performance measurements were taken at a view port resolution of 1920 × 1080. We averaged the achieved frame time while orbiting the view point around the data set center for a predefined duration, making one full revolution in that time. Camera parameters were chosen so that each data set fills most of the view port, while filling the whole view port for the additional near performance tests. Scene voxelization was performed with a target resolution of 256 voxels for all data sets, with resulting resolution given in <ref type="table" target="#tab_0">Table 1</ref>. While, for smaller line sets, sufficient quality can be achieved with less resolution, we found this to be optimal in our testings, as a good compromise between memory consumption and detail is given. The difference in performance for other voxel resolutions is negligible. Unless stated otherwise, all measurements for transparent rendering were conducted with k = 4, using in total 64 MB of additional video memory. We used 10 depth slices for all measurements during primitive culling.</p><p>While our evaluation is limited to static data sets, our method is capable of handling animated data as well, as no geometry pre-processing is needed. Sorting is performed every frame on the GPU, effectively defining the depth slices for no additional cost. Our blending is independent of sliced rendering, so that no popping artifacts are produced as a result of primitives shifting between slices. When ambient occlusion is necessary, a faster method can be used, like in <ref type="bibr" target="#b41">[41]</ref> to calculate the density volume interactively for each animation frame.</p><p>Six real world data sets were used to evaluate the rendering performance and accuracy of transparent rendering. They were chosen based on different levels of complexity and data size. The data sets, that can be seen in <ref type="figure">Fig. 1</ref>, are as follows:</p><p>• Propeller: 500 streamlines seeded on a straight line in the velocity field of a rotating ship propeller simulation. Angular velocity is mapped to transparency and cone radius.</p><p>• Brain: 23,419 short DTI fiber tracts generated from a scan of the whole human brain. Color and radius is inversely mapped from the local line density. Transparency is set to a constant value of 50%.</p><p>• Aneurysm: 9213 streamlines, which were randomly seeded in the interior of an aneurysm. Line transparency is derived from the vorticity of the underlying flow field.</p><p>• Convection: 99,605 streamlines, seeded uniformly in a Rayleigh-Bénard convection, simulating a cold top and heated bottom wall <ref type="bibr" target="#b36">[37]</ref>. Transparency is mapped from line curvature.</p><p>• Turbulence: 80,000 long streamlines, filling the complete simulation domain. Streamlines were generated in a forced turbulence field as with a resolution of 1024 <ref type="bibr" target="#b2">3</ref> . The process is described by Aluie et al. <ref type="bibr" target="#b0">[1]</ref>.</p><p>• Clouds: 400,000 seeded streamlines from a large eddy simulation (LES) of a cloud resolving boundary layer <ref type="bibr" target="#b42">[42]</ref>. Transparency is derived from the magnitude of vorticity along each streamline.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Performance Analysis</head><p>Given the fact that our method to resolve transparency requires objects being rendered in visibility order, we need to sort the segments of each data set during rendering. The duration of one full sorting run, using our GPU implementation, depends on the number of segments in a data set and is given in <ref type="table" target="#tab_0">Table 1</ref>, along with the number of segments. As our method is not only applicable for transparent visualizations, we measured performance for fully opaque renderings to get insight about the influence of culling primitives and the impact of evaluating ambient occlusion. <ref type="table" target="#tab_1">Table 2</ref> (top) lists average render times in ms for an animation around the data sets, as described at the beginning of this section. In addition, a closeup test has been conducted. As stated in Sect. 4.3, sorting the segments while culling is active is only performed on large view changes, which results in 10 sorts for the used camera animation. For all data sets except Propeller, increased render speed can be measured, when applying the culling scheme presented in Sect. 4.3.</p><p>The Propeller data set is sparsely populated and does not suffer from large amounts of occlusion, hence the extra calculations needed for the maximum-depth mipmap produce too much overhead, compared to the low number of culled primitives. Performance is increased by up to a factor of 2.8 (see Aneurysm D and E in <ref type="table" target="#tab_1">Table 2</ref>) for the other data sets. We note, that the culling scheme is most applicable for dense and cube-like shaped data sets, while still delivering increased effectiveness in closeup exploration. Shading the opaque rendered geometry is deferred to a second render pass. This drastically reduces the amount of fragments, for which ambient occlusion needs to be determined. Evidence of the effectiveness can be seen in <ref type="table" target="#tab_1">Table 2</ref> (top).</p><p>The evaluation of the ambient occlusion term reduces performance only by about 3.3% on average and has less impact on larger data sets, as most of the geometry is occluded. The same measurements were performed for the transparent rendering case, with the results being shown in <ref type="table" target="#tab_1">Table 2</ref> (bottom). Performance is overall reduced, which is to be expected. The measured times include the run time of the sorting step for each frame. Our implementation achieved interactive frame rates for every data set except Clouds. Similar to the opaque rendering, our culling scheme proves helpful in increasing performance when data sets are densely sampled, as can be seen in Turbulence and Clouds data sets. However, with the addition of transparency there is another factor which influences the effectiveness of culling. This is especially noticeable on the Aneurysm, where large portions of the lines are very transparent with only small opaque features. In this scenario the accumulated opacity does not surpass the culling threshold and therefore only little geometry is culled, resulting in similar performance compared to rendering without culling. In contrast to opaque rendering, evaluating the ambient occlusion term has a larger impact on performance, because it needs to be calculated for every produced fragment, slowing down render time on average by 24%.</p><p>The accuracy of our approach can be controlled by the choice of parameter k, which determines the intermediate fragment list size for each pixel. This not only influences memory consumption but also render times. Measurements for different values of k on three selected data sets are shown in <ref type="table">Table 3</ref>. We give render times with and, to isolate the impact of k on render times, without culling. Frame times increase for larger values of k, while the effect is less pronounced when culling is enabled. This is especially visible for dense data sets with moderate transparency with a potentially large amount of occlusion.</p><p>To give an overview of the performance of our method in the context of line rendering, we compared it to two recently presented techniques -Multi-Layer Alpha Blending with Dept Bucketing (MLABDB) from <ref type="bibr" target="#b18">[19]</ref> and Voxel-based Ray Casting (VRC) <ref type="bibr" target="#b17">[18]</ref>. We adopted an implementation of both approaches <ref type="bibr" target="#b30">[31]</ref> to our needs to enable comparison with our method. Transfer functions and line radius for each data set were chosen to be identical across all implementations. Measured times, given in <ref type="table" target="#tab_2">Table 4</ref>, show the average duration in ms to render one frame, averaged over a mixture of far and near camera movements. While we intend our method to be used with culling enabled, we have also given results without culling. These timings are independent of the used transfer function and represent worst case performances for highly transparent data sets. The results show that no method is clearly superior over the others. MLABDB is, like our method, highly dependent on overall fragment count, with frame times being higher for the larger data sets. The performance of VRC is heavily determined by the view port resolution and voxel grid resolution. VRC performs worst on the Aneuryms data set, partly due to the high grid resolution compared to data detail. The other factor is the highly transparent transfer function used during testing, which prevents early ray termination and therefore requires more computation. Similar, our method achieved the least speedup when enabling culling. The impact of culling was most noticeable on the Turbulence data set, where the performance of our implementation even surpassed VRC. For the Convection data set VRC produced the fastest render times, as the grid resolution is rather small in one dimension. However, this comes at the cost of decreased line accuracy.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Qualitative Analysis</head><p>To evaluate the quality of renderings produced with our approach, we again compared it to MLABDB, VRC and a ground thruth solution acquired from DP, with results being shown in <ref type="figure">Fig. 7</ref>. Overall the results appear very similar with each method giving an adequate impression of transparency. Zoomed in views for regions of interest reveal differences and shortcomings of each approach. The green region of <ref type="figure">Fig. 7</ref> shows small imperfections of our approach compared to the ground truth solution. In comparison, MLABDB looks slightly blurry, however, all methods achieve good results. A zoomed in view of opaque features being covered by layers of transparent lines is shown in the blue region. Our method and VRC are very similar to the ground truth producing correct results for transparency. The result from MLABDB shows some of the opaque features more pronounced due to the approximate blending approach. Additionally, possibly as a result of the color compression, MLABDB produces a slight shift in color compared to the original transfer function. VRC delivers overall correct transparency but sacrifices line quality, which is a direct result of the discretization  into a voxel grid. Our approach is superior in line accuracy and quality, although this comes at the cost of longer render times. An application of using a differing tube radius can be seen in <ref type="figure">Fig. 9</ref>.</p><p>Comparing our approach to the ground truth solution shows its effectiveness in restoring the correct fragment order. Overall a correct impression of the transparent layers is accomplished. Unwanted blending of internal geometry to outside layers cannot be observed and transparent layers are well defined without blurry edges. We attribute this to not using an approximate blending scheme to combine fragments. Upon further inspection minor artifacts can be seen in <ref type="figure">Fig. 7</ref> (green square). While this is almost imperceptible in the final image, it shows a shortcoming of our approach which we further investigate.</p><p>Limitations of our intermediate sorting strategy can be seen in <ref type="figure">Fig. 8</ref>. We compare our method to a ground truth solution rendered with DP for densely sampled lines, that interpenetrate a lot in the Brain stem region, showing artifacts arising due to fragments being blended in wrong order. As reference, <ref type="figure">Fig. 8 (left)</ref> shows the result of blending purely based on object order, to illustrate the kind of local errors our method needs to resolve. With the used buffer size of k = 4 our method was not able to sort all fragments to their correct visibility order in this challenging example. Compared to other approaches using approximate blending methods <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b25">26,</ref><ref type="bibr" target="#b34">35,</ref><ref type="bibr" target="#b35">36]</ref>, which tend to blur out features or produce wrong transparency and color impression, our method produces sharp, more pronounced artifacts when unable to sort all fragments correctly, yet produces correct results in most cases. When orbiting the view these artifacts can suddenly appear or disappear, as primitives change their order -although this is barely noticeable on typical viewing distances. Effectively a buffer of size k can restore order for all fragments not more than k layers away from the correct sorting position. With lines packed too close this cannot be guaranteed for every pixel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSION AND FUTURE WORK</head><p>In this work we introduced a method for interactive visualization of 3D line data sets with up to millions of segments, incorporating ambient occlusion and applying a novel approach to transparent rendering. We build our approach on GPU-based ray casting using optimized billboards. The rounded cone primitive allows for smooth connections between successive line segments and a simple culling method to remove overlapping internal structures in transparent rendering. Using GPU-based ray casting to draw the rounded cones allows for high image quality independent of zoom level. Transparency based on object order with intermediate fragment sorting produces correct results for lines with limited overlap.</p><p>Limitations of our approach are noticeable on densely packed lines, where a larger buffer size k is necessary to achieve correct visibility order. The need for explicit sorting introduces overhead, which is more noticeable on large data sets. By employing our culling scheme we can gain back performance lost to sorting. Culling has proven especially helpful for opaque rendering.</p><p>For future work we will focus on substituting rounded cones with other primitives, like generalized cylinders following quadratic bézier splines. We will investigate if this can be used to resample lines, reducing the number of segments and providing smoother curvature along the line. Additionally we are interested in incorporating more advanced lighting effects into the rendering, as well as defining a volumetric density model for the tubes to improve 3D perception. <ref type="figure">Fig. 9</ref>. Visualization of the Convection data set, with curvature inversely mapped to radius. Thinner tubes help to discern details in the dense regions, while the thicker transparent lines provide context.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>Schematic illustration of the rendering procedure of our transparent rendering approach.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Illustration of the indexing scheme used in our implementation. Vertex indices are given in black and segment indices in white.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 4 .</head><label>4</label><figDesc>For opaque rendering a lot of Top view of the rounded cone showing the projection of points p 0 to p 3 and support directions. Bottom right shows the projection of a sphere silhouette to determine the corrected radius r 0 on the example of the start cap sphere.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 5 .</head><label>5</label><figDesc>Illustration of the rounded cone billboard as viewed from the camera perspective.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 7 .Fig. 8 .</head><label>78</label><figDesc>Comparison of different transparency rendering methods for lines on the Turbulence, with zoomed in views for regions of interest. From left to right: Ground truth from DP, our method, MLABDB, VRC. Due to small differences in local lighting our renderings appear slightly darker. Comparison between transparency based purely on object order (left), our method using k = 4 (middle) and a ground truth solution rendered with DP (right). A list size of 4 is not sufficient to fully resolve the wrong fragment order on highly overlapping tubes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>The data sets used for evaluation, listed with their respective segment count and voxel grid resolution. Given in the last column are timings for the visibility sorting of the segments in ms.</figDesc><table><row><cell>data set</cell><cell cols="3"># segments voxel resolution sorting time</cell></row><row><cell>Propeller</cell><cell>121,840</cell><cell>256 x 64 x 64</cell><cell>0.23</cell></row><row><cell>Brain</cell><cell>1,118,841</cell><cell>214 x 223 x 256</cell><cell>1.19</cell></row><row><cell>Aneurysm</cell><cell>2,267,219</cell><cell>226 x 221 x 256</cell><cell>2.28</cell></row><row><cell>Convection</cell><cell>9,859,794</cell><cell>256 x 256 x 14</cell><cell>9.13</cell></row><row><cell>Turbulence</cell><cell>17,468,339</cell><cell>256 x 256 x 256</cell><cell>15.28</cell></row><row><cell>Clouds</cell><cell>39,600,000</cell><cell>256 x 91 x 256</cell><cell>34.95</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 .</head><label>2</label><figDesc>Measured render time in ms for opaque (top) and transparent (bottom) rendering at two different zoom levels A: far, B: far with culling, C: far with culling and ambient occlusion, D: near, E: near with culling, F : near with culling and ambient occlusionTable 3. Render times in ms compared between different values for the fragment list size k when culling is applied (first) and without culling (second).</figDesc><table><row><cell>data set</cell><cell>A</cell><cell>B</cell><cell>C</cell><cell>D</cell><cell>E</cell><cell>F</cell></row><row><cell>Propel1er</cell><cell>1.2</cell><cell>2.1</cell><cell>2.3</cell><cell>1.8</cell><cell>2.7</cell><cell>2.8</cell></row><row><cell>Brain</cell><cell>6.3</cell><cell>3.8</cell><cell>4.1</cell><cell>14.8</cell><cell>6.5</cell><cell>6.7</cell></row><row><cell>Aneurysm</cell><cell>10.2</cell><cell>4.7</cell><cell>4.9</cell><cell>24.2</cell><cell>8.6</cell><cell>8.9</cell></row><row><cell>Convection</cell><cell>17.1</cell><cell>14.8</cell><cell>14.9</cell><cell>15.5</cell><cell>15.1</cell><cell>15.4</cell></row><row><cell>Turbulence</cell><cell>45.6</cell><cell>20.7</cell><cell>21.1</cell><cell>52.3</cell><cell>26.3</cell><cell>26.8</cell></row><row><cell>Clouds</cell><cell>60.3</cell><cell>37.1</cell><cell>37.7</cell><cell>90.2</cell><cell>41.7</cell><cell>42.3</cell></row><row><cell>Propel1er</cell><cell>4.6</cell><cell>5.7</cell><cell>6.6</cell><cell>4.8</cell><cell>6.3</cell><cell>7.4</cell></row><row><cell>Brain</cell><cell>14.9</cell><cell>12.3</cell><cell>17.9</cell><cell>26.8</cell><cell>13.2</cell><cell>19.6</cell></row><row><cell>Aneurysm</cell><cell>24.1</cell><cell>24.0</cell><cell>36.6</cell><cell>44.9</cell><cell>42.5</cell><cell>67.5</cell></row><row><cell>Convection</cell><cell>62.9</cell><cell>58.8</cell><cell>86.1</cell><cell>43.1</cell><cell>38.9</cell><cell>50.0</cell></row><row><cell>Turbulence</cell><cell>144.9</cell><cell>93.7</cell><cell>141.4</cell><cell>120.7</cell><cell>69.1</cell><cell>93.9</cell></row><row><cell>Clouds</cell><cell>3229.0</cell><cell>1442.8</cell><cell>1463.1</cell><cell cols="3">1974.1 540.6 573.0</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 4 .</head><label>4</label><figDesc>Performance comparison between MLABDB, VRC and our method on 4 chosen data sets. Frame time is given in ms.</figDesc><table><row><cell>data set</cell><cell>MLABDB</cell><cell>VRC</cell><cell cols="2">ours ours + culling</cell></row><row><cell>Aneurysm</cell><cell>23.0</cell><cell>98.3</cell><cell>29.5</cell><cell>27.8</cell></row><row><cell>Convection</cell><cell>37.9</cell><cell>16.9</cell><cell>72.4</cell><cell>46.6</cell></row><row><cell>Turbulence</cell><cell>117.5</cell><cell>97.3</cell><cell>131.3</cell><cell>82.7</cell></row><row><cell>Clouds</cell><cell cols="3">225.9 118.6 2460.3</cell><cell>910.6</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">This requires to specify indices of adjacent vertices in the index buffer.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>This work has received funding from DFG though TRR 248 (grant 389792660) and the two Clusters of Excellence CeTI (EXC2050/1 grant 390696704) and PoL (EXC2068 grant 390729961).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Forced MHD turbulence data set</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Aluie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Eyink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><forename type="middle">E</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">C K</forename><surname>Kanov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Burns</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Meneveau</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Szalay</surname></persName>
		</author>
		<ptr target="http://turbulence.pha.jhu.edu/docs/README-MHD.pdf" />
		<imprint>
			<date type="published" when="2020-04" />
			<biblScope unit="page">20</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A fast voxel traversal algorithm for ray tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Amanatides</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Woo</surname></persName>
		</author>
		<idno type="DOI">10.2312/egtp.19871000</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of Eurographics Conference on Technical Papers. Eurographics Association</title>
		<meeting>of Eurographics Conference on Technical Papers. Eurographics Association</meeting>
		<imprint>
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Multi-fragment effects on the GPU using the k-buffer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bavoil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>Callahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lefohn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A L D</forename><surname>Comba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
		<idno type="DOI">10.1145/1230100.1230117</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. Symp. Interactive 3D Graph. and Games</title>
		<meeting>Symp. Interactive 3D Graph. and Games<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2007" />
			<biblScope unit="page" from="97" to="104" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The a-buffer, an antialiased hidden surface method. SIG-GRAPH</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Carpenter</surname></persName>
		</author>
		<idno type="DOI">10.1145/964965.808585</idno>
	</analytic>
	<monogr>
		<title level="j">Comput. Graph</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="103" to="108" />
			<date type="published" when="1984-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Interactive indirect illumination using voxel cone tracing: A preview</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Crassin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Neyret</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sainz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Green</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Eisemann</surname></persName>
		</author>
		<idno type="DOI">10.1145/1944745.1944787</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. Symp. Interactive 3D Graph. and Games</title>
		<meeting>Symp. Interactive 3D Graph. and Games<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page">207</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">LineAO -improved three-dimensional line rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Eichelbaum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hlawitschka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Scheuermann</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2012.142</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="433" to="445" />
			<date type="published" when="2013-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Stochastic transparency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Enderton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Sintorn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Luebke</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2010.123</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="1036" to="1047" />
			<date type="published" when="2011-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Interactive order-independent transparency. NVIDIA Corporation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Everitt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2001-10" />
			<biblScope unit="volume">2</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Depthdependent halos: Illustrative rendering of dense line data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Everts</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Bekker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B T M</forename><surname>Roerdink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Isenberg</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2009.138</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1299" to="1306" />
			<date type="published" when="2009-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Interactive illustrative line styles and line style transfer functions for flow visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Everts</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Bekker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B T M</forename><surname>Roerdink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Isenberg</surname></persName>
		</author>
		<idno>abs/1503.05787</idno>
		<imprint>
			<date type="published" when="2015-03" />
			<publisher>CoRR</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Interactive GPU-based Visualization of Large Dynamic Particle Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Falk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Grottel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Krone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Reina</surname></persName>
		</author>
		<idno type="DOI">10.2200/S00731ED1V01Y201608VIS008</idno>
		<imprint>
			<date type="published" when="2016" />
			<publisher>Morgan and Claypool</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Coherent culling and shading for large molecular dynamics visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Grottel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Reina</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Dachsbacher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
		<idno type="DOI">10.1111/j.1467-8659.2009.01698.x</idno>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">29</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="953" to="962" />
			<date type="published" when="2010-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<monogr>
		<title level="m" type="main">The computer graphics and visualization framework</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gumhold</surname></persName>
		</author>
		<ptr target="https://github.com/sgumhold/cgv" />
		<imprint>
			<date type="published" when="2020-04" />
			<biblScope unit="page">20</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Splatting illuminated ellipsoids with depth correction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gumhold</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VMV</title>
		<editor>T. Ertl</editor>
		<meeting>VMV</meeting>
		<imprint>
			<date type="published" when="2003-11" />
			<biblScope unit="page" from="245" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Opacity optimization for 3d line fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Günther</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Rössl</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Theisel</surname></persName>
		</author>
		<idno type="DOI">10.1145/2461912.2461930</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. Graph</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="2013-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Fast four-way parallel radix sorting on GPUs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">K</forename><surname>Ha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">H</forename><surname>Krüger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Silva</surname></persName>
		</author>
		<idno>doi: 10. 1111/j.1467-8659.2009.01542.x</idno>
	</analytic>
	<monogr>
		<title level="j">Comput. Graph. Forum</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="2368" to="2378" />
			<date type="published" when="2009-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Ray tracing generalized tube primitives: Method and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Wald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Usher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Q</forename><surname>Wu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
		<idno type="DOI">10.1111/cgf.13703</idno>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="467" to="478" />
			<date type="published" when="2019-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A voxel-based rendering pipeline for large 3D line sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kanzler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Rautenhaus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2018.2834372</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="2378" to="2391" />
			<date type="published" when="2019-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">A comparison of rendering techniques for 3D line sets with transparency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kern</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Neuhauser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Maack</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Han</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Usher</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2020.2975795</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="page" from="1" to="1" />
			<date type="published" when="2020-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">ARB fragment shader interlock</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Khronos</forename><surname>Group</surname></persName>
		</author>
		<ptr target="https://www.khronos.org/registry/OpenGL/extensions/ARB/ARB_fragment_shader_interlock.txt" />
		<imprint>
			<date type="published" when="2020-04" />
			<biblScope unit="page">15</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Illustrating magnetic field lines using a discrete particle model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. VMV</title>
		<meeting>VMV<address><addrLine>Aka GmbH</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="387" to="394" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Trajectory density projection for vector field visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kuhn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Lindow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Günther</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Wiebel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Theisel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-C</forename><surname>Hege</surname></persName>
		</author>
		<idno type="DOI">10.2312/PE.EuroVisShort.EuroVis-Short2013.031-035</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. EuroVis -Short Papers. The Eurographics Association</title>
		<editor>M. Hlawitschka and T. Weinkauf</editor>
		<meeting>EuroVis -Short Papers. The Eurographics Association</meeting>
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">FreePipe: A programmable parallel rendering architecture for efficient multi-fragment effects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M.-C</forename><surname>Huang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X.-H</forename><surname>Liu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E.-H</forename><surname>Wu</surname></persName>
		</author>
		<idno type="DOI">10.1145/1730804.1730817</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. Symp. on Interactive 3D Graph. and Games</title>
		<meeting>Symp. on Interactive 3D Graph. and Games<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2010" />
			<biblScope unit="page" from="75" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Illuminated lines revisited</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Mallo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Peikert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sigg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Sadlo</surname></persName>
		</author>
		<idno type="DOI">10.1109/VISUAL.2005.1532772</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="19" to="26" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">Association for Computing Machinery</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Maule</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Comba</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Torchelsen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Bastos</surname></persName>
		</author>
		<idno>doi: 10. 1145/2448196.2448212</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. Symp. on Interactive 3D Graph. and Games</title>
		<meeting>Symp. on Interactive 3D Graph. and Games<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2013" />
			<biblScope unit="page" from="103" to="118" />
		</imprint>
	</monogr>
	<note>Hybrid transparency</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Weighted blended order-independent transparency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mcguire</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bavoil</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Computer Graphics Techniques (JCGT)</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="122" to="141" />
			<date type="published" when="2013-12" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Phenomenological transparency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mcguire</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Mara</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2017.2656082</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1465" to="1478" />
			<date type="published" when="2017-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Hybrid visualization for white matter tracts using triangle strips and point sprites</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Merhof</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Sonntag</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Enders</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Nimsky</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hastreiter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Greiner</surname></persName>
		</author>
		<idno type="DOI">10.1109/TVCG.2006.151</idno>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="1181" to="1188" />
			<date type="published" when="2006-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">On perception of semi-transparent streamlines for three-dimensional flow visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Mishchenko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
		<idno type="DOI">10.1111/cgf.12268</idno>
	</analytic>
	<monogr>
		<title level="j">Comput. Graph. Forum</title>
		<imprint>
			<biblScope unit="volume">33</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="210" to="221" />
			<date type="published" when="2014-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b29">
	<analytic>
		<title level="a" type="main">Moment-based order-independent transparency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Münstermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Krumpen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Klein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Peters</surname></persName>
		</author>
		<idno type="DOI">10.1145/3203206</idno>
	</analytic>
	<monogr>
		<title level="j">Proc. ACM Comput. Graph. Interact. Tech</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<date type="published" when="2018-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b30">
	<monogr>
		<title level="m" type="main">OIT rendering tool (PixelSyncOIT)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Neuhauser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kern</surname></persName>
		</author>
		<ptr target="https://github.com/chrismile/PixelSyncOIT" />
		<imprint>
			<date type="published" when="2020-04" />
			<biblScope unit="page">14</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b31">
	<monogr>
		<ptr target="https://www.khronos.org/registry/OpenGL/extensions/NV/NV_shader_atomic_int64.txt" />
		<title level="m">NVIDIA Corporation. NV shader atomic int64</title>
		<imprint>
			<date type="published" when="2020-04" />
			<biblScope unit="page">16</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b32">
	<monogr>
		<title level="m" type="main">Ray-rounded-cone intersection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Quilez</surname></persName>
		</author>
		<ptr target="https://www.shadertoy.com/view/MlKfzm" />
		<imprint>
			<date type="published" when="2020-04" />
			<biblScope unit="page">22</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b33">
	<monogr>
		<title level="m" type="main">Visualization of uncorrelated point data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Reina</surname></persName>
		</author>
		<idno type="DOI">10.18419/opus-2649</idno>
		<imprint>
			<date type="published" when="2009-01" />
		</imprint>
		<respStmt>
			<orgName>University Stuttgart</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b34">
	<analytic>
		<title level="a" type="main">Adaptive transparency</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Salvi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Montgomery</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Lefohn</surname></persName>
		</author>
		<idno type="DOI">10.1145/2018323.2018342</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of the ACM SIGGRAPH Symp. on HPG</title>
		<meeting>of the ACM SIGGRAPH Symp. on HPG<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="119" to="126" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b35">
	<analytic>
		<title level="a" type="main">Multi-layer alpha blending</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Salvi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Vaidyanathan</surname></persName>
		</author>
		<idno type="DOI">10.1145/2556700.2556705</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. Symp. Interactive 3D Graph. and Games</title>
		<meeting>Symp. Interactive 3D Graph. and Games<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="151" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b36">
	<analytic>
		<title level="a" type="main">Resolving the finescale structure in turbulent Rayleigh-Bénard convection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Scheel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">S</forename><surname>Emran</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Schumacher</surname></persName>
		</author>
		<idno type="DOI">10.1088/1367-2630/15/11/113063</idno>
	</analytic>
	<monogr>
		<title level="j">New Journal of Physics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page">113063</biblScope>
			<date type="published" when="2013-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b37">
	<analytic>
		<title level="a" type="main">Efficient visualization of large amounts of particle trajectories in virtual environments using virtual tubelets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schirski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kuhlen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hopp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Adomeit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Pischinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bischof</surname></persName>
		</author>
		<idno type="DOI">10.1145/1044588.1044615</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. ACM SIGGRAPH Int. Conf. VRCAI</title>
		<meeting>ACM SIGGRAPH Int. Conf. VRCAI<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2004" />
			<biblScope unit="page" from="141" to="147" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b38">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Schussman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b39">
	<analytic>
		<title level="a" type="main">Anisotropic volume rendering for extremely dense, thin line data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ma</surname></persName>
		</author>
		<idno type="DOI">10.1109/VISUAL.2004.5</idno>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="107" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b40">
	<analytic>
		<title level="a" type="main">GPU-based ray-casting of quadratic surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Sigg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Weyrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Botsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gross</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Eurographics / IEEE VGTC Conference on Point-Based Graphics</title>
		<meeting>Eurographics / IEEE VGTC Conference on Point-Based Graphics<address><addrLine>Goslar, DEU</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="59" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b41">
	<analytic>
		<title level="a" type="main">Visualization of particle-based data with transparency and ambient occlusion</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Staib</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Grottel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gumhold</surname></persName>
		</author>
		<idno type="DOI">10.1111/cgf.12627</idno>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="151" to="160" />
			<date type="published" when="2015-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b42">
	<monogr>
		<title level="m" type="main">Introduction to UCLA-LES</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Stevens</surname></persName>
		</author>
		<ptr target="https://www.mpimet.mpg.de/fileadmin/atmosphaere/herz/les_doc.pdf.Accessed" />
		<imprint>
			<date type="published" when="2020-07-18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b43">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Stoll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Gumhold</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b44">
	<analytic>
		<title level="a" type="main">Visualization with stylized line primitives</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Seidel</surname></persName>
		</author>
		<idno>doi: 10. 1109/VISUAL.2005.1532859</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="695" to="702" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b45">
	<analytic>
		<title level="a" type="main">Voxel-based global illumination</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Thiedemann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Henrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Grosch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Müller</surname></persName>
		</author>
		<idno type="DOI">10.1145/1944745.1944763</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. Symp. Interactive 3D Graph. and Games</title>
		<meeting>Symp. Interactive 3D Graph. and Games<address><addrLine>New York, NY, USA</addrLine></address></meeting>
		<imprint>
			<publisher>Association for Computing Machinery</publisher>
			<date type="published" when="2011" />
			<biblScope unit="page" from="103" to="110" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b46">
	<analytic>
		<title level="a" type="main">Visualization of industrial structures with implicit GPU primitives</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Toledo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Levy</surname></persName>
		</author>
		<idno type="DOI">10.1007/978-3-540-89639</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. Symp. Advances in Visual Computing</title>
		<meeting>Symp. Advances in Visual Computing<address><addrLine>Berlin, Heidelberg</addrLine></address></meeting>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2008" />
			<biblScope unit="volume">5358</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b47">
	<analytic>
		<title level="a" type="main">Real-time concurrent linked list construction on the GPU</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">C</forename><surname>Yang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hensley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Grün</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Thibieroz</surname></persName>
		</author>
		<idno type="DOI">10.1111/j.1467-8659.2010.01725.x</idno>
	</analytic>
	<monogr>
		<title level="m">Proc. of the 21st Eurographics Conference on Rendering EGSR</title>
		<meeting>of the 21st Eurographics Conference on Rendering EGSR<address><addrLine>Goslar, DEU</addrLine></address></meeting>
		<imprint>
			<date type="published" when="2010" />
			<biblScope unit="page" from="1297" to="1304" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b48">
	<analytic>
		<title level="a" type="main">GPU ray casting method for visualizing 3D pipelines in a virtual globe</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Zhaocong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Shao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Deng</surname></persName>
		</author>
		<idno type="DOI">10.1080/17538947.2018.1429504</idno>
	</analytic>
	<monogr>
		<title level="j">International Journal of Digital Earth</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="page" from="1" to="14" />
			<date type="published" when="2018-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b49">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zockler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Stalling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b50">
	<analytic>
		<title level="a" type="main">Interactive visualization of 3D-vector fields using illuminated stream lines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hege</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="1996" />
			<biblScope unit="page" from="107" to="113" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
