<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Stable Treemaps via Local Moves</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Max</forename><surname>Sondag</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bettina</forename><surname>Speckmann</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kevin</forename><surname>Verbeek</surname></persName>
						</author>
						<title level="a" type="main">Stable Treemaps via Local Moves</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
					<idno type="DOI">10.1109/TVCG.2017.2745140</idno>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T19:18+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Treemap</term>
					<term>Stability</term>
					<term>Local Moves</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Fig. 1. A non-sliceable treemap (a treemap that cannot be recursively sliced into two parts) over time. In each image the weights of the underlying data have changed. To maintain a balance between aspect ratio and stability we modify the treemap via local moves. Symbols (squares, circles, and triangles) mark the pairs of rectangles to which local moves are applied.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Treemaps are a well-known and popular tool to visualize hierarchical data. The input for a treemapping algorithm is a set of n data values a1, . . . , an a hierarchy upon these values (the tree), and a shape, most commonly a rectangle R. The data value associated with each interior node in the tree must correspond exactly to the sum of the data values of its children (the values a1, . . . , an correspond to the leaves of the tree). The output of a treemapping algorithm is a recursive partition of the input shape into disjoint regions such that (a) the size of each region corresponds to its data value, and (b) the regions of the children of an interior node in the tree form a partition of the region of their parent. By definition, treemaps make very efficient use of space.</p><p>The vast majority of treemapping algorithms uses rectangles and also this paper focusses exclusively on rectangular treemaps. The visual quality of rectangular treemaps is most commonly measured via the aspect ratio of its rectangles. Shneiderman <ref type="bibr" target="#b12">[13]</ref> introduced the first treemapping algorithm ("Slice-and-Dice") in 1991. Despite its popularity it quickly became apparent that Slice-and-Dice was producing rectangles of high aspect ratio and hence poor visual quality. Squarified treemaps by Bruls, Huizing and Van Wijk <ref type="bibr" target="#b2">[3]</ref> aimed to ameliorate this fact using a heuristic approach. From a theoretical point of view the aspect ratio of treemaps can become arbitrarily bad: consider a treemap with only two rectangles, one of which has an extremely large area while the other has an extremely small area (and hence necessarily becomes extremely thin). Nevertheless, Nagamochi and Abe <ref type="bibr" target="#b11">[12]</ref>  scribe an algorithm which provably approximates the optimal aspect ratio for a given treemap. Eventually De Berg, Speckmann and Van Der Weele <ref type="bibr" target="#b4">[5]</ref> proved that minimizing the aspect ratio for rectangular treemaps is strongly NP-complete. <ref type="bibr" target="#b0">1</ref> If the input data change, then a second important quality criterion is the stability of the treemap: how much does the treemap change as the data changes. It is clearly desirable that small changes in the data result only in small changes in the treemap. There are a variety of stable treemap algorithms which try to maintain an order on the input data. There are also several related quality metrics which measure how stable a treemap is. We review both in detail in Section 2. All these existing treemap algorithms have two things in common: (i) they recompute the treemap completely when the data changes, and (ii) they use exclusively sliceable layouts for their treemaps.</p><p>Contribution. We present a novel stable treemapping algorithm that has high visual quality. In contrast to previous treemapping algorithms we (i) adapt our treemap via local modification, and (ii) explore the complete space of possible treemap layouts, including non-sliceable layouts (see <ref type="figure">Fig. 1</ref> for an example of the resulting treemaps). We prove that our approach may result in treemaps of higher visual quality and also show experimentally that our algorithm outperforms existing treemapping algorithms on either visual quality and/or stability.</p><p>Definitions and Notation. To describe our contribution in greater detail, we introduce some definitions and notation. First of all, we distinguish single-level treemaps and multi-level treemaps. A single level treemap has no hierarchy, its tree consist only of a root node with n leaves. Multi-level treemaps correspond to trees with interior nodes in addition to the root. A multi-level treemap has a clear recursive structure: the rectangles which correspond to the children of the root form a single-level treemap (a partition of the input rectangle) and each such rectangle in turn serves as the input rectangle for further subdivision according to its children. When studying treemaps it is hence generally sufficient to study single-level treemaps, since all results directly extend to multi-level treemaps; a multi-level treemap can be viewed as multiple nested single level treemaps where the input rectangle of the child is the rectangle determined by the parent. This has the added advantage of removing unnecessary complexity from arguments. For all theoretical parts of this paper (Sections 3-5) we hence mostly consider only single-level treemaps. The experimental evaluation in Section 7 uses also multi-level treemaps, which are constructed recursively according to the algorithm which we describe for single-level treemaps in Section 5. A single-level treemap is a partition of the input rectangle R into a set of n disjoint subrectangles R = {R1, . . . , Rn}, where each rectangle Ri has area ai. Such a partition of rectangles into subrectangles is known as a rectangular layout L, or layout for short. Layouts have been studied in a variety of research areas, including floorplans in architecture and VLSI design and rectangular cartograms in automated cartography. For a layout L, a maximal segment is a maximal contiguous horizontal or vertical line segment contained in the union of the boundaries of rectangles in R. We distinguish between two types of layouts: sliceable layouts and non-sliceable layouts. A layout is sliceable if it can be recursively sliced into two parts along a maximal segment until the layout consists of only a single rectangle. Otherwise the layout is non-sliceable (see <ref type="figure" target="#fig_0">Fig. 2</ref> for an example).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ri</head><p>All treemap algorithms discussed in this paper (with the exception of our stable treemapping algorithm) produce only sliceable layouts. This is obvious for Slice-and-Dice, since slicing cuts are an integral part of the algorithm. Squarified treemaps, all algorithms using strips and spirals, and the Pivot-by-* family all explicitly construct slicing cuts. But also the treemaps created using space-filling curves (Hilbert and Moore) are sliceable: the base of the recursion are four rectangles and every layout with 4 rectangles is sliceable. Organization. Section 2 discusses related work. In Section 3 we first give some additional background on rectangular layouts. We then prove a lower bound on the maximum aspect ratio of sliceable layouts and argue that non-sliceable layouts can achieve a lower aspect ratio. In Section 4 we introduce the local moves which we use to locally modify our treemaps. We then prove that these local moves are powerful enough to explore the complete space of treemap layouts -both sliceable and non-sliceable layouts. In Section 5 we present our stable treemapping algorithm using local moves. In Section 6 we introduce a new measure for stability which arguably captures the relative positions of rectangles better than existing stability measures. Finally in Section 7 we report on extensive experiments comparing our new treemapping algorithm to existing treemapping algorithms, both on single and multi-level treemaps using real-world data. The experiments show that our algorithm outperforms existing algorithms also in practice on either visual quality and/or stability. Our algorithm scores high on stability regardless of whether we use an existing stability measure or our new measure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">RELATED WORK</head><p>Shneiderman and Wattenberg <ref type="bibr" target="#b13">[14]</ref> proposed the first type of treemap that takes stability into account: the ordered treemap. Here an additional order on the treemap rectangles is specified and rectangles that are near each other in this order are attempted to be placed near each other in the treemap. However, as the input data changes there are no guarantees on how close any two rectangles will stay even if they are neighbors in the order. There are several ordered treemap algorithms: the Pivot-by-(Middle, Size and Split-Size) algorithms by Shneiderman and Wattenberg <ref type="bibr" target="#b13">[14]</ref>, the Strip algorithm by Bederson, Shneiderman and Wattenberg <ref type="bibr" target="#b1">[2]</ref>, the Split algorithm by Engdahl <ref type="bibr" target="#b5">[6]</ref>, the Spiral algorithm by Tu and Shen <ref type="bibr" target="#b15">[16]</ref>, and the Hilbert and Moore algorithms by Tak and Cockburn <ref type="bibr" target="#b14">[15]</ref>.</p><p>To measure the success of maintaining the order underlying ordered treemaps, Bederson et al. <ref type="bibr" target="#b1">[2]</ref> introduced the readability metric. The readability metric measures how often the motion of the reader's eye changes direction as the treemap is scanned in order. In addition, Tu and Shen <ref type="bibr" target="#b15">[16]</ref> introduced the continuity metric which measures how often the next item in the order is not the neighbor of the current item. Both these metrics attempt to quantify how easy it is to visually scan an ordered treemap to find a particular item.</p><p>To measure the stability of treemaps, Shneiderman and Wattenberg <ref type="bibr" target="#b13">[14]</ref> proposed the layout-distance-change function. There are three variations of this function. The first is the variance-distancechange function by Tak and Cockburn <ref type="bibr" target="#b14">[15]</ref>. The second variant, also by Tak and Cockburn <ref type="bibr" target="#b14">[15]</ref>, is locational-drift, which measures the stability over a larger period of time. The final variant, proposed by Hahn et al. <ref type="bibr" target="#b9">[10]</ref>, measures the stability of non-rectangular treemaps using the distance between centroids of regions. Very recently Hahn et al. <ref type="bibr" target="#b8">[9]</ref> proposed to use relative-direction-change, which measures the change in rotation between rectangles. This last measure is related to our proposed stability measure since it incorporates the relative positions of regions. However, we believe that our measure captures the relative position of specifically rectangles better. In Section 6 we discuss stability measures in more detail.</p><p>Not all treemaps use rectangles. Alternative models include Voronoi treemaps by Balzer, Deussen, and Lewerentz <ref type="bibr" target="#b0">[1]</ref>, orthoconvex and L-shaped treemaps by De Berg et al. <ref type="bibr" target="#b4">[5]</ref>, and Jigsaw treemaps by Wattenberg <ref type="bibr" target="#b17">[18]</ref>. Furthermore, Hahn et al. <ref type="bibr" target="#b9">[10]</ref> describe an approach for stable Voronoi treemaps.</p><p>As mentioned before, rectangular layouts are studied in a variety of research areas. Of particular interest here are several results from VLSI design. In this context two rectangular layouts are considered equivalent if each rectangle has the same adjacencies in both layouts, that is, if the two layouts have the same dual graph. The question then arises how many non-equivalent layouts exist that consist of exactly n rectangles. Yao et al. <ref type="bibr" target="#b18">[19]</ref> showed how to represent rectangular layouts with so-called twin binary tree sequences. Using these twin binary tree sequences they proved that the number of non-equivalent sliceable layouts equals the Baxter number <ref type="bibr" target="#b3">[4]</ref> and that the number of nonequivalent non-sliceable layouts equals the Schröder number <ref type="bibr" target="#b7">[8]</ref>. Using the same representation by twin binary tree sequences, Young, Chu, and Shen <ref type="bibr" target="#b19">[20]</ref> showed how to transform any two rectangular layouts into each other using local modifications. Our local moves are inspired by their method. We show in Section 4 how to define simple moves directly on a treemap (and hence avoiding the somewhat involved twin binary trees) to achieve the same result, namely a sequence of simple modifications which transforms any two treemaps into each other.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">LAYOUTS</head><p>For a given set of areas a1, . . . , an there are multiple ways to draw a treemap, that is, there are multiple layouts that can represent the same set of areas. We want to find the layout that has the highest visual quality, that is, the layout that minimizes the aspect ratios of its rectangles. To do so we need to explore the space of possible layouts. As stated above, all current rectangular treemapping algorithms produce only sliceable layouts. In this section we prove that the quality of treemaps can be improved substantially by considering all possible layouts, sliceable and non-sliceable. Our algorithm, presented in Section 5, is the first treemapping algorithm that can produce all possible layouts.</p><p>Two layouts representing different areas cannot be the same. Nonetheless they can have a very similar structure. We therefore consider a combinatorial equivalence between layouts. For a layout L, a maximal segment is a maximal contiguous horizontal or vertical line segment contained in the union of the boundaries of rectangles in R. We denote the set of maximal segments of a layout L by S = S(L). We define a partial order on maximal segments of the same orientation as follows. For two horizontal maximal segments s1 and s2 we say that s1 &lt; s2 if s1 is below s2, and there exists a rectangle in R that spans from s1 to s2. Vertical maximal segments similarly define a partial order from left to right. Following Eppstein et al. <ref type="bibr" target="#b6">[7]</ref>, we say that two layouts L and L are order-equivalent if the partial orders for L and L are isomorphic. <ref type="bibr" target="#b1">2</ref> An example of order-equivalent layouts is given in <ref type="figure" target="#fig_1">Figure 3</ref>. In <ref type="bibr" target="#b6">[7]</ref> it was shown that, for any layout L, there is always exactly one layout L that is order-equivalent to L and correctly represents a given set of areas. Thus, for any fixed set of areas, the possible ways to draw a treemap with these areas corresponds to the set of order-equivalence classes of all possible layouts. Sliceable and Non-sliceable layouts. If a layout L is sliceable, then all layouts order-equivalent to L are also sliceable. Existing rectangular treemapping algorithms hence exclude a large number of options from consideration, which may result in treemaps of sub-optimal visual quality. We aim to show this formally. Below we prove that, for certain sets of areas, the maximum aspect ratio of any sliceable layout is much larger than the maximum aspect ratio of the optimal layout.</p><formula xml:id="formula_0">R1 R2 R3 R4 R5 s Fig. 4. R 1 is grounded at maxi- mal segment s.</formula><p>We say that a rectangle Ri ∈ R is grounded if Ri is bounded by at least one maximal segment s for which it is the only rectangle on that side of s (see <ref type="figure">Fig. 4</ref>). We claim that in a sliceable layout all rectangles are grounded. Indeed, if this is not the case, then there must be a rectangle Ri such that all four bounding maximal segments have at least two rectangles on the side of Ri. This results in a "windmill pattern" with Ri in the center (see <ref type="figure" target="#fig_0">Fig. 2</ref>). It is not hard to see that any layout that contains a "windmill pattern" is non-sliceable. We can now prove the following theorem. Theorem 1. The maximum aspect ratio of a sliceable layout L is at least a2/a1, where a1 and a2 are the smallest and second-smallest area in the layout, respectively.</p><p>Proof. Let ρ be the maximum aspect ratio of L and let R1 be the rectangle with the smallest area in L. Let rectangle R2 be adjacent to R1 such that R1 is grounded in the maximal segment shared with R2. Without loss of generality we assume that rectangle R2 lies to the right of rectangle R1. Denote the height and width of Ri by hi and wi, respectively. From the grounded property we get that h1 ≥ h2. This also implies that a2/a1 ≤ w2/w1. From the definition of ρ we get that h1 ≤ ρw1. We further get that</p><formula xml:id="formula_1">ρ ≥ w2 h2 ≥ w2 h1 ≥ w2 ρw1 .</formula><p>As a result, ρ 2 ≥ w2/w1 ≥ a2/a1. Thus the maximum aspect ratio of L is at least a2/a1. This is minimized when R2 is the rectangle with the second smallest area in L.</p><p>Consider the following concrete example with 5 areas: a1 = 1 and a2, a3, a4, a5 = 16. According to Theorem 1 any sliceable layout will have a maximum aspect ratio of at least 16/1 = 4. On the other hand, there exists a non-sliceable layout with these areas with maximum aspect ratio ≈ 1.333, as is shown in <ref type="figure">Figure 5</ref>. In fact, this difference in maximum aspect ratio between sliceable layouts and nonsliceable layouts can be made arbitrarily large: As a1 tends to 0, the maximum aspect ratio of the non-sliceable layout in <ref type="figure">Figure 5</ref> tends to 1, while the maximum aspect ratio of any sliceable layout tends to ∞.</p><formula xml:id="formula_2">R2 R3 R4 R1 R5 R1 R2 R4 R5 R3 Fig. 5</formula><p>. Let a 1 = 1 and a 2 = a 3 = a 4 = a = 16. The maximum aspect ratio in the non-sliceable layout on the right is ≈ 1.333. For any sliceable layout the maximum aspect ratio is at least 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">LOCAL MOVES</head><p>Our stable treemapping algorithm uses the concept of local moves. A local move changes the order-equivalence class of the layout L by changing the layout L locally. Local moves allow us to traverse between all order-equivalence classes of layouts. Intuitively, we can keep a treemap stable over time by limiting the number of local moves between any two time steps. At the same time, the more local moves we allow, the better the visual quality can be. Local moves hence give us the power to control the tradeoff between stability and visual quality. A local move typically changes the areas of the involved rectangles. We can correct the areas in the resulting layout L using the hill-climbing algorithm by Eppstein et al. <ref type="bibr" target="#b6">[7]</ref> (for details see <ref type="bibr">Section 5)</ref>.</p><p>The final layout is order-equivalent to L . Note that two orderequivalent layouts may have different adjacencies across maximal segments (see <ref type="figure" target="#fig_1">Fig. 3</ref>). If L has long maximal segments with many adjacent rectangles on both sides, then adjusting the areas may result in non-local changes of rectangle adjacencies. However, since these changes occur only along maximal segments, they influence the relative positions of rectangles only mildly. We hence claim that our treemaps are stable if we allow only a small number of local moves. The experimental evaluation in Section 7 supports this claim.</p><p>Our local moves are inspired by the work of Young et al. <ref type="bibr" target="#b19">[20]</ref>. They use a representation of rectangular layouts with twin binary tree sequences and show how to use this representation and an additional labeling to transform any two rectangular layouts into each other using only local moves. Their particular labeling is not suitable for the context of treemaps and the representation by twin binary trees is somewhat cumbersome. Below we hence introduce two new local moves which operate directly on the treemap: stretch moves and flip moves. We prove that one can transform any two order-equivalence classes of layouts into each other using only these two moves. Stretch move. Let s be a maximal segment and let R1 and R2 be two rectangles adjacent to one of the endpoints of this segment. Without loss of generality we assume that s is a vertical maximal segment. If rectangles R1 and R2 do not have the same height we can apply a stretch move. Let rectangle R2 denote the rectangle with the smallest height. Without loss of generality we assume that rectangle R1 is to the left of s. To apply the stretch move we then stretch rectangle R2 to the left over rectangle R1 as is shown in <ref type="figure">Figure 6</ref>. Flip move. Let R1 and R2 be two rectangles that together form a larger rectangle. The flip move flips the adjacency between R1 and R2 from horizontal to vertical or vice versa inside this larger rectangle. An example of a flip move is illustrated in <ref type="figure">Figure 7</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Transforming rectangular layouts using local moves</head><p>We now prove that we can transform any layout L into any other layout L using only local moves. For this transformation we need the notion of a vertical stack layout. A layout is a vertical stack layout if it has only horizontal (inner) maximal segments. The transformation from L to L can now be summarized as follows. First we transform L into a vertical stack layout. Next we transform this vertical stack layout into another vertical stack layout. Finally we transform the resulting vertical stack layout into L . To show the existence of this transformation, we need the three following components.</p><p>Transforming a layout to a vertical stack layout. To transform a layout L to a vertical stack layout, we need to eliminate all vertical (inner) maximal segments. Let s be a vertical maximal segment of L. Furthermore, let R1 be the rectangle adjacent to the left top of s, and let R2 be the rectangle adjacent to the right top of s. Now first assume that R1 and R2 do not have the same height, and assume without loss of generality that the height of R2 is smaller than the height of R1. In this case we use a stretch move to stretch R2 over R1 (see <ref type="figure">Fig. 8</ref>). If R1 and R2 have the same height, then they form a larger rectangle together.</p><p>We use a flip move on R1 and R2 as is shown in <ref type="figure">Figure 9</ref>. Note that, in both cases, we reduce the number of rectangles adjacent to s by at least one. When there are no more rectangles adjacent to s, s will cease to exist. Furthermore, our operations do not introduce new vertical maximal segments. We can thus repeatedly apply this procedure until all vertical maximal segments have been eliminated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R1 R2 R2</head><p>R1 s s Transforming vertical stack layouts. Consider any two adjacent rectangles R1 and R2 in a vertical stack layout. We can swap R1 and R2 in the vertical stack order by applying two flip moves to R1 and R2 (see <ref type="figure">Fig. 10</ref>). Since we can swap any two adjacent rectangles, we can produce any order of rectangles in the vertical stack layout (this process is the same as sorting with BubbleSort). Inverting local moves. It is easy to see that all local moves can be inverted. Trivially, a flip move is its own inverse (see <ref type="figure">Fig. 11</ref>). Furthermore, a stretch move that stretches R2 over R1 can be inverted by a stretch move that stretches R1 over R2 (see <ref type="figure" target="#fig_0">Fig. 12</ref>).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R2</head><p>We can now prove the following theorem:</p><p>Theorem 2. For any two layouts L1 and L2 with the same set of rectangles, we can transform L1 into L2 using only stretch moves and flip moves.</p><p>Proof. We can transform L1 into a vertical stack layout L 1 as described above. Similarly, we can transform L2 into a vertical stack layout L 2 .</p><p>To transform L1 into L2, we first transform L1 into L 1 . Next, we transform L 1 into L 2 using appropriately chosen swaps of adjacent rectangles. Finally we transform L 2 into L2 by inverting the local moves used to transform L2 into L 2 .</p><p>We can additionally show that, if the number of rectangles in L1 and L2 is n, then we need at most O(n 2 ) local moves to transform L1 into L2. Please note that the proof above is a so-called "constructive proof of existence". Our argument (i) shows that there always is a set of local moves to transform one layout into the other, and (ii) it describes a way to find these moves. Clearly the resulting transformation is not very natural and we do not intend to use this transformation. Now that we have proven that a transformation always exists, we can find more suitable transformations in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">ALGORITHM</head><p>We now describe our stable treemapping algorithm Incremental Treemap for time-varying data. Our algorithm uses the previous treemap to generate the next one. We therefore need to describe how to transform a treemap T with areas A = {a1, . . . , an} into a treemap T with areas A = {a 1 , . . . , a n }.</p><p>We first consider only a single-level treemap T . We construct the initial treemap using the approximation algorithm by Nagamochi and Abe <ref type="bibr" target="#b11">[12]</ref>. To transform T into T , we use a very simple approach. First we update the treemap T to have the areas in A using the hill-climbing algorithm by Eppstein et al. <ref type="bibr" target="#b6">[7]</ref>.</p><p>The idea of the algorithm by Eppstein et al. is as follows. As is shown in <ref type="bibr" target="#b6">[7]</ref>, there is an induced bijection between the space of coordinates of the maximal segments (segment space) and the space of the areas of the rectangles (area space). Hence, given a (tangent) vector in the area space, in particular A − A, we can compute the corresponding tangent vector x in the segment space by solving the linear equation Jx = A − A, where J is the Jacobian matrix of the bijection. Thus, we can locally change the areas from A to A by moving the maximal segments in the direction of x. The Jacobian matrix J is sparse and can easily be computed as, for each rectangle, the area simply depends on the coordinates of the 4 maximal segments bounding the rectangle. We can now proceed as in a gradient descent approach by iteratively changing the maximal segment coordinates by εx, for ε small enough, until we obtain the areas in A .</p><p>Next, we attempt to improve the visual quality of the layout by applying up to d local moves, where d is some predefined small constant (in our experiments d = 4). A naive approach would simply try all possible sets of at most d local moves. In Section 5.1 we explain how to choose a suitable subset of possible moves to optimize performance. The areas of the resulting layouts (after the at most d local moves) are then again adjusted using the hill-climbing algorithm by Eppstein et al. <ref type="bibr" target="#b6">[7]</ref> to generate an order-equivalent layout with the correct areas. We use the layout with the best average aspect ratio to construct T . Note that we do not change the layout if doing so would lead only to a minor improvement in aspect ratios. Therefore, if L is the layout of T with updated areas A , then we only change L into L if the sum of aspect ratios in L is at least some predefined constant c lower than the sum of aspect ratios in L (in our experiments we use c = 4).</p><p>If T is a multi-level treemap then we use our algorithm recursively on the rectangles that represent subtrees. That is, we first transform the single-level treemap which is formed by the root of T and its children using a set of local moves. Then we recurse into the treemaps inside each of the resulting rectangles Ri and apply the algorithm on the lower levels. The choice of moves is restricted to those moves that involve only subrectangles of Ri which ensures that the hierarchy information is maintained. Clearly changing the layout on a higher level of T has more impact than changing it on a lower level, as it affects all subtreemaps of T . We account for this by adapting the value of c according to the height of the level. In our implementation we are using c = 4 * √ height of the level. Handling additions. When additional data points become available in a changing data set we need to add a new rectangle to the treemap. We introduce such new rectangles before performing any local moves. To add a new rectangle R k to the treemap, we partition an existing rectangle Ri into two subrectangles Ri and R k (see <ref type="figure" target="#fig_1">Fig. 13</ref>). We pick Ri in such a way that the aspect ratios are minimized. <ref type="figure" target="#fig_1">Fig. 13</ref>. Rectangle R k is inserted next to R i by partitioning R i into two sub rectangles.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R k</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Ri Ri</head><p>Handling deletions. For similar reasons we may also need to remove a rectangle from the treemap. Removing rectangles is slightly more involved than adding rectangles, and happens before any local moves are performed, but after new rectangles have been added. There are two cases we need to consider when removing a rectangle Ri:</p><p>Ri is grounded: There necessarily exists a maximal segment s for which Ri is the only rectangle on one side of s. To remove Ri we stretch all rectangles on the other side of s over Ri using stretch moves (see <ref type="figure" target="#fig_5">Fig. 14)</ref>. Ri is not grounded: Ri must be in the center of a windmill pattern. The goal is now to apply stretch moves to Ri until Ri becomes grounded and we are in the first case. Let e be the edge of Ri that is adjacent to the fewest rectangles on the other side. Since Ri is in the center of a windmill pattern, e must include an endpoint of a maximal segment s. there is more than one rectangle on the top side of e, we stretch the leftmost of those rectangles Rj over Ri. As soon as there is only one rectangle Rj on the other side of e, we stretch Ri over Rj (see <ref type="figure">Fig. 15</ref>). If we are unlucky, then Ri is still not grounded, but it is now part of a larger windmill pattern. In that case we repeat the procedure above until Ri finally becomes grounded.</p><p>We summarize our algorithm in the following pseudocode, where f (L) measures the sum of aspect ratios in a layout L.</p><formula xml:id="formula_3">Algorithm IncrementalTreeMap(T ,A ,d,c) 1. if T is empty 2.</formula><p>Generate T using the approximation algorithm. 3. else 4.</p><p>L = correctAreas(L, A ) 5.</p><p>Add rectangles to T that need to be in T .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6.</head><p>Remove rectangles from T that are not in T .</p><formula xml:id="formula_4">7. Q0 = {L} 8. L best = L 9. for i = 1 to d 10.</formula><p>for L ∈ Qi−1 11.</p><p>for all possible local moves m on L 12.</p><formula xml:id="formula_5">L = apply(m, L ) 13. L = correctAreas(L , A ) 14. if f (L ) &lt; f (L best ) 15. L best = L 16. Qi = Qi ∪ {L } 17. if f (L best ) &lt; f (L) − c 18.</formula><p>Let the layout of T be L best 19. for all children Tc of T 20.</p><p>IncrementalTreeMap(Tc, A (Tc), d, c)</p><p>Finally we give the pseudocode for an implementation of Eppstein's et al. <ref type="bibr" target="#b6">[7]</ref> algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Algorithm correctAreas(L,A )</head><p>1. Let A be the areas in L.</p><p>2. while A − A is not small enough 3.</p><p>Let J be the Jacobian matrix of mapping segments to areas.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.</head><p>Solve Jx = A − A for x.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5.</head><p>Move maximal segments of L by εx.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>6.</head><p>Recompute areas A of L. 7. return L</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Improving performance</head><p>The naive algorithm described above is not very efficient. There are two reasons for that: (i) the number of layouts considered by the algorithm is exponential in d, and (ii) updating the areas using the hill-climbing algorithm is not very efficient. We address these two issues below. Reducing the number of layouts. We first compute all layouts that are the result of applying one local move. Of these layouts, we only keep the k layouts with the smallest aspect ratios (in our experiments we use k = 4). When applying a second local move to one of the k remaining layouts, we consider only those local moves that involve a maximal segment for which the adjacencies have been changed by the first local move. Afterwards, we again keep only the best k layouts and we repeat this procedure until we have applied d local moves per layout. Although this approach may not find the best possible layout, it does perform well in practice and the number of layouts considered is no longer exponential in d. Updating areas more efficiently. Computing the correct areas for general (possibly non-sliceable) layouts is significantly more difficult than computing the correct areas for sliceable layouts (areas for sliceable layouts can simply be computed recursively). However, most layouts contain large components that are sliceable. We can use this fact to speed up our algorithm. While we can find a maximal segment s that slices the layout, we simply place s according to the areas of the rectangles on its two sides, and continue recursively on both sides of s. When the layout is not sliceable, we try to find maximal segments that have a single rectangle on both sides. These maximal segments can be removed and reinserted later as a slicing maximal segment. Finally, when no such maximal segments remain, we use the hill-climbing algorithm to position the remaining maximal segments. This approach speeds up our algorithm substantially in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">MEASURES OF STABILITY</head><p>One of the most common measures for stability is the layout-distancechange function introduced by Shneiderman and Wattenberg <ref type="bibr" target="#b13">[14]</ref>. The layout-distance-change function measures the average change of each rectangle in position and shape between two layouts. There are three variants of this function. The first variant is the variance-distancechange function by Tak and Cockburn <ref type="bibr" target="#b14">[15]</ref>, which measures the variance of the layout-distance-change. This allows us to distinguish between a large number of small changes which might be almost invisible, and a small number of large changes. The second variant is the centroidpositioning measure by Hahn et al. <ref type="bibr" target="#b9">[10]</ref>. This measure captures the average change of the centroids of rectangles between two layouts. This approach can easily be extended to non-rectangular treemaps. The third and final variant is the locational-drift measure, again by Tak and Cockburn <ref type="bibr" target="#b14">[15]</ref>. This measure captures how much the rectangles move from their average position over a longer period of time: if rectangles drift around the same position, it is easy to track the rectangles even though the exact position changes every iteration.</p><p>All of these measures use the change in absolute position of a rectangle between layouts as their base. We claim that this is not sufficient to measure the stability. We believe that the change in relative position between rectangles is another important factor to determine the stability. If the relative position between a pair of rectangles R2 and R3 is unchanged, then even if the absolute positions of R2 and R3 change drastically, it is not too difficult to keep track of R2 and R3. For example, in <ref type="figure">Figure 16</ref> rectangle R1 has changed positions with rectangles R2, . . . , R5. In absolute distance, the layout has changed significantly and thus layout-distance-change and its variations give a high score. However, as all rectangles R2, . . . , R5 have maintained their relative position with regard to each other, it is actually quite easy to track the rectangles from one layout to the next. By finding a single rectangle from R2, . . . , R5 we can easily find all other rectangles from R2, . . . , R5. Thus, when only small changes in the relative position of the rectangles occur, the layout seems to be relatively stable even when the absolute positions change drastically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R2 R3 R1</head><p>R5 R4 R2 R3 R1 R5 R4 <ref type="figure">Fig. 16</ref>. Rectangle R 1 has swapped with rectangle R 2 , . . . , R 5 . Even though the absolute positions have significantly changed, it is still easy to track the changes.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">A new measure of stability</head><p>We introduce a new measure for stability that aims to properly capture the change in relative position between rectangles. The relative position between two rectangles is often perceived as above or below, and left or right. To measure the relative position with respect to a rectangle Ri, we subdivide the space around Ri into 8 sections {S1, S2, ..., S8} = S(Ri) by extending the sides of Ri (see <ref type="figure">Fig. 17</ref>). <ref type="table">S2  S3  S4   S5   S6</ref> S7 S8 <ref type="figure">Fig. 17</ref>. The space around rectangle R 1 is subdivided into 8 sections.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R1 S1</head><p>Section S1 represents the East, Section S2 the NorthEast, etc. The relative position of Rj with respect to Ri is now determined by the percentage of Rj in each of the sections of S(Ri).</p><p>We determine the change of the relative position between rectangles Ri and Rj in layouts L and L by calculating to what degree rectangle Rj stays in the same sections of rectangle Ri. Let p k ij (L) be the percentage of Rj that is in section S k of S(Ri) in layout L. We define the relativeposition-change between Ri and Rj as follows:</p><formula xml:id="formula_6">D rel ij (L, L ) = 1 2 8 k=1 p k ij (L) − p k ij (L )<label>(1)</label></formula><p>For example, in <ref type="figure">Figure 18</ref> rectangle R2 was for 25% in S1 and for 75% in S2 of rectangle R1. After the change R2 is for 100% in S1 which results in a score of 0.25.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>R1 R2 R1 R2</head><p>Fig <ref type="figure">. 18</ref>. 25% of the area of rectangle R 2 was in the NorthEast section of rectangle R 1 . In the next layout 100% of the area of R 2 is in the East section of R 1 .</p><p>We then calculate the overall relative-position-change by averaging the relative-position-change for all pairs of rectangles Ri and Rj that are in both layouts:</p><formula xml:id="formula_7">D rel (L, L ) = 1 |R| 2 i j D rel ij (L, L )<label>(2)</label></formula><p>By definition, the relative-position-change is a value between 0 and 1, where 0 indicates no relevant change in the relative positions and 1 indicates the highest possible change of relative positions. <ref type="figure">Figure 19</ref> and <ref type="figure" target="#fig_0">Figure 20</ref> show two examples: In <ref type="figure">Figure 19</ref> the relative positions between rectangles do not change, and thus the relative-position-change is 0 (in comparison, the layout-distance-change is 5.325). In <ref type="figure" target="#fig_0">Figure 20</ref> the relative positions change significantly and the relative-positionchange is 0.45 (in comparison, the layout-distance-change is nearly the same as for <ref type="figure">Fig. 19</ref>, namely 5.308). Note that it is much easier to keep track of the rectangles in <ref type="figure">Figure 19</ref> than in <ref type="figure" target="#fig_0">Figure 20</ref>, which is clearly reflected in our stability measure.</p><p>Independently, Hahn et al. <ref type="bibr" target="#b8">[9]</ref> very recently proposed relativedirection-change as a measure for stability. Relative-direction-change measures the difference in angles between the centroids of two rectangles Ri and Rj in layouts L and L . Both this measure and our relative-position-change capture the change in relative positions, but there are two major differences. First, our measure has a cutoff point for measuring the change in relative position: we do not distinguish between Rj moving from North to East with respect to Ri or from North to South. We believe that in the former case it is already very difficult to recover the position of Rj from Ri, and not significantly less difficult than in the latter case. The second major difference is that our measure is focused purely on rectangular treemaps, whereas the relative direction change measure is defined for general treemaps. As a result, our measure is more suitable for rectangles. Note that, when considering rectangles, the exact angle between the centroids of two rectangles is not that relevant for the perception of relative position. Instead, it is more readily perceived if one rectangle is above/below or left/right from another rectangle. This aspect is covered much more accurately by our measure.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">EXPERIMENTAL EVALUATION</head><p>We evaluate the visual quality and the stability of our incremental algorithm by comparing it to existing rectangular treemapping algorithms. More specifically, we compare the algorithms in terms of the average median aspect ratio, the average mean aspect ratio, the average relative-stability-change and the average layout-distance-change computed over an entire dataset. For this evaluation we use two different real-world datasets: the Coffee dataset and the Names dataset. The complete source code of our implementation can be found here https://gitaga.win.tue.nl/max/IncrementalTreemap. Coffee dataset. The first dataset consists of the amount of coffee a country imported in the period 1994-2014 and originates from the UN comtrade database <ref type="bibr" target="#b16">[17]</ref>. It contains all the 86 countries which have complete data in this period and has a 3-level hierarchy consisting of the country, the region it belongs to, and the continent it belongs to.</p><p>For each algorithm the average relative-position-change and the average layout-distance-change on the Coffee dataset are shown in <ref type="figure" target="#fig_0">Figure 21</ref>. While there are differences between the distribution of the two stability measures, there are no large discrepancies. It thus seems that the average relative-position-change captures similar trends of stability as the layout-distance-change if the scores are high. On low scores, the differences become more apparent as the relative-positionchange score is indeed far closer to 0 for the slice-and-dice algorithm <ref type="figure" target="#fig_0">Fig. 21</ref>. A comparison between the average relative-position-change and the average layout-distance-change of the different algorithms on the Coffee dataset. The average relative-position-change is depicted by the left columns and the average layout-distance-change is depicted by the right columns. The data is averaged over the treemaps generated for each year in the Coffee dataset. <ref type="figure" target="#fig_0">Fig. 22</ref>. A comparison between the average mean and average median aspect ratio of the different algorithms on the Coffee dataset. The average mean aspect ratio is depicted by the left columns and average median aspect ratio is depicted by the right columns. The data is averaged over the treemaps generated for each year in the Coffee dataset. <ref type="figure" target="#fig_0">Fig. 23</ref>. A comparison between the average median aspect ratio and the average relative-position-change on the Coffee dataset. The data is averaged over the treemaps generated for each year in the Coffee dataset.</p><p>than the layout-distance-change score. This is due to the fact that the slice-and-dice algorithm does not change order-equivalence classes at all if there is no hierarchy, and only up to a limited degree if there is a hierarchy. From <ref type="figure" target="#fig_0">Figure 21</ref> it moreover follows that the incremental algorithm significantly outperforms all other algorithms, except for slice-and-dice, on both the average relative-position-change and the average layout-distance-change.</p><p>In <ref type="figure" target="#fig_0">Figure 22</ref> we show the difference between the average mean aspect ratio and the average median aspect ratio for different algorithms. Note that for most algorithms the mean aspect ratio is significantly larger than the median aspect ratio. This implies that for each of these algorithms there are a number of rectangles with very large aspect ratios. Thus, these algorithms do not keep the maximum aspect ratio low, which results in treemaps with low visual quality. In contrast, the incremental algorithm and the approximation algorithm both do aim to minimize the maximum aspect ratio. As a result, all rectangles in the corresponding treemaps have relatively lower aspect ratios and are better visible, leading to treemaps with high visual quality.</p><p>Finally in <ref type="figure" target="#fig_0">Figure 23</ref> the average median aspect ratio is compared to the average relative-position-change. From this figure we can see that the incremental algorithm outperforms all other algorithms on either the average median aspect ratio or average relative-position-change, and actually outperforms most algorithms on both fronts. Names dataset. The second dataset consists of the 200 most popular boys and girls baby names in the Netherlands for each year in the period 1993-2015 and originates from the Nederlandse Voornamenbank <ref type="bibr" target="#b10">[11]</ref>. The dataset in total contains 372 names and does not have a hierarchy. See <ref type="figure" target="#fig_0">Figure 27</ref> for some treemaps computed with our incremental algorithm, and the Hilbert and squarified treemapping algorithms. <ref type="bibr" target="#b2">3</ref> For each algorithm the average relative-position-change and the average layout-distance-change on the Names dataset are shown in <ref type="figure" target="#fig_0">Figure 24</ref>. The discrepancies between the two measures are less pronounced in the Names dataset than in the Coffee dataset. This is caused by the fact that the Names dataset has many rectangles of similar sizes. If one large rectangle changes position, then this generally causes a large layout-distance-change and a relatively low relative-positionchange, whereas with rectangles of similar sizes, this difference is much smaller. From <ref type="figure" target="#fig_0">Figure 24</ref> we moreover see that the incremental and slice and dice algorithms are almost completely stable. This is because the Names dataset itself is quite stable. The most frequent changes that occur are insertions and deletions from names in the dataset. As the incremental algorithm uses the previous layout as a basis, the layout stays virtually the same after an insertion or a deletion. For the slice and dice algorithm the layout also stays roughly the same, as it only uses a different layout when the dataset has a hierarchy. For all the other algorithms, however, the layout can change drastically when an element is inserted or deleted, which is reflected in the stability measures.</p><p>In <ref type="figure" target="#fig_0">Figure 25</ref> we show the difference between the average mean aspect ratio and the average median aspect ratio for different algorithms. The discrepancies between the two are quite low with the notable exception of the Spiral algorithm. Moreover the values of the mean and median aspect ratios are very low as well, which indicates that the resulting rectangles in the treemap for all algorithms except slice and dice have low aspect ratios. The incremental algorithm performs slightly worse on the aspect ratio than most other algorithms. This is mostly due to the fact that we allowed the incremental algorithm to perform only 4 local moves per timestep, while the number of rectangles per level (there is only a single level) is far larger. It is thus not always possible to immediately improve the aspect ratios of all the bad rectangles. By allowing more moves, the aspect ratio would decrease, but the stability measure would increase. The algorithm thus clearly has a tradeoff between the stability and the visual quality. In contrast, the other algorithms can change the entire layout and thus insertions and deletions do not have a similar impact on the mean and median aspect ratios.</p><p>Finally in <ref type="figure" target="#fig_0">Figure 26</ref> the average median aspect ratio is compared to the average relative-position-change. From this figure we can see that the incremental algorithm again outperforms all other algorithms on either the median aspect ratio or the average relative-position-change. Moreover, the average relative-position-change is significantly lower <ref type="bibr" target="#b2">3</ref> In <ref type="figure" target="#fig_0">Figure 27</ref> the dataset is trimmed to only those names that occur in every year, such that there are no insertions or deletions that influence the stability. The trimmed dataset only contains the names which occur in every year of the dataset. The average mean aspect ratio is depicted by the left columns and average median aspect ratio is depicted by the right columns. The data is averaged over the treemaps generated for each year in the Names dataset.</p><p>than most algorithms while the average median aspect ratio is only slightly higher than most other algorithms.</p><p>The experiments show that our incremental algorithm performs very well on real-world data with respect to stability and visual quality. The algorithm obtains an average median aspect ratio below 2 for both datasets, which indicates that the rectangles have a high visual quality. Moreover, the incremental algorithm outperforms all algorithms, except for slice and dice, on both the average layout-distance-change and the average relative-position-change on both datasets. From <ref type="figure" target="#fig_0">Figure 23</ref> and <ref type="figure" target="#fig_0">Figure 26</ref> we can further conclude that the incremental algorithm outperforms existing treemapping algorithms on either the visual quality and/or stability in practice. This is also clearly demonstrated in the supplementary video.</p><p>The only main disadvantage of the incremental algorithm is the running time compared to the existing rectangular treemapping algorithms. As the incremental algorithm explores various possible layouts, it is slower than other rectangular treemapping algorithms that directly construct a layout. This difference in running time can become noticeable once the number of rectangles in a treemap becomes large. When a treemap contains 200 rectangles, existing treemap algorithms can generate the layout almost instantaneously, whereas the incremental algorithm takes about 15 seconds to generate the layout in our implementation. If the application is very time-sensitive, then this might become a problem. In that case the incremental algorithm can be sped up by changing the parameters of the exploration, but the quality of the <ref type="figure" target="#fig_0">Fig. 26</ref>. A comparison between the average median aspect ratio and the average relative-position-change. on the Names dataset. The data is averaged over the treemaps generated for each year in the Names dataset.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Hilbert</head><p>Squarified Incremental 1993 1994 1995 <ref type="figure" target="#fig_0">Fig. 27</ref>. A comparison of the Hilbert treemapping algorithm, our incremental treemapping algorithm, and the squarified treemapping algorithm on the trimmed Names dataset for the years 1993-1995. The dataset is trimmed to only those names that occur in every year, such that no insertions or deletions occur. One can observe that our incremental algorithm is significantly more stable than the other algorithms. This difference in stability is even more apparent in the supplementary video.</p><p>resulting treemaps would deteriorate accordingly. However, note that with a large number of rectangles in a treemap, the treemap becomes increasingly hard to read. In most reasonable cases, the incremental treemapping algorithm will generally be sufficiently fast, even for interactive treemap generation. For example, for the Coffee dataset it takes only 62 ms on average to compute the treemap for one time step.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">CONCLUSION</head><p>We presented a new algorithm to compute stable treemaps. Our algorithm is based on the concept of local moves, modifications to the treemap that influence only a small part of the treemap. These local moves allow us, in contrast to existing treemapping algorithms, to explore the full range of options for choosing layouts, which can provably lead to treemaps with better visual quality. Furthermore, the local moves allow us to control the tradeoff between stability and visual quality, simply by limiting the number of local moves between every two time steps. Our experiments show that our incremental algorithm does not only perform better with respect to stability and/or visual quality in theory, but also in practice on real-world data. The only main disadvantage of our algorithm is its running time, which may be prohibitive for interactive applications on very large datasets. Nonetheless, for most reasonable practical scenarios, where the treemaps still need to remain readable, our algorithm is sufficiently fast. Beyond that, it is even possible to control the tradeoff between the running time of the algorithm and the visual quality of the treemaps, again by controlling the number of local moves between every two time steps. A fully controllable tradeoff between the three aspects visual quality, stability, and running time remains an interesting open problem.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Fig. 2 .</head><label>2</label><figDesc>A nonsliceable layout. Rectangle R i is the center of a "windmill".</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 3 .</head><label>3</label><figDesc>Two order-equivalent layouts: the blue arrows indicate the partial order on the vertical maximal segments, the red arrows indicate the partial order on the horizontal maximal segments.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 6 .Fig. 7 .</head><label>67</label><figDesc>A stretch move at the upper endpoint of the maximal segment s. A flip move on rectangles R 1 and R 2 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 8 .Fig. 9 .</head><label>89</label><figDesc>Rectangle R 2 is stretched over rectangle R 1 : s has one less rectangle adjacent to it. Rectangle R 1 and R 2 are flipped using a flip move: s has two less rectangles adjacent to it.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 10 .Fig. 11 .Fig. 12 .</head><label>101112</label><figDesc>Rectangles R 1 and R 2 are swapped using two flip moves. Inverting the Flip move. Inverting the Stretch move.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 14 .</head><label>14</label><figDesc>We delete the grounded rectangle R 1 from the layout by stretching R 2 and R 3 over R 1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 19 .Fig. 20 .</head><label>1920</label><figDesc>A change occurred in the layout, but all relative positions stay the same. It is easy to track the movement of the rectangles. The relative-position-change is 0 and the layout-distance-change is 5.325. A change occurred in the layout which affects the relative positions. It now becomes more difficult to track the movement of the rectangles. The relative-position-change is 0.45 and the layout-distancechange is 5.308.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 24 .</head><label>24</label><figDesc>A comparison between the average relative-position-change and the average layout-distance-change of the different algorithms on the Names dataset. The average relative-position-change is depicted by the left columns and the average layout-distance-change is depicted by the right columns. The data is averaged over the treemaps generated for each year in the Names dataset.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 25 .</head><label>25</label><figDesc>A comparison between the average mean and average median aspect ratio of the different algorithms on the trimmed Names dataset.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>de-• Max Sondag is with TU Eindhoven. E-mail: m.f.m.sondag@tue.nl. • Bettina Speckmann is with TU Eindhoven. E-mail: b.speckmann@tue.nl. • Kevin Verbeek is with TU Eindhoven. E-mail: k.a.b.verbeek@tue.nl. Manuscript received 31 Mar. 2017; accepted 1 Aug. 2017. Date of publication 28 Aug. 2017; date of current version 1 Oct. 2017. For information on obtaining reprints of this article, please send e-mail to: reprints@ieee.org, and reference the Digital Object Identifier below. Digital Object Identifier no. 10.1109/TVCG.2017.2745140</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>RjFig. 15. If rectangle R 1 is adjacent to multiple rectangles of all sides, we can make R 1 a grounded rectangle by repeatedly applying stretch moves over an adjacent maximal segment s.</figDesc><table><row><cell>Rj</cell><cell></cell><cell></cell></row><row><cell>s</cell><cell>s</cell><cell>Ri</cell></row><row><cell>Ri</cell><cell>Ri</cell><cell></cell></row></table><note>Without loss of generality e is above Ri and the endpoint of s is on the left side of e. Then, as long as</note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1">This result was previously claimed in<ref type="bibr" target="#b2">[3]</ref> but not in fact proven.</note>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="2">Note that this equivalence is different from the equivalence considered by Yao et al.<ref type="bibr" target="#b18">[19]</ref> and mentioned in Section 2: order-equivalent layouts generally do not have the same dual graph.</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Voronoi treemaps for the visualization of software metrics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Balzer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Deussen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lewerentz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ACM Symposium on Software Visualization</title>
		<meeting>the ACM Symposium on Software Visualization</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="165" to="172" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Ordered and quantum treemaps: Making effective use of 2d space to display hierarchies</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">B</forename><surname>Bederson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wattenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="833" to="854" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Squarified treemaps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bruls</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Huizing</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Data Visualization</title>
		<imprint>
			<publisher>Springer</publisher>
			<date type="published" when="2000" />
			<biblScope unit="page" from="33" to="42" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The number of Baxter permutations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">R</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">L</forename><surname>Graham</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Hoggatt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kleiman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Combinatorial Theory, Series A</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="382" to="394" />
			<date type="published" when="1978" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Treemaps with bounded aspect ratio</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">De</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Speckmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Van Der Weele</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Geometry</title>
		<imprint>
			<biblScope unit="volume">47</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="683" to="693" />
			<date type="published" when="2014" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Ordered and unordered treemap algorithms and their applications on handheld devices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<pubPlace>Stockholm Royal Institute of Technology</pubPlace>
		</imprint>
	</monogr>
	<note>Master&apos;s degree project, Department of Numerical Analysis and Computer Science. SE-100</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Area-universal and constrained rectangular layouts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Eppstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Mumford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Speckmann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Verbeek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Computing</title>
		<imprint>
			<biblScope unit="volume">41</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="537" to="564" />
			<date type="published" when="2012" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Some problems of non-associative combinations (2)</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Erdélyi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">M</forename><surname>Etherington</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Edinburgh Mathematical Notes</title>
		<imprint>
			<biblScope unit="volume">32</biblScope>
			<biblScope unit="page" from="7" to="14" />
			<date type="published" when="1940" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Relative direction change: A topologybased metric for layout stability in treemaps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hahn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bethge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Döllner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 8th International Conference of Information Visualization Theory and Applications (IVAPP 2017)</title>
		<meeting>the 8th International Conference of Information Visualization Theory and Applications (IVAPP 2017)</meeting>
		<imprint>
			<date type="published" when="2017" />
			<biblScope unit="page" from="88" to="95" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Visualization of varying hierarchies by stable layout of voronoi treemaps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Hahn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Trümper</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Moritz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Döllner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Information Visualization Theory and Applications</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2014" />
			<biblScope unit="page" from="50" to="58" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Knaw</forename><surname>Meertens Instituut</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Nederlandse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Voornamenbank</surname></persName>
		</author>
		<ptr target="https://www.meertens.knaw.nl/nvb" />
		<imprint>
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">An approximation algorithm for dissecting a rectangle into rectangles with specified areas</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Nagamochi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Abe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Discrete Applied Mathematics</title>
		<imprint>
			<biblScope unit="volume">155</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="523" to="537" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Tree visualization with tree-maps: 2-d space-filling approach</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="92" to="99" />
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Ordered treemap layouts</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Shneiderman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wattenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the IEEE Symposium on Information Visualization</title>
		<meeting>the IEEE Symposium on Information Visualization</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page">73</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Enhanced spatial stability with Hilbert and Moore treemaps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tak</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Cockburn</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="141" to="148" />
			<date type="published" when="2013" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Visualizing changes of hierarchical data using treemaps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Tu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1286" to="1293" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title level="m" type="main">UN comtrade database</title>
		<ptr target="https://comtrade.un.org" />
		<imprint>
			<date type="published" when="2016" />
			<biblScope unit="page" from="15" to="17" />
		</imprint>
	</monogr>
	<note>United Nations</note>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">A note on space-filling visualizations and space-filling curves</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Wattenberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Information Visualization</title>
		<imprint>
			<publisher>IEEE</publisher>
			<date type="published" when="2005" />
			<biblScope unit="page" from="181" to="186" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Floorplan representations: Complexity and connections</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Yao</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Chen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C.-K</forename><surname>Cheng</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Graham</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Design Automation of Electronic Systems</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="55" to="80" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Twin binary sequences: A nonredundant representation for general nonslicing floorplan</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">F</forename><surname>Young</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">C</forename><surname>Chu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><forename type="middle">C</forename><surname>Shen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="457" to="469" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
