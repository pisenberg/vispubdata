<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Kd-Jump: a Path-Preserving Stackless Traversal for Faster Isosurface Raytracing on GPUs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><forename type="middle">M</forename><surname>Hughes</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ik</forename><forename type="middle">Soo</forename><surname>Lim</surname></persName>
						</author>
						<title level="a" type="main">Kd-Jump: a Path-Preserving Stackless Traversal for Faster Isosurface Raytracing on GPUs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:52+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Raytracing</term>
					<term>isosurface</term>
					<term>GPU</term>
					<term>parallel computing</term>
					<term>volume visualization</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Isosurfaces rendered on a NVidia GTX280 GPU with a 512 2 screen. Bonsai (256 3) rendered at 36.4 fps (stack); 23.2 fps (kd-restart); 42.6 fps (Kd-Jump). Foot (256 3) at 45.9 fps (stack); 27.1 fps (kd-restart); 50.9 fps (Kd-Jump). Aneurism (512 3) at 29.4 fps (stack); 18.4 fps (kd-restart); 36.7 fps (Kd-Jump). Skull (256 3) at 25.2 fps (stack); 19.1 fps (kd-restart); 30.1 fps (Kd-Jump). Kd-Jump outperforms both kd-restart and a stack-based approach.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>Visualization of volumetric data has seen much research over many years. The two prominent approaches typically employed are direct volume rendering <ref type="bibr" target="#b1">[2,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr" target="#b22">23]</ref> and isosurface visualization. Isosurface rendering is a simple and effective approach for visualizing the different intensities present in the data. Many methods for isosurface visualization have been presented ranging from direct volume rendering using isosurface transfer-functions <ref type="bibr" target="#b18">[19]</ref>, rasterization of isosurfaces extracted to polygonal data <ref type="bibr" target="#b16">[17]</ref>, or direct raytracing <ref type="bibr" target="#b12">[13,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b23">24]</ref>. Raytracing is a process of projecting rays through a scene to find intersections with scene geometry. In order to facilitate finding these intersections in a timely manner, an acceleration structure is typically warranted. Acceleration structures serve two purposes; to ensure only valid data-elements intersecting the rays are examined, and to ensure empty space is ignored.</p><p>Interactive isosurface raytracing <ref type="bibr" target="#b13">[14,</ref><ref type="bibr" target="#b23">24]</ref> presents a unique challenge as the acceleration structure must facilitate the rendering of all possible isosurfaces held by the data. An implicit kd-tree <ref type="bibr" target="#b23">[24]</ref> is a special variant of general kd-trees, which is designed to facilitate fast traversal to voxels with possible ray-isosurface intersections. In this paper, we utilize a variant of the implicit kd-tree approach and specifically target our contribution for highly-parallel computing devices, such as Graphical Processing Units (GPUs).</p><p>GPUs have developed very quickly in recent years so as to be several magnitudes more powerful than modern CPUs. GPUs are essentially massive parallel-processing devices with many small processing units and hence are typically suited to light-weight and highlyparallel computing problems. GPUs were initially made available to researchers with the introduction of shader languages, although this required complicated programming. With the advent of new technologies such as CUDA (Compute Unified Device Architecture), it has become more viable to perform sophisticated algorithms on GPU hardware with relatively simpler programming methodologies. For example, CUDA kernels (i.e., functions that operate in parallel across multiple threads) are programmed in the C language and called much like a normal C/C++ function.</p><p>However, raytracing on GPUs introduces new challenges for researchers, not only from an implementation perspective, but also in choosing the best algorithm to fully utilize the device hardware. Many previous raytracing approaches were designed for CPU-based raytracing and therefore may not have the same benefits when implemented on GPUs. Raytracing algorithms can be divided into two categories; those that reduce the overall workload (e.g., packet traversal) and those that optimize the traversal (e.g., stackless traversal). In packet traversal <ref type="bibr" target="#b23">[24]</ref>, a group of rays are represented and traversed as a packet, which reduces the amount of work for the group by performing the common traversal steps. Coherent traversal <ref type="bibr" target="#b13">[14]</ref> attempts to exploit the fact that rays typically traverse the same nodes most of the time by forcing convergence after ray divergence. Optimization algorithms target the specific strengths and drawbacks of employed architecture, for example, stackless traversal <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b20">21]</ref>.</p><p>In general, raytracing requires a stack to record tree nodes which should, if required, be returned to. Due to shared-memory limitations of GPUs, such an approach typically requires the stack to be stored in the GPU's main memory (global memory). Since the slowest aspect of most GPUs is accessing the global memory, however, a stack-based approach may induce a memory bottleneck.</p><p>Foley <ref type="bibr" target="#b4">[5]</ref> highlighted that a stack-based traversal approach, on older-generation GPUs, induced such a performance bottleneck. Their solution was to completely remove the need for a stack and resort to extra computation for correct traversal. The two approaches that they introduced for general kd-trees were kd-restart and kd-backtrack. Kdrestart, upon requiring to return, restarted traversal from the root node, while also moving the ray's segment-range ahead of previously visited areas. Kd-backtrack dealt with returning by backtracking up the tree one node at a time until a valid continuation point was found. Both approaches require a considerable amount of additional work to find valid nodes to continue traversal, as shown in <ref type="figure" target="#fig_1">Fig. 2</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Previous Work</head><p>Implicit kd-trees <ref type="bibr" target="#b23">[24]</ref> have been presented for use with isosurface raytracing and have been shown to be useful for maximum-intensity projection <ref type="bibr" target="#b7">[8]</ref>.</p><p>Challenges using a stack have been addressed by employing semistackless or completely-stackless approaches. Foley <ref type="bibr" target="#b4">[5]</ref> introduced kdrestart and kd-backtrack to find the correct point to continue traversal. This work was further optimized with the introduction of kd-shortstack <ref type="bibr" target="#b9">[10]</ref>. With kd-shortstack, a small stack is used for the majority of cases and, if a stack-overflow occurs, the algorithm reverts to kd-restart. Another alternative in stackless traversal was ropes <ref type="bibr" target="#b20">[21]</ref>. Ropes are additional memory pointers per node, which link a node to its neighbour nodes. Ropes allow traversal, when required to return, to simply travel along the ropes into the neighbour nodes. Unfortunately, ropes require additional computation to build and require a considerable amount of memory.</p><p>Volumetric rendering of scenes with billions of voxels is possible on modern GPUs by streaming data-bricks to the GPU while simultaneously rendering previously uploaded bricks <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b5">6,</ref><ref type="bibr" target="#b8">9]</ref>. This allows volumes far larger than the available memory of the device to be rendered in real time. The latest publication <ref type="bibr" target="#b2">[3]</ref> employing the bricking method is also notable for partially using indices for traversing their acceleration structure, and using a variant of kd-restart.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Main Contribution</head><p>In this paper, we introduce a stackless approach, referred herein as Kd-Jump, for the traversal of implicit kd-trees. Kd-Jump achieves an immediate return, like a stack, without redundant node testing; illustrated in <ref type="figure" target="#fig_1">Fig. 2(a)</ref>. Also introduced is Hybrid Kd-Jump, which utilizes a volume-stepper for leaf testing and a run-time depth threshold to define where kd-tree traversal stops and volume-stepping occurs. By using both methods, we gain the benefits of empty-space removal and fast hardware-accelerated texture-caching.</p><p>In section 2, we give the background on building and traversing an implicit kd-tree. In section 3, we present our stackless approach Kd-Jump. In section 4, we introduce the Hybrid Kd-Jump traversal approach, which can dynamically alter the depth where volume stepping occurs. While in section 5 and 6, we present our results, discuss the possible bottlenecks and analyze CUDA.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">BACKGROUND</head><p>We employ and build upon Wald's <ref type="bibr" target="#b23">[24]</ref> implicit kd-tree. For completeness in this paper, we outline the basic concepts for building and traversing an implicit kd-tree. An unfamiliar reader should refer to Wald's original paper for a more comprehensive overview. We also highlight the aspects that we have altered for our implementation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Building Implicit Kd-Tree</head><p>A kd-tree is a binary tree where, starting with a root, each node is divided into two children by an axis-aligned splitting-plane. When a node cannot be split, it represents one voxel and is referred to as a leaf. The split axis is typically chosen based upon which dimension is currently largest for the node, as illustrated by <ref type="figure" target="#fig_2">Fig. 3</ref>.  <ref type="bibr" target="#b23">[24]</ref> implicit kd-tree. A balanced kd-tree is formed by building the tree upon virtual dimension, while only actual nodes and leaf data are stored. Also, note that split planes can be shared.</p><p>Implicit kd-trees are required to be balanced-trees, such that all leaves of the tree are on the same depth. To achieve this balance, the voxel dimensions must be a power-of-two, although each dimension need not be identical. Implicit kd-trees define actual-dimensions and virtual-dimensions; where the actual-dimensions are for voxels that actually exist while the virtual-dimensions are used purely to ensure that a balanced kd-tree is built, as illustrated by <ref type="figure" target="#fig_2">Fig. 3</ref>. Even though the kd-tree is built upon a larger virtual-volume, the non-existent nodes and voxels are never visited; nor are they stored.</p><p>There are two stages to building the implicit kd-tree, both of which are iterative processes. The first stage involves determining the number of levels for the tree, computing the level information from top-tobottom and allocating the node memory per level. The second stage involves calculating the node information from bottom-to-top. The initial building process is required to be run on the CPU in order to allocate GPU memory, while the more labour-intensive job of computing the node information can be performed in parallel on the GPU itself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.1">Initial Building</head><p>Given a volume and its actual voxel dimensions R = [R x , R y , R z ], we first compute the virtual dimensions</p><formula xml:id="formula_0">V = [2 m , 2 n , 2 p ] where 2 m−1 &lt; R x ≤ 2 m , etc.</formula><p>The number of levels in the kd-tree is then defined as k = m + n + p.</p><p>Each level of the kd-tree has real dimensions R l and virtual dimensions V l . During the process of tree building, we also require maintaining the current range of nodes as V l . We use V l to determine the largest dimension and the split takes place along the axis a l ∈ {x, y, z} of the largest dimension on level l. Thus, starting with</p><formula xml:id="formula_1">V 0 = V and V 0 = [1, 1, 1], the virtual-dimensions for each level are defined by V l+1 a l = 2V l a l , while V l+1 a l = V l a l /2.</formula><p>The actual-dimensions of each level can then be found by R l = ceil V l (R/V ) . Finally, the number of nodes which we require per level is M l = R l</p><p>x × R l y × R l z . Unlike general kd-trees using memory pointers, nodes are addressed using indices and a map is used to convert the indices to a location in memory. For three-dimensional data, a node has three indices U = [x, y, z], which are non-negative integers. Converting these indices, for a node on level l, to a memory location is achieved with o f f set</p><formula xml:id="formula_2">+ (U x + (U y × R l x ) + (U z × R l x × R l y )) × sizeo f (node),</formula><p>where the o f f set is the start of data for the level.</p><p>Implicit kd-trees do not store a split-plane within each node. For each level of the kd-tree, the number of shared split-locations is R l a l rather than M l ; see <ref type="figure" target="#fig_2">Fig. 3</ref>. In fact, the split plane for a node can be computed, for any node, during traversal so as to avoid using global memory.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1.2">Computing Node Data</head><p>Once the memory for the kd-tree is allocated, the node data and dimension splits for each level can be computed. Wald <ref type="bibr" target="#b23">[24]</ref> originally defined that each node contained the minimum and maximum (min/max) value for all data held within the node sub-tree. This min/max value is used to determine whether any child contains the current isovalue and whether traversal should continue.</p><p>In this paper, we define that each node contains the two sets of min/max values; one for each child; rather than just one min/max value encompassing both. By storing the min/max of both children, we can facilitate faster traversal. Specifically, we store both sets so that referencing of the data can be achieved by mapping the indices to memory once and loaded in one transaction. In addition, by checking whether both children are valid (contains the isosurface) before traversing into them, we can potentially eliminate two redundant iterations (downtraversal and return) if a child is invalid.</p><p>Starting from the last node level, the min/max values are computed by evaluating the children. In the case of the last level, this requires checking the eight corner values of a voxel. For the remaining node levels, the min/max sets are computed from the min/max sets held by the child nodes. As nodes are only dependent on their own children, all nodes on a tree-level can be computed in parallel. Finally, if memory overhead is a concern, the final level of nodes can be omitted and computed on the fly <ref type="bibr" target="#b23">[24]</ref>. Special care must be taken if the volume is accessed via CUDA textures, as data is typically offset.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Traversing Implicit Kd-Trees</head><p>Determining whether a ray intersects the isosurface is achieved by traversing the nodes which both intersect the ray and contain the isosurface. Starting from an origin, a ray is projected along a direc-tion and a ray segment, defined by t near and t f ar , is used to mark the valid portions along the ray where raytracing can occur. Each node has two children, denoted first-child and second-child. During traversal, the children are also tagged as near-node and far-node, although the conventions are not synonymous. We also define a boolean NearFirst ≡ r a l &gt; 0, where r is the ray direction vector. Traversing into a child node is performed by updating the indices; we update</p><formula xml:id="formula_3">U d = 2U d + (1 − NearFirst)</formula><p>for the near-node and</p><formula xml:id="formula_4">U d = 2U d + (NearFirst)</formula><p>for the far-node. By traversing the near-node initially, we ensure that the first intersection along the ray is found, at which point traversal can terminate. Testing a node initially requires computing the intersection distance t d from the ray origin to the split plane. Determining which children to traverse into is subject to where t d is in relation to t near and t f ar , as shown in <ref type="figure" target="#fig_3">Fig. 4</ref>. If t near &gt; t d then the near-node is traversed and the far-node is culled. If t f ar &lt; t d then the far-node is traversed. A common case is when t near &lt; t d &lt; t f ar and both child nodes are valid and (potentially) must be traversed. In this case, the near-node is traversed into initially and, if the ray does not find a valid intersection in that sub-tree, the far-node is returned to.</p><formula xml:id="formula_5">(a) t near &lt; t d &lt; t f ar (b) t f ar &lt; t d (c) t near &gt; t d</formula><p>The typical solution for storing the far-node is to use a stack to record the indices and the t d and t f ar values. However, a stack is not ideal for use on a GPU and we explore a stackless approach.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">STACKLESS TRAVERSAL WITH KD-JUMP</head><p>The basic traversal of a kd-tree requires storing a return point when both children of a node have to be tested. Utilising a stack is a simple method for storing the return information. However, a stack approach requires utilizing the (currently) slowest part of the GPU pipeline, the global-memory. To avoid using the global-memory, one must remove the stack. There are two main stackless methods currently available (without requiring additional node memory); kd-restart and kdbacktrack. Both are trivial to implement for implicit kd-trees, but lead to additional workload compared to a stack-based approach. The extra work comes in the form of redundant node testing to find a continuation point.</p><p>With kd-backtrack, the return mechanism is replaced by traversing back up the tree node-by-node until a valid node is found, at which point downward traversal continues. Once a valid parent node is found, the far-child is traversed. The approach was originally envisaged for use with arbitrary kd-trees and therefore required additional parent-pointers to work.</p><p>Traversal of implicit kd-trees does not involve memory pointers and all nodes for all levels are entirely referenced by indices. As a result, it is possible to forgo the need to backtrack one node at a time and simply jump immediately to the next valid node. However, what is a valid node and how much to jump by require additional information. We now explain a novel approach for this and we refer to it as Kd-Jump.</p><p>In order to understand how immediate returning to the next valid node is possible, we will re-examine how downward traversal is achieved with an implicit kd-tree.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Traversing to Child</head><p>Traversal of the kd-tree involves tracking and updating three indices, so as to allow addressing of nodes. The indices of a node, at level l, are defined as U l = [x l , y l , z l ] and the indices of the next level are U l+1 . We first initialize the child indices with those of the parent; U l+1 = U l . Then traversal, from parent to child, is achieved by altering the indexcomponent corresponding to the axis a l that splits the l'th level</p><formula xml:id="formula_6">U l+1 a l = 2U l a l + c, c = 0 first child 1 second child (1)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Returning to Immediate Parent</head><p>Like a stack-based approach, the best scenario is to return to the next immediate node to test. The current node and the node to return to will always share a common parent. As such, the first step is to arrive at that parent (see <ref type="figure" target="#fig_1">Fig. 2</ref>(a) or <ref type="figure" target="#fig_4">Fig. 5</ref>). The trivial case, given U l+1 , is to return to the immediate parent U l . Again, for this simple case, we initialize the indices with U l = U l+1 and then apply an operation equivalent to the inverse of Eq. <ref type="formula">1</ref>.</p><formula xml:id="formula_7">U l a l = f loor U l+1 a l 2<label>(2)</label></formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Returning to Arbitrary Parent</head><p>Returning from U l to U j ( j &lt; l) potentially requires different divisions of each element of the index set. To achieve an immediate jump, we must deduce the number of iterations of Eq.(1) that have been performed to each element of the index set. We define a k-by-3 matrix S, which stores the accumulation of the number of axis-splits, for each level. The matrix is formed in a recursive manner. Each row is initialized with the previous row values; S l+1 = S l . This is then followed by altering the vector-component corresponding to the axis a l that splits the l'th level</p><formula xml:id="formula_8">S l+1,a l = S l,a l + 1,<label>(3)</label></formula><p>where S m,n represents the matrix element at the m'th row and n'th column, and</p><formula xml:id="formula_9">S 0 = [0, 0, 0]<label>(4)</label></formula><p>is the initialization vector for the root level. Note that S is formed only once during kd-tree construction. Thus, storing and accessing this matrix on GPUs can be made quite fast by using cached constantmemory. Given the accumulation matrix S, the current depth l and the depth j of the common-parent node, we can find the numbers of iterations, denoted N, of Eq.(1) applied to each index element between levels j and l as</p><formula xml:id="formula_10">N = S l − S j<label>(5)</label></formula><p>where</p><formula xml:id="formula_11">N = [N x , N y , N z ].</formula><p>Finally, we are able to restore the index-set for the parent node being returned to by altering Eq.(2) to acknowledge the number of power-of-2 multiplications that have been applied (Eq.(5)). Thus, returning to the index-set U j , given U l , is achieved using</p><formula xml:id="formula_12">U j = f loor U l 2 N ,<label>(6)</label></formula><p>where</p><formula xml:id="formula_13">2 N ≡ [2 N x , 2 N y , 2 N z ]</formula><p>. So long as c ≤ 1, Eq.(6) will correctly find the integer indices without having to redetermine c for each level. Also note, all divisions in Eq.(6) are a power-of-two and, therefore, they can be implemented using rightward bit-shifting.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.4">Completing Jump</head><p>Once we have returned to the parent node, we can simply reapply Eq.(1) in order to traverse into the next child. However, the unknown element is the offset c, which we need to apply in order to arrive at the far-child. Assuming a nearest-first traversal ordering, this can be deduced by redetermining whether the first-node is the near-facing node, which is quickly performed by examining the ray direction; such that if r a l ≥ 0 then c = 1 else c = 0. The complete Kd-Jump method is illustrated by <ref type="figure" target="#fig_4">Fig. 5</ref> for a simple two-dimensional case.</p><p>After returning into the next node, the final step is to re-clip the ray to the bounds of the node and recompute the t-near and t-far intervals. The bounds can be computed on-the-fly, which avoids global-memory usage as well. See <ref type="bibr" target="#b24">[25]</ref> for efficient Ray-Bound intersection methods. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.5">Making Return Flags</head><p>Our detailed Kd-Jump mechanism facilitates a return, but does not yet include how much to jump by. To return immediately during the course of ray traversal, we require a flag to specify whether a level along the traversal path has a node that requires testing. One should note that, for the current traversal path, only one possible node will be required to be returned to for each level. As such, we only require a single memory-bit per level to store a possible return. We define a 32-bit integer-register DepthFlags to store these flags. As the typical size of volumes used on GPUs today (without out-of-core methods) is less than 1024 3 , a 32-bit integer can hold the depth-flags. However, 64-bit integers can be utilized to facilitate kd-trees of up-to 64 levels in the future; indeed CUDA devices already provide 64-bit hardware functionality.</p><p>Given the DepthFlags register, we set whether a level should be returned to using bitwise operators; DepthFlags |= 1 (31 − l). Note that we store the bits in most-significant ordering, such that the bitindex of the l'th level is 31 − l. We can determine whether there are return positions by checking if DepthFlags &gt; 0. Assuming that DepthFlags is non-zero, finding the first-set depth flag is akin to counting the consecutive number of zero-bits, starting from the leastsignificant bit; we denote this operation CountBits. Hence, the actual depth j to return to is 31 −CountBits(DepthFlags). Upon a successful return to a level, it is important to clear the j'th level flag bit to zero; again using bit manipulation. In CUDA CountBits can be accomplished using the built-in function f f s (however it is offset by plus 1). For an alternative to CUDA's f f s, see <ref type="bibr" target="#b0">[1]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">FASTER TRAVERSAL WITH HYBRID KD-JUMP</head><p>An acceleration method for ray-tracing serves one primary purpose of removing the extraneous memory access affiliated with empty or invalid space. However, it is entirely possible that an acceleration method might under-perform or even perform worse than a brute-force raytracer, for example, when the acceleration method is complex or is utilized for too long. Thus, it is very important to be able to determine when and where an acceleration method is useful. For this purpose, we present hybrid traversal and dynamic update.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Hybrid Traversal</head><p>Each node in a kd-tree represents a sub-region of the complete volume. With each level of the kd-tree, this region is made ever smaller until a node represents a single voxel on the final level. We employ a simple method, whereby we introduce a real-time depth threshold parameter to the traversal kernel. Once rays traverse past this threshold, we switch to the volume stepper and iteratively step along the ray from t near to t f ar . The volume stepping is performed until the isosurface is crossed, or until t f ar is reached, after which a return is issued. See <ref type="figure" target="#fig_5">Fig. 6(a)</ref>.</p><p>The purpose of this hybrid system is two-fold; firstly, to gain the benefit of the fast texture-cache and, secondly, to allow the adjustment of the threshold in order to maximize the usefulness of the kd-tree. Although combining an acceleration structure with volume stepping methods is not entirely new, we present it here in order to show that a kd-tree can perform well and can be adjusted easily for dynamic situations.</p><p>By building a complete kd-tree and then introducing a run-time depth threshold we can alter the threshold during raytracing in order to find the optimism setting. For instance, the optimal threshold is subject to several factors, primarily the volume size, the complexity of the data itself, the isosurface location and the view direction. Further, if the volume stepping distance is reduced, say to acquire better intersection results while zoomed in, then a larger threshold (traversing further down the kd-tree) would be more efficient.</p><p>Also, the threshold depends on the complexity of the datainterpolation being performed. If tri-linear interpolation is used, it would be more beneficial to switch to the volume stepper sooner. However, if tri-cubic interpolation is used, as is the case for discrete binary-volume rendering <ref type="bibr" target="#b11">[12]</ref>, then there is far more incentive for the kd-tree to traverse for as long as possible, because of the lack of hardware acceleration. The same argument applies for complex intersection methods such as the correct root finding method <ref type="bibr" target="#b17">[18]</ref>. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Dynamic Update</head><p>With Wald's original implicit kd-tree, each node contained a min/max pair; the minimum and maximum values within the region represented by the node. As we have described in the previous section, we load both child min/max pairs prior to traversal into children. Hence, during traversal, these two sets of values must be loaded from memory. For 8-bit data, this requires a 32-bit transaction while, for 16-bit data, the size of the node is 64-bits. The cost of loading this data, plus the cost of comparing the node value range with the target isosurface, may add additional complexity. A better alternative is to move the node validity test out of the traversal stage and into the kd-tree update stage. Thus, instead of a node having two min/max pair's for each child, it simply has two boolean bits to specify if the children are currently valid for traversal. Upon a change in isovalue, this would require updating every node on every level starting from the original volume itself. This is already quite fast (less than 0.25 seconds) for 512 <ref type="bibr" target="#b2">3</ref> volumes, even with a naive implementation. Much of this efficiency can be attributed to CUDA's cached texture-access, which not only applies to accessing three-dimensional volume, but also accessing the node data. See <ref type="figure" target="#fig_5">Fig. 6(b)</ref>.</p><p>With hybrid traversal, several deep-levels of the kd-tree may be avoided all together. We show, in the results, that the deeper levels are not particulary useful in our implementation. Therefore, the dynamic update can be made more efficient by only updating levels of the tree which may be traversed. This can be accomplished by introducing a separate sub-volume of min/max pairs. This sub-volume would represent the node information for a kd-tree level and would be considered the absolute cutoff depth. During traversal, the cutoff depth would have to override the depth threshold if the later is greater.</p><p>Choosing whether to employ node-conditions or traversalconditions depends on several factors. If memory size is an issue, or the isovalue is changed irregularly, then node-conditions would be more suited. In contrast, if the isovalue is altered every frame, then traversal-conditions would be better suited.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">RESULTS</head><p>We performed several comparative tests and recorded the timing information for the kernels using CUDA's high-resolution timers. The results presented here where averaged over multiple passes. <ref type="table" target="#tab_0">Table 1</ref> gives the results for the average frames-per-second (FPS) spanning a wide range of the isosurfaces and multiple view directions for the test data. Memory usage is an important factor for GPUs, due to limited resources. We show the typical memory usage in <ref type="table" target="#tab_0">Table 2 for a 1024 2</ref> screen, as would be the case with single ray-tracing kernel. The table shows a stack requires considerable amount of global memory to accommodate all rays, while Kd-Jump requires only a small matrix in fast constant-memory. Although kd-restart uses the least resources, the redundant node visitation severely reduces performance as shown in <ref type="table" target="#tab_0">Table 1</ref>.</p><p>To further compare the performance of Kd-Jump, we evaluate the theoretical performance, as shown in <ref type="figure" target="#fig_6">Fig. 7</ref>. In this evaluation, we only test the relevant code to store and retrieve a return position. We set up a kernel with 1024 2 threads organized into 128-thread blocks to achieve full occupancy. Both the stack and Kd-Jump kernels were tasked with storing and then retrieving n number of returns. The results clearly shows that Kd-Jump potentially has considerable speed gains. When cross-referenced with <ref type="table" target="#tab_0">Table 1</ref>, however, it is evident the gains of Kd-Jump over stack, in a complete ray-tracer, are not as great. We believe that it is due to the fact the memory accesses in the stack kernel are better hidden by the other computation (general loop, ray splitting and leaf testing). between stack and Kd-Jump for increasing number of returns. 1024 2 threads perform n storages and then n returns. We can test both the Kd-Jump and stack-based kernels with different settings for the core and memory frequencies, as shown in <ref type="figure" target="#fig_7">Fig. 8</ref>. This allows us to examine which factor (computation or memory access) is limiting performance for each kernel. The results clearly show that Kd-Jump is computationally limited while the stack-based approach is memory limited. This quick test can also be quite useful during development and implementation of raytracing kernels, as it can indicate which factors should be optimized.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Limiting Factors</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Hybrid Kd-Jump</head><p>In order to gain in performance as much as possible and thus give merit for using a kd-tree in the first place, we present a comparison of a hybrid kd-tree kernel (using our Kd-Jump method) versus a pure brute-force raytracing kernel. While these kernels are not optimized particulary well, both share the same code for stepping through the volume and detecting an isosurface crossing.</p><p>For the Hybrid Kd-Jump kernel, we have incorporated a number of optimizations, specifically the hybrid traversal and dynamic update described in section 4.1 and 4.2. In addition, the Hybrid Kd-Jump kernel accesses node information from the texture cache rather than directly from global memory. <ref type="table">Table 3</ref> shows the results for Hybrid Kd-Jump versus a brute-force volume-stepper; showing multiple isosurfaces, data-sizes and screen sizes. Of note are the cases where brute-force outperforms Hybrid Kd-Jump. In these cases, two conditions are (always) present. Firstly, the isosurface covers much of the screen and secondly, the isosurface is close to the bounds of the data. Hence, a simple volume stepper only operates for a short period of time before detecting an isosurface. With more complex isosurfaces, longer distances from the bounds to the isosurface and larger screen resolutions, however, brute force is slower than Hybrid Kd-Jump. <ref type="figure">Fig. 9</ref> shows the performance change for various threshold values and indicates the degree to which using a kd-tree is beneficial. <ref type="figure">Fig. 9</ref>: FPS for Aneurism (512 3 ) using Hybrid Kd-Jump (with dynamic-update) in 512 2 and 1024 2 screen resolutions, over all thresholds. Threshold of 1 is a special case where a pure volume-stepper kernel is used. Last threshold represents a complete downward traversal of kd-tree. It clearly shows that Hybrid Kd-Jump is able to remove empty space and gain in performance by reducing redundant traversal steps into deeper levels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Multiple Rays Per Thread</head><p>A bottleneck affecting all methods can occur when only one thread of a warp is active, or only one warp of a block is so. If CUDA allocates a block worth of resources (shared memory, registers) and operates that block until completion, it is logical to assume that, if only one warp is actually active, then the three remaining inactive warps will actually limit computation throughput.</p><p>We can test this by altering the kernel to include an outer-loop, whereby new rays are loaded and initialized, once a warp has finished. It is doubtful that loading a new ray when a single-thread terminates will be effective. Indeed, during our initial development, loading a new ray when each thread terminated induced much slower performance. We believe that this is due to the result of more code-branching during traversal, as well as the removal of the initial ray coherence. On the other hand, a warp terminates when all threads terminate. Thus loading a new batch of rays across the 32 threads of the warp will maintain the initial coherency of a group of rays while ensuring that as many warps are active throughout the lifetime of the kernel. We implement the multiray kernel as an extension of the Kd-Jump kernel. As seen in <ref type="figure" target="#fig_8">Fig. 10</ref>, we show positive benefits.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.4">Separating Kernels</head><p>The basic approach to parallel ray tracing is to dedicate one thread per ray and to develop a single-kernel containing the entire rendering pipeline; node traversal, leaf testing and pixel shading. However, as a single-kernel, the pipeline will not fully exploit the GPU and may well indeed create performance bottlenecks. For instance, shading is a <ref type="table">Table 3</ref>: FPS for Hybrid Kd-Jump versus brute-force averaged across multiple views per isovalue. Hybrid threshold is chosen to maximize performance in each case.</p><p>It clearly shows that Hybrid Kd-Jump outperforms a brute-force volume-stepper for most cases. The volume-stepping is faster only when there is very little empty space and the isosurface is found quite quickly (i.e., close to the bounds of the data).  branchless process and hence should perform very well in parallel. In a single-kernel ray tracer, however, some threads may begin shading prior to others,; this causes thread divergence and serialization events. Thus, separating out the shading portion (as well as other portions) of the pipeline and placing it in a different kernel should result in better performance, at least in theory <ref type="bibr" target="#b19">[20,</ref><ref type="bibr" target="#b21">22]</ref>. That being said, launching multiple kernels can carry an overhead. <ref type="figure" target="#fig_9">Fig. 11</ref> shows this theory has at least some merit. However, the performance improvement is small and only attained if a lot of shading occurs to begin with; the rendering of lower isovalues occupy a large portion of the screen. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">DISCUSSION</head><p>CUDA devices contain multiple processing units. Each processing unit is capable of operating many threads in parallel, although only a small number (a warp) actually work at any given moment. Currently, CUDA devices operate warps of 32 threads in size. With branchless code, all threads in a warp operate the same instruction of code and fully utilize the SIMD (Single Instruction, Multiple Data) functionality. If conditional branching occurs, then the threads branching into the statement are evaluated first and any thread not following the branch is masked inactive and forced to wait. Once the branch is evaluated, a serialization occurs and threads in the warp are re-synchronized automatically. Apart from the fact that divergent branching and serialization incurs slowdown, the SIMD functionality might not be used to the fullest. Also, note that SIMD efficiency is dependent on limited code-branching and not necessarily ray-coherence. Currently, a maximum number of 1024 threads can be active on each multi-processor. While only a single warp (group of 32 threads) ever works at any given moment for a multi-processor, CUDA is able to switch between warps waiting for instructions to complete and effectively ensure maximum throughput. For example, if one warp requests global memory, it will essentially have to wait for that request to complete and, during that time, other warps can operate. Thus, maximum occupancy ensures that costly instructions (such as memory access) are better hidden and do not pose a bottleneck; this observation can be made by comparing <ref type="figure" target="#fig_6">Fig. 7</ref> and <ref type="table" target="#tab_0">Table 1</ref> where additional computation better masks the memory latency. In <ref type="figure" target="#fig_8">Fig. 10</ref>, we show that further performance improvements can be gained with load-balancing (multiple rays per thread).</p><p>Concern for maximum occupancy should be the first priority for researchers. Device occupancy is determined by two factors, the number of registers and the amount of shared memory used by the kernel. Unfortunately, it makes full occupancy improbable to include the entire traversal pipeline as a single kernel (on current architecture). To achieve full occupancy, without extensive and time-consuming optimization, the traversal mechanism must be separated into multiple kernels.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Multiple Kernels versus Single Kernel</head><p>Separating kernels into multiple stages presents a new challenge; how should we organize the work for them? For example, let us assume that we have an Intersect-Kernel which detects ray-geometry intersections and a Shader-Kernel. Not all rays will have intersections and, therefore, they will not require shading. Cropping out the rays which do not require shading so that we can pass only valid rays to the Shader-Kernel requires an intermediate step to organize the memory.</p><p>A simple solution is to have Intersect-Kernel to store a hit-flag specifying whether the ray has hit geometry. A separate kernel can then examine rays to find those with valid hits and create a work-list for the Shade-Kernel. This approach can also be performed in parallel (as a minimizing problem <ref type="bibr" target="#b6">[7]</ref>), where each thread is responsible for checking the state of a set number of rays. Regardless of how it is implemented, however, the additional step to organize the work requires extra computation and memory access, and is therefore only useful if the benefit outweighs this cost.</p><p>Simply separating kernels without organization of the input workload, for the shading kernel (i.e., simply having 1 thread per pixel), is shown in <ref type="figure" target="#fig_9">Fig. 11</ref>. However, what remains to be seen is whether it is possible to reorganize workload between kernel calls, without it becoming a bottleneck in itself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Alternative To Accumulation Matrix</head><p>The accumulation matrix approach, while simple, still requires constant-memory for storage. Different architectures may not provide fast caching features. An alternative to the accumulation matrix is to utilize more registers; one per-dimension. Each bit represents a level of the kd-tree. We store a TRUE, in the relevant register, to specify whether a dimension has been split on a particular level. The registers would be propagated with the correct split information during the kd-tree build stage, or actually during traversal.</p><p>Determining N of Eq.(5) using the accumulation registers involves counting the number of TRUE bits between the current depth and the return depth. Firstly, this requires masking the accumulation registers for only the levels in question and a bit-counter. In CUDA, this can be achieved using the popc function (see <ref type="bibr" target="#b0">[1]</ref> for an alternative).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">Limitations and Scope of Kd-Jump</head><p>While Kd-Jump exploits the indexing method for implicit kd-trees, pointers are used for general kd-trees. As such, Kd-Jump in the current form cannot be readily used for a general kd-trees. In order to apply Kd-Jump to a general tree, one should be able to transpose a general kd-tree onto a "virtual" balanced kd-tree and build a suitable memory map to reference node data. In practice, however, any additional computation for the map could lower the performance.</p><p>When Kd-Jump is employed for isosurface ray-tracing or direct volume rendering, the traversal-orders are pre-defined and are quickly recomputed upon return. For MIP (Maximum Intensity Projection) rendering, however, redetermining the traversal-order would require additional memory look-ups and testing, which could lower the performance.</p><p>The Kd-Jump approach would be applicable for use with other binary trees, if nodes can be referenced with indices and index-updates can also be invertible. In theory, this approach could be used with BVH <ref type="bibr" target="#b15">[16]</ref> if indices are employed and a sufficient method for mapping the indices to memory (without excess) is available. Since a BVH is not a spatial-splitting structure, tree-balancing is applicable.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">CONCLUSION</head><p>We have presented Kd-Jump, a stackless traversal of implicit kd-trees for faster isosurface raytracing. We have shown that Kd-Jump can outperform both stackless and stack-based approaches, while only needing a fraction of memory compared to a stack-based approach. Further, Kd-Jump exploits the index-based referencing used for implicit kd-trees to achieve traversal-paths equivalent to a stack-based method, without incurring the extra node visitation of kd-restart.</p><p>To further strengthen kd-tree, we have introduced Hybrid Kd-Jump. Hybrid Kd-Jump utilises a volume stepper for leaf testing and a runtime depth threshold to define where kd-tree traversal stops and volume stepping occurs. By using both methods we gain the benefits of empty-space removal and hardware-based texture interpolation. We have shown that Hybrid Kd-Jump performs well at removing empty space and can outperform a brute-force ray-tracer.</p><p>Memory usage for an implicit kd-tree may be too large if min/max pairs are stored in each node. We have shown that, if the conditions for the current isosurface are moved out of traversal and into the tree nodes themselves, then significantly less memory is required. In addition, even with a naive implementation, updating the implicit kd-tree for a large volume was shown to be quite fast.</p><p>We have shown the usefulness of loading new rays once a warp of threads completes and report that such an approach yields promising results for faster raytracing. We also discussed and examined the separation of the ray-tracing pipeline into separate kernels, and showed that the methodology has some promise for better efficiency.</p><p>Further information, including source code, is available at <ref type="bibr" target="#b10">[11]</ref>.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>•</head><label></label><figDesc>David M. Hughes is with the School of Computer Science, Bangor University, UK. (meirion@bangor.ac.uk). • Ik Soo Lim is with the School of Computer Science, Bangor University, UK. (i.s.lim@bangor.ac.uk). Manuscript received 31 March 2009; accepted 27 July 2009; posted online 11 October 2009; mailed on 5 October 2009.For information on obtaining reprints of this article, please send email to: tvcg@computer.org .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 :</head><label>2</label><figDesc>Schematic illustration of additional nodes tested to achieve a correct return among different approaches. Kd-Jump does not need to re-test previously visited nodes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 :</head><label>3</label><figDesc>Wald's  </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 :</head><label>4</label><figDesc>The three cases of traversal. Left: the ray-plane intersection distance t d is within the ray segment (t near , t f ar ), Center: the ray segment lies completely on the near side of the split plane, Right: the ray segment lies completely on the far side of the split plane.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 5 :</head><label>5</label><figDesc>A two-dimensional example illustrating the two-stage process of finding the indices of the next node to test.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig. 6 :</head><label>6</label><figDesc>(a) Hybrid Traversal (b) Dynamic Update With hybrid traversal, the kd-tree is traversed until a variable threshold is met after which volume stepping occurs. With Dynamic update, nodes are updated with binary conditions as to whether children contain any part of the target isosurface.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 7 :</head><label>7</label><figDesc>Theoretical performance (number of computations possible per second)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 8 :</head><label>8</label><figDesc>FPS for Kd-Jump and stack traversal with different core frequency and memory frequency settings, rendering Foot (256 3 ) with 512 2 resolution. It shows that Kd-Jump is computationally limited whereas stack is memory-latency limited.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 10 :</head><label>10</label><figDesc>The results for loading multiple-rays per-thread once a warp terminates.Balancing workload (i.e., keeping warps are active as long as possible) can improve performance.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 11 :</head><label>11</label><figDesc>The difference in FPS (%) between separate kernels and the whole Kd-Jump kernel. For each isovalue, FPS is averaged over different views. It shows that the separate kernels lead to only a minor improvement.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Average FPS across multiple views and multiple isovalues. Bonsai, Foot and Skull are of 256 3 in size while Aneurism is of 512 3 .</figDesc><table><row><cell></cell><cell></cell><cell>512 2</cell><cell></cell><cell></cell><cell>1024 2</cell><cell></cell></row><row><cell></cell><cell>stack</cell><cell>kd-restart</cell><cell>Kd-Jump</cell><cell>stack</cell><cell>kd-restart</cell><cell>Kd-Jump</cell></row><row><cell>Bonsai</cell><cell>58.3</cell><cell>34.2</cell><cell>65.6</cell><cell>17.3</cell><cell>10.0</cell><cell>18.9</cell></row><row><cell>Foot</cell><cell>43.1</cell><cell>25.7</cell><cell>48.8</cell><cell>12.3</cell><cell>7.2</cell><cell>13.6</cell></row><row><cell>Skull</cell><cell>52.9</cell><cell>32.1</cell><cell>59.7</cell><cell>15.5</cell><cell>7.1</cell><cell>16.8</cell></row><row><cell>Aneurism</cell><cell>42.9</cell><cell>25.5</cell><cell>50.2</cell><cell>11.7</cell><cell>6.5</cell><cell>12.9</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Memory usage (per kernel) for traversal schemes with 1024 2 screen resolution and maximum depth of 27. It assumes that CUDA will allocate all device memory for all threads (rays). Kd-Jump needs only a small amount of constantmemory (cached) and no device memory, while a stack requires a considerable amount of device memory.</figDesc><table><row><cell></cell><cell>stack</cell><cell>kd-restart</cell><cell>Kd-Jump</cell></row><row><cell>Device</cell><cell>405MB</cell><cell>0</cell><cell>0</cell></row><row><cell>Constant</cell><cell>0</cell><cell>0</cell><cell>0.0003MB</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">ACKNOWLEDGMENTS</head><p>We thank the anonymous reviewers for the helpful comments and constructive criticism and Catrin Plumpton for helpful discussion. This work is in part supported by the Leverhulme Trust (grant no. F/00 174/L) and the HEFCW (Higher Education Funding Council for Wales).</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Bit twiddling hacks</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Anderson</surname></persName>
		</author>
		<ptr target="http://graphics.stanford.edu/sean-der/bithacks.html" />
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Illustrative contextpreserving volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Bruckner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Grimm</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kanitsar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Gröller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proc. EuroVis</title>
		<imprint>
			<biblScope unit="page" from="69" to="76" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Gigavoxels : Rayguided streaming for efficient and detailed voxel rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Crassin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Neyret</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lefebvre</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Eisemann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symp. Interactive 3D Graphics and Games</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="15" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">High-quality pre-integrated volume rendering using hardware-accelerated pixel shading</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Engel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kraus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Graphics hardware</title>
		<meeting>Graphics hardware</meeting>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="9" to="16" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Kd-tree acceleration structures for a gpu raytracer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Foley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sugerman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">HWWS &apos;05: Proc. Graphics Hardware</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="15" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A single-pass GPU ray casting framework for interactive out-of-core rendering of massive volumetric datasets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Gobbetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Marton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Iglesias Guitián</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">7</biblScope>
			<biblScope unit="page" from="797" to="806" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A memory model for scientific algorithms on graphics processors</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Govindaraju</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Larsen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE/ACM Supercomputing</title>
		<meeting>IEEE/ACM Supercomputing</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="89" to="99" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Fast implicit kd-trees: Accelerated isosurface ray tracing and maximum intensity projection for large scalar fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Grob</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lojewski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bertram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hagen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Computer Graphics and Imaging</title>
		<meeting>Computer Graphics and Imaging</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="67" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Gpu-based object-order ray-casting for large datasets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Hong</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Qiu</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="177" to="240" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Interactive kd tree GPU raytracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Horn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Sugerman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Houston</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Interactive 3D graphics and games</title>
		<meeting>Interactive 3D graphics and games</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="167" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Kd-jump sourceforge project</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Hughes</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">S</forename><surname>Lim</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Tricubic interpolation of discrete surfaces for binary volumes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kadosh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Cohen-Or</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Commercezone</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Jerusalem</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Transactions on Visualization and Computer Graphics</title>
		<meeting>IEEE Transactions on Visualization and Computer Graphics</meeting>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="580" to="586" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Interactive ray tracing of arbitrary implicits with simd interval arithmetic</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Knoll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Hijazi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Wald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hagen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. on Interactive Ray Tracing</title>
		<meeting>IEEE Symp. on Interactive Ray Tracing</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="11" to="18" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Coherent multiresolution isosurface ray tracing. The Visual Computer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Knoll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Wald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="209" to="225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Interactive isosurface ray tracing of large octree volumes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Knoll</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Wald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Symp. on Interactive Ray Tracing</title>
		<meeting>IEEE Symp. on Interactive Ray Tracing</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="115" to="124" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Fast BVH Construction on GPUs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Lauterbach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Garland</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Sengupta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Luebke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Manocha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="375" to="384" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Marching cubes: A high resolution 3D surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Computer graphics and interactive techniques</title>
		<meeting>Computer graphics and interactive techniques</meeting>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="page" from="163" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Fast and accurate ray-voxel intersection techniques for iso-surface ray tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Marmitt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Friedrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kleer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Wald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Slusallek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Vision, Modeling, and Visualization (VMV)</title>
		<meeting>Vision, Modeling, and Visualization (VMV)</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="429" to="435" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Interactive Ray Tracing for Volume Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Parker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Livnat</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sloan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="238" to="250" />
			<date type="published" when="1999" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Perfect load balancing for demand-driven parallel ray tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Plachetka</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Lecture Notes in Computer Science</title>
		<imprint>
			<biblScope unit="page" from="410" to="419" />
			<date type="published" when="2002" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Stackless kd-tree traversal for high performance GPU ray tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Popov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Günther</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-P</forename><surname>Seidel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Slusallek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics Forum</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="415" to="424" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<monogr>
		<title level="m" type="main">Hybrid scheduling for efficient ray tracing of complex images. High Performance Computing for Computer Graphics and Visualisation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Reinhard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">W</forename><surname>Jansen</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1995-07" />
			<biblScope unit="page" from="78" to="87" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Importance-driven volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Viola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kanitsar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Groller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. IEEE Visualization</title>
		<meeting>IEEE Visualization</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="139" to="145" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Faster isosurface ray tracing using implicit kd-trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><surname>Wald</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Friedrich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Marmitt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-P</forename><surname>Seidel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="562" to="572" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<analytic>
		<title level="a" type="main">An efficient and robust ray-box intersection algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Barrus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Morley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of graphics tools</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="49" to="54" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
