<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Loop Surgery for Volumetric Meshes: Reeb Graphs Reduced to Contour Trees</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Julien</forename><surname>Tierny</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Attila</forename><surname>Gyulassy</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eddie</forename><surname>Simon</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><roleName>Member, IEEE</roleName><forename type="first">Valerio</forename><surname>Pascucci</surname></persName>
						</author>
						<title level="a" type="main">Loop Surgery for Volumetric Meshes: Reeb Graphs Reduced to Contour Trees</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:54+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Reeb graph</term>
					<term>scalar field topology</term>
					<term>isosurfaces</term>
					<term>topological simplification</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Fig. 1. The Reeb graph of a pressure stress function on the volumetric mesh of a brake disk is shown at several scales of hypervolumebased simplification. At the finest resolution of this data-set (3.5 million tetrahedra), our approach computes the Reeb graph in 7.8 seconds while the fastest previous techniques [19, 12] do not produce a result.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>As scientific data becomes larger and more complex, sophisticated techniques are required for its effective analysis and visualization. Topology-based methods are particularly useful in this context due to their ability to capture features directly, and interact with them at multiple resolutions. Reeb graphs are an efficient solution that encodes the behavior of level sets of scalar functions defined on manifold meshes of arbitrary topology, and therefore their efficient computation is an important challenge. In this paper, we present a new algorithm that computes Reeb graphs in an efficient manner, to enable in-practice use of the Reeb graph for various visualization and analysis tasks.</p><p>Topology-based techniques are becoming more common to solve complex visualization and data analysis challenges. In particular, the contour tree <ref type="bibr" target="#b9">[10]</ref> is now commonly recognized as an efficient solution to capture the structure of scalar fields. Thanks to simple, robust and fast algorithms <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b6">7]</ref>, it has a wide spectrum of applications, including seed-set computation for fast isosurface extraction <ref type="bibr" target="#b23">[24]</ref>, topologically clean isosurface extraction <ref type="bibr" target="#b7">[8]</ref>, feature-extraction <ref type="bibr" target="#b3">[4]</ref>, featuredriven visualization metaphors <ref type="bibr" target="#b25">[26]</ref>, and automated transfer function design <ref type="bibr" target="#b26">[27]</ref>. Algorithms for computing the contour tree <ref type="bibr" target="#b22">[23,</ref><ref type="bibr" target="#b6">7]</ref> require the scalar-valued data to be defined on a simply connected domain (a very restrictive topological constraint), but many scientific experiments and computer-aided design simulations do not meet this requirement. Then, the more general notion of Reeb graph <ref type="bibr" target="#b20">[21]</ref> is needed. Only a few algorithms exist for computing Reeb graphs on volumetric meshes, and they are computationally expensive and therefore not practically applicable for use in interactive applications.</p><p>This paper presents an algorithm to compute Reeb graphs on volumetric meshes in R 3 (in particular tetrahedral meshes) that runs in practice with the same efficiency as a contour-tree algorithm, enabling the practical generalization of contour tree based visualization techniques to meshes of arbitrary topology. Our approach is based on the key concept of loop surgery, inspired from surgery theory <ref type="bibr" target="#b24">[25]</ref>. In particular, we transform the input domain by a sequence of symbolic cuts such that the Reeb graph of the input scalar field defined on the transformed domain is guaranteed to be loop free, and hence computable with efficient contour tree algorithms. Then, some inverse symbolic cuts are performed in the topology domain to convert the computed contour tree into the Reeb graph of the original scalar field. We show that these symbolic cuts can be computed in an efficient manner, with reasonable computation overhead with respect to contour tree computation. Extensive experiments show that for volumetric meshes our approach is orders of magnitude faster than state-of-the-art techniques, while maintaining a smaller memory footprint, as shown by the largest experiments. To demonstrate the potential of our approach, we picked a contour tree based visualization technique and extended it to volumetric meshes of arbitrary topology while still maintaining its interactive appeal. In particular, we implement an algorithm for fast topologically-clean isosurface extraction, and apply it in the context of pressure analysis for mechanical design. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Related work</head><p>A preliminary contour tree algorithm was introduced by de Berg and van Kreveld <ref type="bibr" target="#b9">[10]</ref>. Extending the previous work by Tarasov and Vyalyi <ref type="bibr" target="#b22">[23]</ref>, Carr et al. <ref type="bibr" target="#b6">[7]</ref> presented a very elegant, simple, robust and fast algorithm for contour tree computation on simply connected simplicial complexes of arbitrary dimension, hereafter called the join-split algorithm. This approach implicitly exploits the fact that, over simply connected domains, the topological evolution of the connected components of the sub-and sur-level sets of the input field captures all the information about that of the connected components of level sets. Consequently, level-set connectivity tracking is efficiently achieved by only keeping track of the connectivity of the sub-and sur-level sets with a computationally inexpensive Union-Find data structure. The O(n log n + Nα(N)) complexity of the join-split algorithm can be proven to be optimal for computing contour trees. The relationship between the topology of the sub-and sur-level sets and that of level sets no longer holds on domains of arbitrary topology. This remark motivates research for efficient Reeb graph computation algorithms.</p><p>Approximation algorithms exist for computing Reeb graphs based on image domain regular partitioning <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b15">16,</ref><ref type="bibr" target="#b27">28]</ref>, but they can lead to inaccurate results due to dependence on sampling rates or thresholds. The first combinatorial algorithm for Reeb graph computation on PL 2-manifolds was introduced by Shinagawa and Kunii <ref type="bibr" target="#b21">[22]</ref>, with an O(n 2 t ) time complexity where n t stands for the number of triangles in the mesh. Cole-McLaughlin et al. <ref type="bibr" target="#b8">[9]</ref> introduced an optimal algorithm for PL 2-manifolds, with O(n e log(n e )) time complexity (where n e is the number of edges) by taking advantage of the mono-dimensionality of level sets in the special case of PL 2-manifolds by maintaining them dynamically in a sorted representation. Since it can be computed efficiently for PL 2-manifolds, the Reeb graph has been a very popular shape abstraction for several computer graphics tasks, such as surface parameterization <ref type="bibr" target="#b28">[29]</ref>, shape retrieval <ref type="bibr" target="#b15">[16]</ref>, character animation <ref type="bibr" target="#b2">[3]</ref>, and others. We defer the reader to <ref type="bibr" target="#b5">[6]</ref> for a comprehensive survey on the applications of Reeb graphs in shape modeling.</p><p>Many properties of two-dimensional domains exploited by the above algorithms do not hold for three-dimensional domains, making the problem more challenging. There are only a few techniques for the computation of Reeb graphs in higher dimensions and thus usable for volumetric meshes. Pascucci et al. <ref type="bibr" target="#b18">[19]</ref>, presented a streaming approach taking as an input streamed meshes of arbitrary dimension. Due to its intrinsic ability to handle non-manifold meshes, the algorithm computes Reeb graphs by considering the restriction of the input field to the 2-skeleton of the mesh, whose Reeb graph is proved to equal that of the original field. However, isosurfaces have to be maintained, and since no natural order is possible for two-dimensional level sets (unlike the case of triangular meshes <ref type="bibr" target="#b8">[9]</ref>), the algorithm exhibits a quadratic worse case time complexity. Doraiswamy and Natarajan <ref type="bibr" target="#b12">[13]</ref> proposed an extension of Cole-McLaughlin et al.'s approach <ref type="bibr" target="#b8">[9]</ref> to three-dimensions by dynamically maintaining isosurfaces with a complex data structure based on a spanning tree, resulting in a time complexity of O(n t log 2 n t ), where n t is the number of triangles in the mesh. They showed that an implementation with a lighter data structure performed better in practice despite a complexity of O(ng log 2 n), where g is the maximum genus of an isosurface. The same authors also introduced recently another algorithm <ref type="bibr" target="#b11">[12]</ref> with improved practical performance, which extends a previous approach <ref type="bibr" target="#b19">[20]</ref> from surface to tetrahedral meshes. In <ref type="bibr" target="#b11">[12]</ref>, the authors adapt image domain regular partitioning techniques by partitioning the domain precisely along critical level sets and deducing the Reeb graph from the domain partition. With practical fields studied in scientific visualization or computer-aided design simulations, the number of critical points is often linear with the number of vertices in the mesh, and the size of the partition boundaries can also be proportional to the number of tetrahedra, resulting rapidly in a quadratic run-time behavior in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Contributions</head><p>This paper makes the following new contributions:</p><p>1. We introduce a new procedure called loop surgery to reduce the problem of computing a Reeb graph to that of a contour tree. We believe this is an important result, since the join-split algorithm <ref type="bibr" target="#b6">[7]</ref> for computing contour trees is well known to have not only optimal theoretical complexity, but also simple and practical implementation. 2. We describe a practical algorithm for computing <ref type="bibr">Reeb graphs</ref> with complexity O(n log n + gN). For practical examples, g, which is equal to the number of handles of the domain, is a small constant, and systematic experiments show a speedup over previous algorithms by several orders of magnitude on average. 3. We provide a proof showing necessary and sufficient conditions for a loop free Reeb graph to be computed correctly by the joinsplit contour tree algorithm. 4. We extend topologically-clean isosurface extraction to volumetric meshes of arbitrary topology, and apply it in the context of mechanical design, where it enables a direct visualization of the major trends of physical simulations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PRELIMINARY RESULTS</head><p>In this section, we briefly describe the formal setting of our approach and present some preliminary results on the topology of Reeb graphs on tetrahedral meshes. We defer the reader to <ref type="bibr" target="#b16">[17]</ref> and <ref type="bibr" target="#b14">[15]</ref> for reference books on Morse theory and homology.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Background and definitions</head><p>Consider a real-valued function f : M → R defined on a manifold M.</p><p>One fundamental way to study the function f is to extract its level sets. For a given scalar w the level set L(w) is defined as the inverse image of w onto M through f , L(w) = f −1 (w). We call each con- A retraction is defined <ref type="bibr" target="#b14">[15]</ref> as a continuous map such that its image is a subset of the domain and the restriction of the map to the image is the identity. We define a contour retraction of a manifold M under a function f to be a continuous map that retracts each contour (connected component of level set) to a single point. Notice that, by continuity, adjacent contours are retracted to adjacent points; distinct contours are retracted to distinct points. This gives the definition:</p><p>The Note that f can be decomposed into f = ψ •φ , where φ : M → R( f ) is a contour retraction that maps points in the same contour of f to the same point of R( f ), and ψ : R( f ) → R is a continuous function that maps points of R( f ) to a scalar value in R.</p><p>Consider the case where the domain of f : M → R is a simplicial complex with boundary, with n vertices and N simplices. Within each simplex of M, the function f is the linear interpolation of its values at the vertices, and we say that f is a piecewise-linear (PL) function. The following operations on a simplicial complex M are used to identify critical points. The star of a simplex u is the set of simplices that contain u as a face: St(u) = {σ ∈ M|u ≤ σ }, where u ≤ σ denotes that u is a face of σ . The link of the simplex u is the set of simplices in the closure of the star of u that are not also in its star, i.e., Lk(u) = St(u) − St(u), where St denotes the closure of the star. In PL functions, critical points can only occur at vertices. The lower link of u is the subset of the link containing only simplices with all their vertices lower in function value than u:</p><formula xml:id="formula_0">Lk − (u) = {σ ∈ Lk(u)| v ≤ σ → f (v) &lt; f (u)}. Symmetrically, the up- per link is Lk + (u) = {σ ∈ Lk(u)| v ≤ σ → f (u) &lt; f (v)}. Similarly, the lower star of u is St − (u) = {σ ∈ St(u)| v ≤ σ → f (v) &lt; f (u)}. A vertex u in M</formula><p>is regular if and only if both Lk − (u) and Lk + (u) are simply connected, otherwise u is a critical point of f (notice that both must be simply connected since M has a boundary).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Loops in Reeb graphs on PL 3-manifolds in R 3</head><p>Consider a scalar function f defined on a PL 3-manifold mesh M in R 3 . The key idea of loop surgery is to define a sequence of operations that transform M to M with f : M → R valued by f such that R( f ) becomes loop-free, and then efficiently computable with contour tree algorithms. Therefore, we carefully characterize the loops (independent cycles) of R( f ) prior to introducing loop surgery.</p><p>Let ∂ M be the boundary of M. Since M is compact and embeddable in R 3 , ∂ M is necessarily non-empty, orientable and closed <ref type="bibr" target="#b10">[11]</ref> but possibly disconnected.</p><p>Let f ∂ be the restriction of f to ∂ M. We will first assume that both f and f ∂ are PL Morse functions (degenerate cases will be discussed later). Let R( f ∂ ) be the Reeb graph of f ∂ . Then, we have the following relation <ref type="bibr" target="#b8">[9]</ref>:</p><formula xml:id="formula_1">#loops(R( f ∂ )) = g (1)</formula><p>where g is the sum of the genera of the boundary components of M. The key property that will allow us to implement loop surgery in an efficient manner is the fact than the topology of M is closely related to that of ∂ M. In particular, the number of handles of M is the first Betti number, β 1 (M), which is given by the following relation <ref type="bibr" target="#b10">[11]</ref>:</p><formula xml:id="formula_2">β 1 (M) = g (2)</formula><p>where β 1 (M) is the number of independent 1-cycles in M, formally the rank of the first homology group of M. In simpler words, this relation expresses the fact that each handle of the volume M corresponds to a tunnel of its boundary surface. As discussed in <ref type="bibr" target="#b8">[9]</ref> in any dimension the construction of the Reeb graph can lead to the removal of 1-cycles, but not to the creation of new ones. Therefore, the number of loops of R( f ) cannot be greater than the first Betti number of M : In conclusion, the number of loops of R( f ) cannot be greater than the number of loops of R( f ∂ ) :</p><formula xml:id="formula_3">#loops(R( f )) ≤ β 1 (M) (3) (a) f (M) (b) R( f ) (c) R( f ∂ ) (d) S i (e) M (f) R( f )</formula><formula xml:id="formula_4">#loops(R( f )) ≤ β 1 (M) = g = #loops(R( f ∂ ))<label>(4)</label></formula><p>A direct extension of the equation 4 is the following lemma: Lemma 1. The existence of loops in R( f ) implies the existence of corresponding tunnels in both M and ∂ M, and thus of corresponding loops in R( f ∂ ). The inverse is not necessarily true.</p><p>A result of this lemma is that one can deduce information about the loops of R( f ) by just studying R( f ∂ ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Loop surgery</head><p>When f ∂ is PL Morse, there exists a unique pair of saddle points for each loop, consisting of an "opening" split saddle and a "closing" join saddle. The existence of such pairs is guaranteed by extended persistence <ref type="bibr" target="#b1">[2]</ref>. We uniquely associate each loop with the closing saddle of this pair, and call that saddle a loop saddle. Moreover, by lemma 1, each loop in R( f ) can also be associated with the same loop saddle as the corresponding loop in R( f ∂ ). Notice that some loop saddles of R( f ∂ ) may not be associated with any loop of R( f ).</p><p>Loop surgery consists of transforming the domain M such that R( f ) becomes loop-free. In other words, loop surgery breaks the loops of R( f ) and reflects that transformation on M. Since we have an injection from the loops of R( f ) to the set of loop saddles, it is sufficient to reason only with the loop saddles to achieve these transformations. In particular, for each loop saddle s i with value f (s i ), we define its cutting surface S i as a contour of f (a connected component of isosurface inside the volume) at value f Once the loop-free Reeb graph R( f ) is computed, inverse cuts can be applied in a straightforward manner by removing pairs of minimum and maximum nodes generated by the same cutting surface, and gluing together the corresponding arcs.</p><formula xml:id="formula_5">(s i ) − ε such that f (s i ) − ε</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Loop free Reeb graph computation</head><p>The algorithm presented by Carr et al. <ref type="bibr" target="#b6">[7]</ref> computes the contour tree by tracking the joining of sub-and sur-level set components. Traditionally, simply-connectedness of M has been used as a condition to ensure correctness of this algorithm. However, a Reeb graph can be loop free even when the domain is not simply connected, as shown in figure 3(b). This is especially important, since our loop surgery procedure does not guarantee that the domain is divided into simply connected regions. Therefore, we prove necessary and sufficient conditions for this contour tree algorithm to work. The following lemma shows when a saddle creates a loop in the Reeb graph. Lemma 3 shows that we can use the contour tree algorithm presented by Carr et al. <ref type="bibr" target="#b6">[7]</ref> to compute loop free Reeb graphs, by tracking the connectivity evolution of sub-and sur-level sets. Performing loop surgery guarantees that R( f ) is loop free, and then computable with the contour tree algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">ALGORITHM</head><p>Our algorithm for Reeb graph computation is summarized by the following pseudocode:  The input is a PL function f, and a simplicial mesh M. In lines (1-5), the domain is symbolically cut to ensure that its Reeb graph is loop free. If a diagnostic (line 1) shows that the domain has no handles (section 3.1.1), then no loop surgery needs to be done. Otherwise, loop saddles (section 3.1.2) are detected (line 2), and the domain is symbolically cut (line 4) along cutting surfaces (section 3.1.3). We keep track of the extra pairs of nodes created in the Reeb graph by each cut (line 5). Since the Reeb graph is guaranteed to be loop free, we compute it (line 6) using a modified version of the join-split algorithm (section 3.2). Finally, the loop free Reeb graph is transformed into the correct Reeb graph of the input function by inverse cuts (lines 7-8) (section 3.3).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Loop surgery</head><p>The purpose of loop surgery is to symbolically cut the domain such that R( f ) is guaranteed to be loop free. This procedure corresponds to lines 1-5 of algorithm 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.1">Genus diagnostic</head><p>We first check if any loop surgery is needed by checking the presence of tunnels on the boundary ∂ M. This implements the genus diagnostic function in line 1 of algorithm 1. In particular, we use the Euler formula on each connected component of ∂ M:</p><formula xml:id="formula_6">χ = 2 − 2g = n ∂ v − n ∂ e + n ∂ f<label>(5)</label></formula><p>where n ∂ v , n ∂ e and n ∂ f stand for the numbers of vertices, edges and triangles of the considered component of ∂ M. The sum of the genera g of the connected components of ∂ M then gives the number of tunnels in ∂ M and hence the number of cuts needed to ensure that R( f ) is loop free. Loop surgery is needed only if the sum of the genera is non-zero.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.2">Loop saddles</head><p>If the domain is cut at every loop saddle (defined in section 2.3) then R( f ) is loop free. In this section, we implement find loop saddles in line 2 of algorithm 1. One technique for finding loop saddles is computing the Reeb graph of the boundary (using an existing technique such as <ref type="bibr" target="#b18">[19]</ref>), and then identifying the loop saddles using extended persistence <ref type="bibr" target="#b1">[2]</ref>. However, the benefits of using a simpler technique for finding a small superset of loop saddles outweigh the cost of performing additional cuts.</p><p>By lemma 1, we know that loop saddles must exist as a subset of the saddles on the boundary, therefore, we carefully select these from the set of all saddles of f ∂ in a three-step process: (i) all saddles of f ∂ are identified; (ii) we apply lemma 3 and remove from these the ones that join distinct sub-or sur-level set components; and (iii), we further remove those that do not join the same sub-level set component in the volume. The rules we employ resolve degenerate saddles implicitly. These steps are explained in detail below. (i) Saddles of f ∂ occur at vertices of ∂ M. A vertex x ∈ ∂ M is a saddle if and only if the number of connected components of its lower link is greater than one. This number can be computed by a simple link traversal technique <ref type="bibr" target="#b8">[9]</ref>. The set of all the saddles on the boundary is denoted S ∂ . </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1.3">Cutting surfaces</head><p>We symbolically cut M through a sequence of symbolic cuts, implementing lines (3-5) of the algorithm. According to lemma 3, to ensure that R( f ) be loop free, every saddle must join distinct sub-level set components. A saddle s in S ∂ does not have this property, therefore we perform symbolic cuts on M such that each connected component of the lower link of s has a unique sub-level set component.</p><p>A symbolic cut is an isosurface traversal that updates pointers in the tetrahera that are crossed. A cutting surface S is a simple data structure with a unique identifier that is the record of the symbolic cut. Let s be a saddle of S ∂ with value f (s), and let C i and C j be connected components in Lk − (s). We perform a cut with value f (s) − ε for every pair C i and C j that are on the boundary of the same sublevel set component. We start the traversal at a tetrahedron in the star of s that has a vertex in C i , formally, σ ∈ St(s)|σ ∩ C i = / 0. The sublevel set information necessary to compare C i and C j is found in step (ii) of loop saddle identification (section 3.1.2). We skip components of Lk − (s) that do not touch the boundary. Each symbolic cut produces a new sub-level set component, which is recorded in the cutting surface data structure. For example, if n components of Lk − (s) initially are on the boundary of the same sub-level set component, n − 1 symbolic cuts will be performed.</p><p>To keep track of the symbolic cuts in the rest of the algorithm, each tetrahedron crossed by any cutting surface stores a pointer for each of its vertices to the highest cutting surface passing below and the lowest cutting surface passing above the vertex. Additionally, each vertex is marked with a top flag if it lies above a cutting surface crossing the tetrahedron, and also a bottom flag if it lies below a cutting surface crossing the tetrahedron. Finally, each saddle that generates symbolic cuts stores pointers to the corresponding cutting surfaces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Loop free Reeb graph computation</head><p>By lemma 3, a loop free Reeb graph can be computed using a contour tree algorithm. Since we cut M only symbolically, we use a modified version of the join-split algorithm <ref type="bibr" target="#b6">[7]</ref> that behaves "as if" M were actually transformed into M . Building the loop free Reeb graph using the modified join-split algorithm implements line (8) in algorithm 1.</p><p>The following pseudo-code for computing the join tree simulates the cuts and uses a Union-Find data structure (using path compression and union by rank) implemented to return the highest element of a set.  find and then merge the sets, also adding an arc to the join tree (lines <ref type="bibr" target="#b11">[12]</ref><ref type="bibr" target="#b12">[13]</ref><ref type="bibr" target="#b13">[14]</ref>. This simulates having cut M by S , since it disconnects part of the lower link, and instead connects v to an "artificial" minimum, which is the node returned by the Union-Find. Next, the vertices in the lower link of v that were not disconnected by any cutting surface are processed (lines <ref type="bibr" target="#b14">[15]</ref><ref type="bibr" target="#b15">[16]</ref><ref type="bibr" target="#b16">[17]</ref><ref type="bibr" target="#b17">[18]</ref><ref type="bibr" target="#b18">[19]</ref><ref type="bibr" target="#b19">[20]</ref>. If no tetrahedra in the lower star of v are crossed by a cutting surface (i.e., v did not get marked as top in section 3.1.3 (line 21)) then the lower link of v can be processed (lines <ref type="bibr" target="#b21">[22]</ref><ref type="bibr" target="#b22">[23]</ref><ref type="bibr" target="#b23">[24]</ref><ref type="bibr" target="#b24">[25]</ref><ref type="bibr" target="#b25">[26]</ref> with no changes to the algorithm in <ref type="bibr" target="#b6">[7]</ref>. The join tree of f is returned. The split tree is computed symmetrically, and merging the two trees occurs exactly as in the join-split algorithm. This computes the loop free Reeb graph R( f ).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Inverse cuts</head><p>Transforming the loop-free Reeb graph R( f ) into R( f ) requires gluing minimum-maximum pairs of each cutting surface. This implements lines 7-8 of algorithm 1. For each cutting surface, pointers in the data structure identify the minimum it generated in the join tree and the maximum it generated in the split tree. The two nodes are found in R( f ), and are glued together by concatenating the up-arc of the minimum, and the down-arc of the maximum. This inverts the changes made to R( f ) by loop surgery.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">RESULTS</head><p>We implemented Reeb graph computation based on loop surgery in standard C under GNU/Linux. All the experiments presented below were run on a standard desktop computer with a 64-bit 2.83 GHz CPU and 8 GB of memory. Data-sets are courtesy of the AIM@SHAPE shape repository <ref type="bibr" target="#b0">[1]</ref> and collaborating mechanical design experts.</p><p>In our experiments, we compare running times with recent Reeb graph computation techniques for tetrahedral meshes <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b11">12]</ref>. We used the original implementations of these approaches, kindly provided by their respective authors. Furthermore, we compared the output of our approach to that presented in <ref type="bibr" target="#b18">[19]</ref> using the exact same simulation of simplicity <ref type="bibr" target="#b13">[14]</ref>, and found the two algorithms output identical Reeb graphs for all the available data-sets.  The worst case scenario is reached when both g and N S (loop surgery process) are linear with the size of the mesh, in which case our algorithm has a quadratic complexity. However, with real-life data, g is a small constant, resulting in virtually linear scalability in practice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Time complexity</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Performance Comparison</head><p>We compare the running times of our approach with those of the two fastest previous techniques, presented in <ref type="bibr" target="#b18">[19]</ref> and <ref type="bibr" target="#b11">[12]</ref>. Notice however that these techniques provide a more general solution since they handle meshes of arbitrary dimension. Our approach, instead, has been specifically designed for volumetric meshes embedded in R 3 , given their importance in visualization applications.</p><p>The scalar data used in our experiments represents a variety of physical phenomena: air turbulence, pressure, liquid oxygen diffusion, rock density, etc. <ref type="table" target="#tab_0">Table 1</ref> reports the running times of the three methods on these data. Our approach achieves significant improvement in terms of running time for each data-set, including those with the highest number of handles, resulting in an average speedup factor of 6,500.</p><p>The approaches presented in <ref type="bibr" target="#b18">[19]</ref> and <ref type="bibr" target="#b11">[12]</ref> exhibit a quadratic behavior on real-life volumetric data. The streaming approach <ref type="bibr" target="#b18">[19]</ref> becomes very memory intensive because it has to maintain the boundaries of incomplete level sets, which are represented efficiently only for surface meshes. The memory footprint of the output sensitive approach <ref type="bibr" target="#b11">[12]</ref> is dependent on the number of critical points and the size of their contours, which in real-life data-sets can be prohibitively large. In our loop surgery, instead, it is difficult to reach with real-life data the worst case scenario of the theoretical quadratic complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Loop surgery overhead</head><p>We analyze the internal behavior of our approach and compute the running time overhead due to loop surgery. <ref type="table" target="#tab_1">Table 2</ref> reports the average running times of the individual steps of our approach. The running times agree with our complexity analysis, as the loop surgery overhead increases when the number of handles increases. The pressure field on the trunk data-set ( <ref type="figure" target="#fig_13">fig. 8</ref>) is a special case: it is an extremely noisy field that illustrates that we are performing more symbolic cuts than necessary, due to ambiguities in resolving degenerate critical points. Overall, we observe that the loop surgery overhead is proportional to the cost of computing the contour tree with real-life data.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Asymptotic stress tests</head><p>Finally, we provide a stress test to show the performance of the algorithm in a worst-case scenario. We generate meshes by tetrahedralizing a rectilinear grid on from which rows and columns have been  <ref type="bibr" target="#b18">[19]</ref> and the output sensitive <ref type="bibr" target="#b11">[12]</ref> approaches respectively. On average, the loop surgery processes 428k tets per second, providing a speedup factor of 6,510. The symbol me indicates that the process finished because of a memory exception.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Data</head><p>Tets #H LS SA <ref type="bibr" target="#b18">[19]</ref> OS <ref type="bibr" target="#b11">[12]</ref> Time removed, allowing us to increase the number of tets and the number of handles independently. The function value of each vertex is its y coordinate. <ref type="figure" target="#fig_14">Figure 9</ref> illustrates these meshes. <ref type="figure" target="#fig_7">Figure 10</ref> shows the memory footprint and the running time as a function of the number of handles and the size of the mesh (in logarithmic scale). This experiment shows that for a constant number of handles, our algorithm scales linearly with the size of the mesh (slopes of one on the log-log scale). The memory footprint follows the same linear behavior as the execution time, due to non-optimized data structures for storing cutting surfaces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Limitations</head><p>A limitation of the algorithm is that it requires the mesh to be manifold with boundary to ensure that the boundary of the mesh is a 2manifold without boundary. Another is that it is often not possible to disambiguate the behavior of contours by inspecting only the link and sub-level sets of a saddle, therefore we perform extra cuts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">APPLICATION: FAST TOPOLOGICALLY CLEAN ISOSURFACE EXTRACTION ON NON-SIMPLY CONNECTED DOMAINS</head><p>To demonstrate the potential and the versatility of our approach, we generalize fast topologically clean isosurface extraction to non-simply connected domains. In particular, we focus on the analysis of pressure fields in mechanical design (where the majority of meshes have handles), a case study where contour-tree based techniques could not previously apply. One experiment in the process of mechanical design involves the analysis of the resistance of mechanical pieces made of different materials to pressure stress. In such experiments, mechanical experts first consider simulation previews computed on low resolution meshes. This step illustrates the approximate behavior of the material. Its understanding is crucial to define correct parameters for the actual simulation at high resolution. However, as shown in figure 11, this preview can be noisy, making its interpretation difficult. We overcome this problem with a fast topologically clean isosurface extraction system. First, the Reeb graph of the low-resolution pressure stress function is computed in a pre-process. Then, local geometric measures <ref type="bibr" target="#b7">[8]</ref> (extended to tetrahedral meshes) are computed for each arc of the Reeb graph. Then, users may select thresholds for geometric measures to simplify the Reeb graph, as described in <ref type="bibr" target="#b18">[19]</ref>. This filtering of the arcs in our examples took at most 0.03 seconds. Our approach maintains degree two nodes in the Reeb graph, representing regular vertices of the function. Consequently, the Reeb graph provides a seed vertex for each contour the user wants to display. We store the non-simplified arcs of the Reeb graph in a balanced interval tree. An isosurface extraction query consists of searching in this tree for a valid seed set. In our examples, this is performed in less than  nanoseconds, starting standard isosurface traversal techniques at these seeds in interactive times. <ref type="figure" target="#fig_7">Figure 11</ref> illustrates this process on pressure stress functions computed on a brake disk and a cylinder head, where the user progressively increases a simplification threshold with the hyper-volume measure <ref type="bibr" target="#b7">[8]</ref>. The Reeb graphs are simplified, and as a result, the small connected components (noise) of the queried isosurface are progressively removed and the most important features are highlighted. This enables a direct visualization of the major trends of the simulation. In the future, we would like to introduce metrics between the Reeb graphs at low and high mesh resolutions, in order to provide quality scores for the low-resolution previews, to accelerate the validation of the final simulation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">CONCLUSION</head><p>In this paper, we present a novel algorithm for fast Reeb graph computation on tetrahedral meshes in R 3 . By providing theoretical results on the topology of such Reeb graphs, we show their computation could be reduced to a contour tree computation through a technique called loop surgery. Experiments demonstrate in practice the scalability of the algorithm. Moreover, we show that our approach improves in term of running time, for the special case of volumetric meshes, the fastest previous techniques on real-life data by several orders of magnitude. We extend fast topologically clean isosurface extraction to non-simply connected domains in the context of mechanical design.</p><p>Reducing the computational requirements of Reeb graphs to that of contour trees enables the generalization of the contour-tree based visualization techniques to volumetric meshes of arbitrary topology and thus opens several avenues for future visualization research. Furthermore, as contour tree computation has been shown to be parallelizable <ref type="bibr" target="#b17">[18]</ref>, we plan to investigate a parallel version of the algorithm for large-scale data analysis. An extension of our approach to volumetric meshes not embeddable in R 3 and of higher dimensions would address a larger class of problems. However, as it is no longer true that such meshes necessarily admit boundary, the loop surgery concept would need to be extended and generalized. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>•</head><label></label><figDesc>Julien Tierny, Attila Gyulassy and Valerio Pascucci are with the Scientific Computing and Imaging Institute, University of Utah, E-mails: {jtierny, jediati, pascucci}@sci.utah.edu. • Eddie Simon is with Dassault Systèmes, E-mail: eddie.simon@3ds.com. Manuscript received 31 March 2009; accepted 27 July 2009; posted online 11 October 2009; mailed on 5 October 2009. For information on obtaining reprints of this article, please send email to: tvcg@computer.org .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>(a) M, f (M) (b) R( f ∂ ) (c) Cutting surfaces (d) M , f (M ) (e) R( f ) Fig. 2. Overview of Reeb graph computation based on loop surgery: The input defines a scalar function f (color gradient) on M (a). The Reeb graph of the function restricted to the boundary R( f ∂ ) (b) is used to identify loop saddles (blue squares). Cutting surfaces (c) of each loop saddle are used to transform the domain (d) to M . The Reeb graph R( f ) is loop free (e). Inverse cuts are applied to circled critical point pairs to obtain the Reeb graph R( f ) of the input function.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>nected component of the level set L(w) a contour. A sub-level set is defined as the inverse image of the open interval (−∞, w) onto M through f , L − (w) = {x ∈ M| f (x) &lt; w}. Symmetrically, a sur-level set is the inverse image of the open interval(w, ∞) onto M through f , L + (w) = {x ∈ M| f (x) &gt; w}.One aspect that is well understood in Morse theory<ref type="bibr" target="#b16">[17]</ref> is the evolution of the homology classes of the contours of f while w changes continuously in R. The points at which the topology of a contour changes are called critical points and the corresponding function values are called critical values. If all of the critical points of f are nondegenerate and have distinct values, then f is a Morse function.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Reeb graph R( f ) is the contour retract of M under f . The Reeb graph is represented as a graph consisting of nodes and arcs. Branching in R( f ) occurs only at critical values of f . Figure 2(b) shows a simple scalar function with the associated Reeb graph. A Reeb graph is called a contour tree when it has no loops. For example, this is true when M is simply connected.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Fig. 3 .</head><label>3</label><figDesc>Example where the domain (a) is not simply connected and R( f ) is loop free (b). The Reeb graph of the boundary, R( f ∂ ), has a loop (c), therefore loop surgery is performed (d), (e). Even after loop surgery, each component of M is not necessarily simply connected, but the Reeb graph of each component is loop free (f).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>is a regular value of f , there is no critical value in [ f (s i ) − ε, f (s i )) and S i intersects one of the connected components of the lower star St − (s i ) in the volume. The symbolic cuts transforming M into M consist of cutting M along each defined cutting surface, as illustrated in figures 2(c) and 2(d). On the topology domain, cutting along a cutting surface at a regular value is equivalent to cutting an arc of R( f ) and creating a new pair of critical nodes (a minimum and a maximum, as illustrated in figure 2(e)). Since we have an injection from the set of loops of R( f ) to the set of cutting surfaces, the Reeb graph of the function f : M → R, f being the function valued by f after symbolic cuts, is guaranteed to be loop free: all the possible loops have indeed been broken, as shown in figure 2(e).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Lemma 2 .</head><label>2</label><figDesc>Let f : M → R be a Morse function and n be a degree-3 node of R( f ) corresponding to a join saddle s (seefigure 4). If the contours joined by the saddle are on the boundary of the same sublevel set component, then there exists a loop in R( f ) for which n is the highest saddle. Proof. Refer to figure 4 in the following. Given n, s, f , and R( f ), let ε be a small number such that there is no critical value in therange [ f (s) − ε, f (s)).The existence of such an epsilon is guaranteed because the critical values of a Morse function are distinct. Let w = f (s) − ε, and a and b be the points on the two downward arcs from n such that the value of their corresponding contours c a and c b is w, i.e., f (c a ) = f (c b ) = w. By construction, n is a join saddle, therefore there exists a path p + in M connecting a point in c a with a point in c b such that all its interior is in the sur-level set L + (w). The map φ : M → R( f ), mapping points in the same contour in M to the same point in R( f ), is a continuous surjection (by definition of a contour retraction), therefore a connected component p + in M is mapped to a connected component φ (p + ) in R( f ), such that a and b are connected in R( f ) by a path q + ⊆ φ (p + ) whose interior is strictly above w. Since by hypothesis c a and c b are on the boundary of the same sub-level set component, there exists also a path p − in M connecting a point in c a with a point in c b such that all its interior is in the sub-level set L − (w). Therefore a and b are also connected in R( f ) by a path q − ⊆ φ (p − ) whose interior is strictly below w. The two paths q + + q − form a loop. By applying lemma 2, we prove necessary and sufficient conditions for computing correct loop free Reeb graphs using tracking of suband sur-level sets. Lemma 3. Let f : M → R be a Morse function. Its Reeb graph R( f ) is loop free if and only if every degree-3 node in R( f ) corresponds to a saddle of f where distinct components of sub-or sur-level sets join.Proof. First we prove that if a Reeb graph R( f ) is loop free, every degree-3 node n corresponds to a saddle s of f that joins distinct components of sub-or sur-level sets. Assume that there exists a degree-3 node that joins contours that are on the boundary of the same sub-or sur-level set component. By lemma 2, there must be a loop in R( f ). This contradicts the hypothesis statement that R( f ) is loop free.Next, we prove that if every degree-3 node corresponding to a saddle in R( f ) joins distinct sub-or sur-level set components, then R( f ) is loop free. Assume for contradiction that R( f ) has a loop, s is the highest join saddle in the loop, and n the corresponding degree-3 node. Pick ε, w, a, b, c a , and c b as before. The paths q + and q − exist in R( f ) connecting a and b in a loop. Since φ is a contour retraction, any connected component of R( f ) is a connected subset of M. Therefore φ −1 (q − ) is a connected component in M, connecting c a to c b in L − (w). Therefore, c a and c b are on the boundary of the same connected component of L − (w), which contradicts the hypothesis. The same argument holds for split saddles.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Algorithm 1 .</head><label>1</label><figDesc>Reeb Graph Overview INPUT: f, M (0) M' = M, GL = {} (1) if genus_diagnostic(∂ M) &gt; 0 then (2) S∂ = find_loop_saddles(M, ∂ M, f) (3) for each s in S∂ (4) M' = cut(M', cutting_surface(s)) (5) GL = GL ∪ node_pairs(s) (6) RG = contour_tree(M') (7) for each p in GL (8) RG = glue(RG, p) (9) return RG</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Fig. 4 .</head><label>4</label><figDesc>Reference figure for lemma 2. Paths forming a loop in M map to connected components forming a loop in R( f ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 5 .</head><label>5</label><figDesc>(a) ∂ M, f ∂ (∂ M) (b) Sublevel sets of f ∂ (c) Join tree of f ∂ (d) Split tree of f ∂ (e) Lk − (s) (f) Loop saddles Identifying loop saddles: f ∂ and its saddle points (a). Loops are "absorbed" by sub-level sets of f ∂ (b). Join tree (c) and split tree (d) of f ∂ identify non-loop saddles. Configurations of the lower link (e) in the volume distinguish between opening and closing of loops. Loop saddles (blue squares) are returned (f).(ii) We remove saddles of S ∂ that do not open or close a loop. To use the result of lemma 2 in determining whether or not the saddle can be part of a loop, we identify the sub-and sur-level set associated with each connected component of the lower and upper link of a saddle of S ∂ . The classification of sub-and sur-level set components is computed by constructing the join tree and the split tree in the join-split contour tree algorithm<ref type="bibr" target="#b6">[7]</ref>. The join sweep that builds the join tree processes vertices of ∂ M in order of increasing function value, maintaining sub-level sets via a Union-Find data structure. In the computed join tree of f ∂ , the number of downward arcs of each node is equal to the number of distinct sub-level set components of f ∂ that are joined at the corresponding vertex. Similarly, a split sweep builds the split tree by processing vertices of ∂ M from highest to lowest. The resulting split tree provides the information about the evolution of sur-level set components. When the number of downward arcs in the join tree equals the number of connected components of the lower link or the number of upward arcs in the split tree equals the number of connected components of the upper link, the saddle does not open or close a loop in R( f ∂ ). These saddles are removed from S ∂ . In practice, this step removes 87% of the saddles of S ∂ on average. (iii) The set S ∂ now contains exactly those saddles that correspond to the opening or closing of a loop on the boundary. Furthermore, the sub-and sur-level set component associated with each connected component of the lower and upper link of every saddle is also known from step (ii). Let s be a saddle of S ∂ . If two or more connected components of Lk − ∂ (s) are part of the same sub-level set component, then by lemma 2, s forms a loop in R( f ∂ ). However, if they also belong to the same contour of f in the volume, then s does not create a loop in R( f ). Therefore, we keep only saddles s in S ∂ where distinct connected components in Lk − ∂ (s) are the boundary components of the same sub-level set component, and are also disconnected in the link of s in the volume, Lk − (s). All other saddles are removed from S ∂ . In practice, this step removes 50% of the remaining saddles of S ∂ .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 6 .</head><label>6</label><figDesc>Examples of cutting surfaces of 3D scalar fields defined on non-simply connected domains: skull (2 handles), brake caliper (3 handles), cylinder head (82 handles).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 7 .</head><label>7</label><figDesc>Examples of Reeb graphs computed from height functions defined on the experiment data-sets. Persistence-based simplification and arc smooth embedding can optionally be computed in a post-process.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Let n and N be the number of vertices and simplices of M. Let n ∂ , N ∂ and N S be the numbers of vertices of ∂ M, the number of simplices of ∂ M, and the number of simplices of M crossed by cutting surfaces. We present a complexity analysis for each step in our algorithm: Loop saddle extraction: Saddle identification by link traversal requires O(n ∂ ) steps. Join tree and split tree computation both require O(n ∂ log(n ∂ ) + N ∂ α(N ∂ )) where α() is an exponentially decreasing function (inverse of the Ackermann function). Loop saddle distinction is performed in O(g) steps, where g is the genus of ∂ M. Symbolic cuts computation: O(g×N S ) steps: there are at most O(g) cuts, and each may cross at most O(N S ) tetrahedra.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 8 .</head><label>8</label><figDesc>Trunk data-set: due to the thinness of the mesh, the pressure simulation failed, resulting in a noisy field (left), where 20% of the vertices of the mesh generate branching in the Reeb graph (right).Loop-free Reeb graph computation: the contour tree algorithm variant requires O(nlog(n) + Nα(N)) steps<ref type="bibr" target="#b6">[7]</ref>.Inverse cuts: O(g) steps: there is an explicit list of cutting surfaces, and gluing the min-max pairs of each takes constant time. Overall bound: O(nlog(n) + Nα(N) + g × N S ).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Fig. 9 .</head><label>9</label><figDesc>Handle stress tests: examples of generated meshes with increasing number of handles and the Reeb graph of their height function.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head>Fig. 10 .</head><label>10</label><figDesc>Memory footprint (dashed) and running time (solid) when increasing the number of tets for a mesh with constant number of handles.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head>Fig. 11 .</head><label>11</label><figDesc>Topologically clean isosurface extraction on a pressure stress simulation. The Reeb graph is progressively simplified (from top to bottom) with increasing hyper-volume scale. As a result, small components (noise) of the considered isosurface are progressively removed and the most important features are progressively highlighted. Brake disk, from top to bottom: 92, 8 and 2 connected components. Cylinder head, from top to bottom: 215, 58 and 9 connected components.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 .</head><label>1</label><figDesc>Comparison of the Reeb graph computation times. In the table #H indicates the number of handles in a mesh, LS, SA, and OS indicate the loop surgery, the streaming</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 .</head><label>2</label><figDesc>Running times of the different stages of the algorithm for reallife fields on non-simply connected domains. Loop surgery overhead represents 43% of the computation in average.</figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>(s.)</cell><cell></cell><cell>Time (s.)</cell><cell>Speedup</cell><cell>Time (s.)</cell><cell>Speedup</cell></row><row><cell>Langley Fighter</cell><cell>70,125</cell><cell>0</cell><cell>0.35</cell><cell></cell><cell>43.70</cell><cell>126</cell><cell>650.10</cell><cell>1,879</cell></row><row><cell>Cylinder Head (low res.)</cell><cell>116,274</cell><cell>82</cell><cell>0.66</cell><cell></cell><cell>10.20</cell><cell>15</cell><cell>257.19</cell><cell>390</cell></row><row><cell>Hood (low res.)</cell><cell>120,501</cell><cell>31</cell><cell>0.34</cell><cell></cell><cell>45.77</cell><cell>135</cell><cell>52.60</cell><cell>158</cell></row><row><cell>Trunk (low res.)</cell><cell>143,366</cell><cell>1</cell><cell>1.87</cell><cell></cell><cell>27.97</cell><cell>15</cell><cell>406.67</cell><cell>218</cell></row><row><cell>Liquid Oxygen Post</cell><cell>616,050</cell><cell>1</cell><cell>0.69</cell><cell></cell><cell>435.20</cell><cell>634</cell><cell>15.54</cell><cell>23</cell></row><row><cell cols="2">Brake Caliper (med res.) 1,155,317</cell><cell>3</cell><cell cols="3">2.24 me: 167,382.52</cell><cell cols="3">-180,637.74 80,570</cell></row><row><cell>Buckminster Fullerene</cell><cell>1,250,235</cell><cell>0</cell><cell>2.51</cell><cell></cell><cell>9,887.00</cell><cell>3,942</cell><cell>781.00</cell><cell>311</cell></row><row><cell>Plasma</cell><cell>1,310,720</cell><cell>0</cell><cell>2.20</cell><cell></cell><cell>11,983.21</cell><cell cols="2">5,442 me: 406.83</cell><cell>-</cell></row><row><cell cols="2">S. Fernando Earthquake 2,067,739</cell><cell>0</cell><cell>4.07</cell><cell></cell><cell>15,949.10</cell><cell cols="2">3,921 me: 327.33</cell><cell>-</cell></row><row><cell>Brake Disk (high res.)</cell><cell>3,554,828</cell><cell>54</cell><cell>7.80</cell><cell cols="2">me: 56,929.80</cell><cell cols="2">-me: 762.14</cell><cell>-</cell></row><row><cell>Data</cell><cell></cell><cell></cell><cell>Tets</cell><cell cols="5">#H Loop surgery contour tree</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">(s. / %)</cell><cell cols="2">(s. / %)</cell></row><row><cell cols="2">Cylinder Head (low res.)</cell><cell cols="2">116,274</cell><cell cols="2">82 0.45</cell><cell>68.18</cell><cell cols="2">0.21 31.82</cell></row><row><cell cols="2">Hood (low res.)</cell><cell cols="2">120,501</cell><cell cols="2">31 0.13</cell><cell>38.24</cell><cell cols="2">0.21 61.76</cell></row><row><cell cols="2">Trunk (low res.)</cell><cell cols="2">143,366</cell><cell>1</cell><cell>1.42</cell><cell>75.94</cell><cell cols="2">0.45 24.06</cell></row><row><cell cols="2">Liquid Oxygen Post</cell><cell cols="2">616,050</cell><cell>1</cell><cell>0.09</cell><cell>13.43</cell><cell cols="2">0.58 86.57</cell></row><row><cell cols="4">Brake Caliper (medium res.) 1,155,317</cell><cell>3</cell><cell>0.52</cell><cell>23.11</cell><cell cols="2">1.73 76.89</cell></row><row><cell cols="2">Brake Disk (high res.)</cell><cell cols="4">3,554,828 54 3.01</cell><cell>38.89</cell><cell cols="2">4.79 61.41</cell></row></table><note></note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">IEEE TRANSACTIONS ON VISUALIZATION AND COMPUTER GRAPHICS, VOL. 15, NO. 6, NOVEMBER/DECEMBER 2009</note>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>Julien Tierny was supported by the Fulbright Program (U.S. Department of State) and by the Lavoisier Program (French Ministry of Foreign Affairs). Attila Gyulassy was supported in part by the National Science Foundation, under grant CCF-0702817. This work has also been performed under the auspices of the U.S. Department of Energy by the University of Utah under Contract DE-FC02-06ER25781. The authors would like to thank Vijay Natarajan for providing the implementation of the paper <ref type="bibr" target="#b11">[12]</ref>.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>UF.make_set(a) <ref type="bibr" target="#b3">(4)</ref> if v ∈ S∂ then <ref type="bibr" target="#b4">(5)</ref> for each S in cutting_surfaces(v) (6) b = JT.add_node(S ) <ref type="bibr" target="#b6">(7)</ref> UF.make_set(b) <ref type="bibr" target="#b7">(8)</ref> for each tet σ ∈St</p><p>if c = a then <ref type="bibr" target="#b12">(13)</ref> UF.union(c, a) <ref type="bibr" target="#b13">(14)</ref> JT.add_edge(c, a) <ref type="bibr" target="#b14">(15)</ref> for each vertex u in σ ∩ Lk − (v) <ref type="bibr" target="#b15">(16)</ref> if f(u) &gt; f(S ) then <ref type="bibr" target="#b16">(17)</ref> d = UF.find(u) <ref type="bibr" target="#b17">(18)</ref> if d = a then <ref type="bibr" target="#b18">(19)</ref> UF.union(d, a) (20)</p><p>JT.add_edge(d, a) (21) else <ref type="bibr" target="#b21">(22)</ref> for each vertex u in σ ∩ Lk − (v) (23) c = UF.find(u) <ref type="bibr" target="#b23">(24)</ref> if c = a then <ref type="bibr" target="#b24">(25)</ref> UF.union(c, a) <ref type="bibr" target="#b25">(26)</ref> JT.add_edge(c, a) (27) return JT Vertices are processed in order of increasing function value (lines 0,1), and we add the vertex v to the join tree and to a new set in the Union-Find (lines 2,3). If v is a saddle that generated a symbolic cut (line 4), we simulate M being cut. We also simulate the existence of a new sub-level set and a new minimum by adding each cutting surface S to the join tree and the Union-Find (lines 6,7). The tetrahedra in the star of v that have a vertex in the lower link of v are iterated upon (line 8). For each such tetrahedron σ , if there is a cut S crossing σ (line 9), we pick the highest S that is below v (line 10). This is a constant time operation due to having stored pointers in each tetrahedron in the cutting surface computation (section 3.1.3). We perform a</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Aim@shape Shape</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Repository</surname></persName>
		</author>
		<ptr target="http://shapes.aim-at-shape.net/" />
		<imprint>
			<date type="published" when="2006" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Extreme elevation on a 2-manifold</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">K</forename><surname>Agarwal</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Edelsbrunner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Harer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Wang</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symp. on Computational Geometry</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="357" to="365" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Harmonic skeletons for realistic character animation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Aujay</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Hétroy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Lazarus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Depraz</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics Symp. on Computer Animation</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="151" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">The contour spectrum</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">L</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schikore</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="1997" />
			<biblScope unit="page" from="167" to="174" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Extended Reeb graphs for surface understanding and description</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Biasotti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Falcidieno</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Spagnuolo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Discrete Geometry for Computer Imagery</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="185" to="197" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Reeb graphs for shape analysis and applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Biasotti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Giorgi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Spagnuolo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Falcidieno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Theoretical Computer Science</title>
		<imprint>
			<biblScope unit="volume">392</biblScope>
			<biblScope unit="page" from="5" to="22" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Computing contour trees in all dimensions</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Carr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Snoeyink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Axen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symp. on Discrete Algorithms</title>
		<imprint>
			<date type="published" when="2000" />
			<biblScope unit="page" from="918" to="926" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Simplifying flexible isosurfaces using local geometric measures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Carr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Snoeyink</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">V</forename><surname>De Panne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization</title>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="497" to="504" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Loops in Reeb graphs of 2-manifolds</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Cole-Mclaughlin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Edelsbrunner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Harer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Natarajan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Symp. on Computational Geometry</title>
		<imprint>
			<date type="published" when="2003" />
			<biblScope unit="page" from="344" to="350" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Trekking in the alps without freezing or getting tired</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Berg</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">J</forename><surname>Van Kreveld</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">European Symp. on Algorithms</title>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="121" to="132" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Computing homology groups of simplicial complexes in R 3</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">K</forename><surname>Dey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Guha</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of the ACM</title>
		<imprint>
			<biblScope unit="volume">45</biblScope>
			<biblScope unit="page" from="266" to="287" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Efficient output-sensitive construction of Reeb graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Doraiswamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Natarajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Symp. on Algorithms and Computation</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="557" to="568" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Efficient algorithms for computing Reeb graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Doraiswamy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Natarajan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computational Geometry: Theory and Applications</title>
		<imprint>
			<biblScope unit="volume">42</biblScope>
			<biblScope unit="page" from="606" to="616" />
			<date type="published" when="2009" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Simulation of simplicity: a technique to cope with degenerate cases in geometric algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Edelsbrunner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">P</forename><surname>Mucke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Graphics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="66" to="104" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">Algebraic Topology</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hatcher</surname></persName>
		</author>
		<imprint>
			<date type="published" when="2002" />
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Topology matching for fully automatic similarity estimation of 3D shapes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Hilaga</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Shinagawa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kohmura</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kunii</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="203" to="212" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Milnor</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Morse Theory</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1963" />
			<publisher>Princeton University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Parallel computation of the topology of level sets</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Cole-Mclaughlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Algorithmica</title>
		<imprint>
			<biblScope unit="volume">38</biblScope>
			<biblScope unit="page" from="249" to="268" />
			<date type="published" when="2003" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Robust online computation of Reeb graphs: simplicity and speed</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Scorzelli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">T</forename><surname>Bremer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Mascarenhas</surname></persName>
		</author>
		<idno>26:58.1-58.9</idno>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Graphics</title>
		<imprint>
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Reeb graph computation based on minimal contouring</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Patanè</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Spagnuolo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Falcidieno</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Shape Modeling International</title>
		<imprint>
			<date type="published" when="2008" />
			<biblScope unit="page" from="73" to="82" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Sur les points singuliers d&apos;une forme de Pfaff complètement intégrable ou d&apos;une fonction numérique</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Reeb</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Comptes-rendus de l&apos;Académie des Sciences</title>
		<imprint>
			<date type="published" when="1946" />
			<biblScope unit="volume">222</biblScope>
			<biblScope unit="page" from="847" to="849" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Surface coding based on Morse theory</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Shinagawa</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">L</forename><surname>Kunii</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><forename type="middle">L</forename><surname>Kergosien</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="page" from="66" to="78" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Construction of contour trees in 3D in O((n) log (n)) steps</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Tarasov</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Vyalyi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM Symp. on Computational Geometry</title>
		<imprint>
			<biblScope unit="page" from="68" to="75" />
			<date type="published" when="1998" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Contour trees and small seed sets for isosurface traversal</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Van Kreveld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Van Oostrum</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Bajaj</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Shcikore</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In ACM Symp. on Computational Geometry</title>
		<imprint>
			<biblScope unit="page" from="212" to="220" />
			<date type="published" when="1997" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Surgery on compact manifolds</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T C</forename><surname>Wall</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1970" />
			<publisher>American Mathematical Society</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Topological landscapes: a terrain metaphor for scientific data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">H</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P.-T</forename><surname>Bremer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="1416" to="1423" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<analytic>
		<title level="a" type="main">Topology-controlled volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">H</forename><surname>Weber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">E</forename><surname>Dillard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Carr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">V</forename><surname>Pascucci</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="330" to="341" />
			<date type="published" when="2007" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b27">
	<analytic>
		<title level="a" type="main">Removing excess topology from isosurfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wood</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hoppe</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Desbrun</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Schrder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Graphics</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="190" to="208" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b28">
	<analytic>
		<title level="a" type="main">Feature-based surface parametrization and texture mapping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Zhang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mischaikow</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Trans. on Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="1" to="27" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
