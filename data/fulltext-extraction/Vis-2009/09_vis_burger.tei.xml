<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Interactive Streak Surface Visualization on the GPU</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kai</forename><surname>Bürger</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Florian</forename><surname>Ferstl</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Holger</forename><surname>Theisel</surname></persName>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rüdiger</forename><surname>Westermann</surname></persName>
						</author>
						<title level="a" type="main">Interactive Streak Surface Visualization on the GPU</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-20T19:51+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Unsteady flow visualization</term>
					<term>streak surface generation</term>
					<term>GPUs</term>
				</keywords>
			</textClass>
			<abstract>
				<p>Fig. 1. Our method generates adaptively refined integral surfaces in 3D flows on the GPU. The shown surfaces consist of 800k, 300k and 400k particles, respectively, and they were generated and rendered in less than 50ms. Figure a) and b) show streak surfaces in unsteady flows. Figure c) shows a stream surface.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">INTRODUCTION</head><p>In interactive flow visualization, the integration and visualization of stream lines has been a standard tool from its very beginning. With the consideration of time-dependent flows, path lines and streak lines have moved into the focus of research because they reflect important properties of the flow: while a path line describes the path of a massless particle in the flow, a streak line shows the positions of particles that have been released continuously at a fixed location in the past.</p><p>The visualization of integral surfaces has been proven to be common and useful in visual flow exploration. In the case of stream and path surfaces, their extraction is well-understood. The main idea is to integrate the front line of the surface and apply if necessary an adaptive refinement/coarsening to it. After the front has passed, the generated surface remains unchanged.</p><p>Streak surfaces have a strong relation to experimental flow visualization where external materials such as dye, hydrogen bubbles or heat energy are injected into the flow. The advection of these external materials creates streak lines and shows the flow patterns. Due to this reason, analogues to these experimental techniques have been adopted by researchers in computer-aided scientific visualization for flow exploration. However, up to now streak surfaces are rarely applied be-</p><p>• K. Bürger (E-mail: buerger@tum.de) and R. Westermann (E-mail: westermann@tum.de) are with the Computer Graphics &amp; Visualization group, Technische Universität München.</p><p>• Holger Theisel (E-mail: theisel@isg.cs.uni-magdeburg.de) is with the Visual Computing group, University of Magdeburg. cause of the computational complexity of streak surface generation. Since streak surfaces may change their shape everywhere and at any time of the integration, every part of the surface has to be monitored at any time of the integration for adaptive refinement/coarsening. Due to this fundamental difference to stream and path surfaces, the consideration of streak surfaces makes only sense if their evolution over time is shown, e.g., in a pre-computed video sequence or in interactive applications with a real-time performance. The only approach so far to address the real-time requirement was proposed by Funck et al. <ref type="bibr" target="#b19">[20]</ref>. It combines the streak surface integration with a smoke metaphor, leading to cancelation effects of problematic surface parts: parts of the streak surface where an adaptive refinement is necessary are rendered less opaquely. In this way, smoke like structures are obtained by a streak surface integration without any adaptive refinement. On the other hand, the value of this approach for visual flow exploration is limited because it cannot guarantee to find all relevant flow structures and fine structures can only be revealed if the initial tessellation of the mesh already respects these subtleties.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">CONTRIBUTION</head><p>In this paper, to the best of our knowledge, we present the first realtime approach for adaptive streak surface integration and high-quality rendering. We achieve this by using particle-based approaches in which either the surface is represented as a set of surface patches that can be handled independent of each other, or a closed surface triangulation is computed from the given particle set. For both approaches we have developed methods for interactive surface refinement and coarsening based on local surface properties.</p><p>While the former approach is elegant in its simplicity, it requires redundant particle computations and lacks flexibility in the rendering process. Even though we use an advanced rendering method similar to high-quality point-splatting <ref type="bibr" target="#b1">[2]</ref>, rendering artifacts at patch boundaries can not be avoided entirely. The second approach, on the other hand, yields a closed surface representation providing a variety of rendering options, but it can result in deformed triangulations and rendering artifacts thereof.</p><p>Our paper makes the following specific contributions:</p><p>• A patch-based scheme for the adaptive generation of streak surfaces, and a high-quality patch-based surface rendering technique.</p><p>• A particle-based adaptive refinement/coarsening scheme for streak surface generation, and a novel method to construct a closed triangular streak surface from a set of particles.</p><p>These approaches run entirely on the GPU and allow for real-time performance if certain requirements are fulfilled. In particular, for an efficient processing of time-dependent fields, as many consecutive time steps as are required by the numerical integrator are supposed to fit into GPU memory. In addition, our methods assume the flow fields to be given on Cartesian grids that can be stored in 3D texture maps on the GPU. As it was shown in Krueger et al. <ref type="bibr" target="#b9">[10]</ref>, particle tracing can then be mapped efficiently on the SIMD architecture underlying current GPUs. In principle, the extension of our approaches to tetrahedral grids is straight forward <ref type="bibr" target="#b14">[15]</ref>, but it comes at an additional expense due to more complex operations for point location and interpolation, as well as the fact that particles might have to integrate over many elements in one time step.</p><p>The remainder of this paper is organized as follows. In the next chapter we review previous work that is related to ours. An introduction to streak surfaces is given in Section 4. Section 5 presents a novel technique to construct and render a patch-based streak surface representation. In Section 6 we describe the particle-based technique for streak surface generation in which local connectivity information is used to build a surface triangulation. In Section 7 we evaluate the performance of our approaches, and we discuss their advantages and limitations. We conclude the paper with an outline of future research in the field.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">RELATED WORK</head><p>We do not attempt here to survey the vast number of approaches in stream line and path line integration because they are standard in flow visualization. For a thorough overview, however, let us refer to the report by Post et al. <ref type="bibr" target="#b10">[11]</ref>. Graphics hardware related algorithms for interactive flow exploration were presented in <ref type="bibr" target="#b2">[3,</ref><ref type="bibr" target="#b3">4,</ref><ref type="bibr" target="#b4">5,</ref><ref type="bibr" target="#b9">10,</ref><ref type="bibr" target="#b14">15,</ref><ref type="bibr" target="#b16">17]</ref>. The usefulness of streak lines for the exploration of time-dependent flow fields has been proven in several applications, but due to the computational complexity of streak line integration and adaptive stream surface construction streak surfaces have only rarely been used in practice.</p><p>Hultquist <ref type="bibr" target="#b8">[9]</ref> presented the first adaptive stream surface integration approach, which was later extended in different ways: The approach by Stalling <ref type="bibr" target="#b17">[18]</ref> uses local topological information to increase accuracy. Scheuermann et al. <ref type="bibr" target="#b13">[14]</ref> compute exact solutions of stream surfaces inside piecewise linear vector fields. In the work by van Wijk <ref type="bibr" target="#b18">[19]</ref> a global implicit approach for certain stream surfaces is given. Recently, a construction method for stream surfaces of high polynomial precision has been introduced by Schneider et al. <ref type="bibr" target="#b15">[16]</ref>. Garth et al. <ref type="bibr" target="#b7">[8]</ref> discussed a number of enhancements in the context of vortex extraction. In another work by Garth et al. <ref type="bibr" target="#b6">[7]</ref>, improved integral surface accuracy was achieved by separating characteristic line integration and integral surface triangulation. A particle-based approach for the generation and rendering of stream surfaces was proposed by Schafhitzel in <ref type="bibr" target="#b12">[13]</ref>.</p><p>The methods proposed by Schafhitzel <ref type="bibr" target="#b12">[13]</ref> and Garth et al. <ref type="bibr" target="#b6">[7]</ref> are also the only approaches describing the surface extraction in a timedependent context for path surfaces. The generalization from stream surfaces to path surfaces is rather straightforward because only the kind of integration at the surface front has to be replaced.</p><p>The first approach for streak surface integration is the smoke surface approach presented by Funck et al. in <ref type="bibr" target="#b19">[20]</ref>. There, the adaptivity problem of streak surfaces is solved by extracting the surface with a smoke metaphor and therefore avoiding any adaptive refinement. While this gives interesting smoke-like structures, it is unable to produce fully adaptive opaque streak surfaces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">STREAK SURFACES</head><p>Streak surfaces are defined by repeatedly setting out particles on a line-shaped seeding structure over a certain time interval. The collection of all these particles at a certain time denotes the streak surface. Technically, a streak surface can be obtained in the following way for a 3D time-dependent flow field v(x,t): the seeding structure is considered to be a polyline consisting of the points s 0 , ..., s n . At the time t i = t 0 + i ∆t we start a path line integration of the particle x i, j from the seeding point s j and observe its behavior over t:</p><formula xml:id="formula_0">x i, j (t) = x i, j (t i ) + ∫ t t i v(x i, j (s), s) ds (1) with x i, j (t i ) = s j , i = 0, .</formula><p>.., m and j = 0, ..., n. For t ≥ t m = t 0 +m ∆t, the streak surface can be considered as a rectangular vertex array (x i, j (t)).</p><p>We call a column (x i,0 , ..., x i,n ) a time line, while a row</p><formula xml:id="formula_1">(x 0, j , ..., x m, j )</formula><p>is a streak line. The vertices are the surface points from which a closed surface representation has to be built. During the integration, the distance between both adjacent time lines and streak lines may vary at any location of the surface. Thus, after every integration step the surface has to be checked everywhere for adaptive refinement or coarsening. This means that, based on an appropriate refinement/coarsening criterion, new particles have to be seeded between adjacent points along a particular time or streak line, or adjacent points have to be merged. This process is computationally very complex because streak surfaces appear to have a rather large distortion after their seeding. An increase of the surface area by a factor of 100 or more is usual, leading to a high number of refinement steps. It is worth noting that in an interactive application, the adaptive refinement/coarsening has to be monitored and carried out at any time simultaneously with real-time performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">PATCH-BASED STREAK SURFACE GENERATION</head><p>By using a patch-based approach, the streak surface generation and rendering process is split into a set of independent operations on each patch. These operations can then be executed in parallel, and all the patches can be rendered independent of each other. The computation of adjacency information between surface points, as it is required for the computation of a surface triangulation, can be avoided.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Patch Generation and Refinement</head><p>As described in Section 4, a streak surface can be constructed by repeatedly setting out particles on a line-shaped seeding structure over a certain time interval and by connecting these particles to form a closed surface. All particles (x i,0 , ..., x i,n ) released at time t i = t 0 + i ∆t reside on one advancing front. We call this front the time line tl i .</p><p>Whenever a new time line tl i is released, our approach computes n quadrilateral patches</p><formula xml:id="formula_2">p i,v , with v = 0, ..., n − 1. Each patch consists of four vertices (s v , s v+1 , x i,v , x i,v+1</formula><p>), which are duplicated and stored separately for each patch. The initial time line is removed. The patch vertices are then advected through the flow as described before, and the shape changes a patch undergoes due to the particles movements are used to steer the refinement process.</p><p>The refinement of surface patches is performed for each patch separately wrt. an area-based criterion. Specifically, we set a threshold to Ξ 2 , where Ξ is the distance between adjacent points on the seeding structure. If, at any time, the area of a patch is greater than αΞ 2 , where α is a real number larger than 1 controlling the subdivision strength, the patch is subdivided into two quadrilaterals. This is performed by splitting the patch along its longest edge and the edge opposite to it. The two new patches and their vertices are stored separately, and the refined patch is removed (see <ref type="figure" target="#fig_1">Figure 2</ref>). </p><formula xml:id="formula_3">s 1 s 2 s 3 x 0,0 x 0,1 x 0,2 x 0,3 p 0,0 p 0,1 p 0,2 s 0 s 3 x 0,0 x 0,3 p 0,0 p 0,1 p 0,2 s 0 s 0 s 3 x 0,0 x 0,3 p 1,0 p 1,2 x 1,0 x 1,3 p 0,0 p 0,2 (a) (b) (c) p 1,1</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">GPU Implementation</head><p>Today, advanced GPU functionality <ref type="bibr" target="#b0">[1]</ref> provides new possibilities to efficiently perform patch-based streak surface generation: the geometry shader can manipulate a primitive stream by appending or removing primitives, and the stream out stage can be used to direct the resulting stream to intermediate buffers in GPU memory. Since buffer resources cannot be bound as pipeline input and stream out target simultaneously, we use two instances and toggle between them in a ping-pong fashion. Each surface patch is represented by its four vertices, a scalar value counting the number of integration steps, and a counter indicating its refinement depth. On the GPU, for every patch this information is stored as one contiguous data block in a vertex array buffer. Since current GPUs cannot change the size of a resource residing in GPU memory dynamically, a buffer that is large enough to store the entire streak surface has to be allocated before the surface construction begins. By letting the user select the number n of patches that are released in each time step, the maximum refinement depth d, as well as the maximum number of integration steps m a patch can perform until it is removed, the buffer must be able to store</p><formula xml:id="formula_4">n × 2 d × (m − d + 1) patches.</formula><p>The streak surface construction starts by storing n zero area patch primitives p 0 j , with j = 0, ..., n − 1, at the beginning of the vertex array buffer. In the following we assume n to be an even number. These elements are used in every time step to repeatedly release a new patch front into the flow. The respective vertices of patch</p><formula xml:id="formula_5">p 0 j are (s j , s j+1 , s j , s j+1 ).</formula><p>In each integration step, all buffer elements are passed to the geometry shader and processed as follows: For each of the first n/2 elements p 0 j with j = 0, ..., n/2 − 1 the shader writes the two zero area patches p 0 2× j and p 0 (2× j)+1 to the output buffer. Access to the vertices of these patches is achieved by binding the input stream buffer as shader resource. Since these n patches are written first, they are always at the beginning of the buffer. For each of the remaining n/2 elements the shader appends two patch elements to the buffer, which represent the currently released patch front. These patches are then expanded by integrating their last two vertices to new positions.</p><p>For the remaining buffer elements, which contain patches that were released into the flow at previous time steps, the refinement criterion is evaluated before the integration is performed. If a refinement is not carried out, the geometry shader advects the patch vertices, increments the integration step counter and appends the patch element to the output stream. Otherwise, the geometry shader splits the element as described, advects the four original as well as the two new vertices, and appends the two new primitives to the output stream. The refinement counters of the new primitives are set to the counters of the refined patch and incremented by one. <ref type="figure" target="#fig_1">Figure 2</ref>(c) illustrates the growth of the vertex array buffer due to the seeding and refinement of surface patches.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.3">Patch-based Streak Surface Rendering</head><p>The patch-based surface representation can be rendered directly by sending the vertex array buffer through the graphics pipeline and rasterizing the patches separately. However, since T-vertices are introduced by the particular refinement strategy, holes in the surface representation can occur. To cover these holes, we adopt a rendering technique that was introduced by Botsch and co-workers in the context of point splatting <ref type="bibr" target="#b1">[2]</ref>. <ref type="figure" target="#fig_2">Figure 3</ref> shows an adaptively refined patch-based streak surface (α = 1.2), which was rendered using simple point rendering of the patch centroids (left) and the patch-based splatting approach (right). A two pass rendering approach is performed before deferred perpixel surface lighting is computed. Therefore, all patches in the vertex buffer are rendered twice. In each pass a geometry shader enlarges every patch by changing its vertices px k (k = 0, ..., 3) to px k + β ||px k − c||. Here, c is the patch centroid and β is a user defined scaling factor. As shown in <ref type="figure" target="#fig_3">Figure 4</ref>, patches are then split into the four triangles spanned by their centroid and the patch vertices before they are rendered.</p><p>In the first rendering pass, commonly referred to as visibility pass, a depth imprint of the enlarged surface patches closest to the viewer is generated. In the second pass, also known as attribute pass, the patch-based surface representation is rendered again using a biased depth test on the generated depth imprint. In this way, only patch samples close to the first rendered surface survive. In a pixel shader, the patch attributes like color and normal are weighted by a Gaussian kernel centered at the patch centroid, and these contributions are finally accumulated via additive blending and normalization. In this way, a smooth transition of patch attributes is obtained in regions where multiple enlarged patches overlap. Due to the bending of streak surfaces, it can happen that surface samples having a large geodesic distance from each other become close to each other and fall into the same pixel. In this case, the biased depth test might let both samples pass and accumulate in the pixel buffer. To avoid this we assign two additional parameter values to each patch. The first value indicates a patch's position in the ordered set of x i,j-1</p><p>x i,j+1</p><p>x i,j+2</p><p>x i,j+3</p><p>10 10</p><p>x i,j  In the visibility pass, these values are rendered into a separate render target, and they are then used in the attribute pass to discard those fragments that are close to the rendered surface samples but have parameter values that differ more than a given threshold.</p><formula xml:id="formula_6">t i+1 t i+2 t i+3 t i+4 x i,0 x i,1 x i,2 0 1 1 2 1 1 1 0 1 2 1 2 1 2 2 2 2 0 0 0 0 2 7 x i,0 x i,1 x i,2 x i,0 x i,2 x i,4 x i,0 x i,2 x i,0 x i,3 x i,6 x i,6 8 (c) (d)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">MESH-BASED STREAK SURFACE GENERATION</head><p>Patch-based streak surface generation entirely avoids to store and update any connectivity between the patches. On the other hand, because every patch stores its own set of vertices even though they might be shared between patches, a considerable amount of memory is wasted and numerical integration of the same vertex is performed up to four times. To overcome this overhead we propose a novel GPU approach to construct an adaptive triangular streak surface representation from the set of seeded particles. Similar to the data layout that was used in the patch-based approach, all particles seeded into the flow are stored in a linear vertex buffer. Each initially seeded particle x i, j is assigned an index id i, j = j × 2 d , where d is the maximum refinement depth. The particle set belonging to a particular time line tl i is stored in a contiguous block b i in this buffer. The blocks are ordered such that block b i−1 follows block b i , with block b 0 being the last in the buffer.</p><p>In every time step the particles are processed in the order of their occurrence in the buffer, and they are written to the output buffer in the same order. If a new particle is generated due to the splitting of an existing particle, it is placed directly behind this particle in the output buffer. If a particle is removed, it is simply not written into this buffer. On the GPU this is realized by executing a geometry shader with a variable primitive output of 0-2 elements for each incoming primitive. In the same way as described in the previous section, the maximum buffer size has to be computed up front depending on the number of particles per time line, the maximum refinement depth, and the maximum number of integration steps. Then, two ping-pong buffers of this size have to be allocated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Particle Refinement</head><p>Our method for generating an adaptive streak surface triangulation from a given set of subsequently released time lines can be separated into three passes:</p><p>• Time line refinement: Every time line is refined/coarsened based on local criteria like stretching, compression, and line curvature, as well as a global criterion taking into account the change in surface area.</p><p>• Connectivity update: The connectivity between particles on adjacent time lines is established.</p><p>• Streak line refinement: The connectivity information is used to compute local streak line properties, which are considered to steer the refinement of streak lines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.1">Time line refinement</head><p>Time line refinement adapts the particle density along each time line prior to the particle integration. The refinement/coarsening criteria we apply have been adopted from previous work in the field. The first criterion considers the flow divergence at a particle position as introduced in <ref type="bibr" target="#b8">[9]</ref>. Let Φ(x, y) be the distance between particles x and y, and Ξ the initial distance between two adjacent seed points, then the particle x i, j spawns a new particle between x i, j and x i, j+1 -we call this operation particle splitting-if</p><formula xml:id="formula_7">Φ(x i, j , x i, j+1 ) &gt; α Ξ<label>(2)</label></formula><p>Similar to <ref type="bibr" target="#b7">[8]</ref>, the second criterion considers the approximate local curvature along a time line. Let Θ(u, v, w) be defined as</p><formula xml:id="formula_8">Θ(u, v, w) = ( u−v ||u−v|| ⋅ w−v ||w−v|| ) + 1 2<label>(3)</label></formula><p>where u, v, w are three particle coordinates. A particle x i, j is split if</p><formula xml:id="formula_9">Θ(x i, j−1 , x i, j , x i, j+1 ) + Θ(x i, j+2 , x i, j+1 , x i, j ) &gt; β<label>(4)</label></formula><p>In this way, the deviation of the time line from a straight line is approximated and used to steer the local time line refinement. Particle splitting is performed by fitting a cubic polynomial p(t) through x i, j−1 , x i, j , x i, j+1 and x i, j+2 , and by evaluating p(t) at t = <ref type="bibr" target="#b0">1</ref> 2 :</p><formula xml:id="formula_10">p(1/2) = − 1 16 (x i, j−1 + x i, j+1 ) + 9 16 (x i, j + x i, j+2 )<label>(5)</label></formula><p>Based on the indices id i, j of the initially seeded particles x i, j , every new particle on a time line gets assigned its index in the ordered set of all possible particles along this line as described in the previous section for surfaces patches. We will subsequently call these indices the particle ids. <ref type="figure" target="#fig_6">Figure 5</ref> illustrates the changes in the particle layout on a time line due to refinement and coarsening events.</p><p>To prevent the streak surface from unlimited stretching, we adapt a criterion that was proposed for stream surfaces in <ref type="bibr" target="#b8">[9]</ref>. We compare the current distance between two particles to their distance in the last time step in relation to the distance a particle has moved due to the integration. Let Ψ(x, y,t) be the distance between particles x and y at time t, and x i, j,t the position of particle x i, j at time t. We mark an edge as invalid, meaning that it will not be refined any further, if the following expression evaluates to true:</p><formula xml:id="formula_11">Ψ(x i, j , x i, j+1 ,t) − Ψ(x i, j , x i, j+1 ,t − 1) &gt; γ Φ(x i, j,t , x i, j,t−1 )<label>(6)</label></formula><p>If an edge has been classified as invalid or cannot be refined any further, it is not considered in the triangulation of the streak surface described below. In this way, the surface is cut in regions where it stretches too much, e.g., if it evolves around obstacles in the flow as demonstrated in <ref type="figure" target="#fig_7">Figure 6</ref>. Finally, in addition to inserting new particles we remove a particle x i, j if the following condition is met:</p><formula xml:id="formula_12">(Φ(x i, j , x i, j−1 ) + Φ(x i, j , x i, j+1 ) &lt; δ Ξ) ∧ (Θ(x i, j−1 , x i, j , x i, j+1 ) + Θ(x i, j , x i, j+1 , x i, j+2 ) &lt; ζ )<label>(7)</label></formula><p>Due to this coarsening we avoid vertex clustering in regions of high convergence, and we prevent the generated triangles from becoming too small. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.2">Connectivity update</head><p>Due to time line refinement and coarsening the connectivity between particles on adjacent time lines has to be computed in each integration step. Therefore, every particle on time line tl i searches for the particle on tl i+1 and the one on tl i−1 having the id closest to its own one on the respective time line. We will call these two particles the predecessor and the successor of a particle. In particular, for a particle x i, j we select the successor x i+1,succ with the closest id ≤ the particle's id and the predecessor x i−1,pred with the closest id ≥ the particle's id (see <ref type="figure">Figure 7</ref> (a)). Once the predecessor and the successor have been determined, references to them are stored as offsets to the absolute position of the particle in the vertex array buffer, and they are used as described below to build a closed surface representation. Finding the two particular neighbors requires every particle to search the vertex buffer to the left and to the right of it, with the search radius depending on the number of particles on time lines tl i−1 ,tl i and tl i+1 . We will describe in Section 6.3 how to determine these numbers in a very efficient way on the GPU. x i,j</p><p>x i-1,pred</p><p>x i+1,succ</p><p>x i+1,succ+1 <ref type="figure">Fig. 7</ref>. (a) Each particle on time line tl i selects its successor (red arrows) and predecessor (green arrows) on adjacent time lines based on the closest matching particle id. (b) The distance estimate of a particle x i, j to its adjacent time line tl i+1 is based on an intermediate particle z, exhibiting the same particle id.</p><formula xml:id="formula_13">x i-1,pred-1 z dist tl i+1 tl i tl i-1 tl i+1 tl i tl i-1 x i,j (a) (b)</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1.3">Streak line refinement</head><p>In this pass, a complete time line is added to or removed from the streak surface. The criterion to steer the refinement/coarsening is based on the maximum Euclidean distance between neighboring time lines.</p><p>A new time line is inserted between tl i and tl i+1 if the maximum of the shortest distances between particles on tl i and the time line tl i+1 exceeds a user defined threshold. An existing time line is removed if the maximum of the shortest distances to both adjacent time lines falls below a given threshold. Unfortunately, since we do not know the exact time line between the given vertices, computing the shortest distance from a particle to this line is not possible in general. Therefore, we proceed as follows: Since x i+1,succ is the closest existing control point on tl i+1 with id i+1,succ ≤ id i, j and its adjacent particle x i+1,succ+1 has a larger particle id, we first interpolate an intermediate position z on the line segment spanned by x i+1,succ and x i+1,succ+1 as follows:</p><formula xml:id="formula_14">a = id i, j − id i+1,succ id i+1,succ+1 − id i+1,succ z = x i+1,succ + a(x i+1,succ+1 − x i+1,succ )<label>(8)</label></formula><p>We then compute the Euclidian distance between x i, j and z, and we use this distance as the shortest distance of x i, j to the time line tl i+1 . The distance to the preceding time line tl i−1 is determined analogously (see <ref type="figure">Figure 7</ref>(b)).</p><p>A new particle front that is added due to streak line refinement contains the same number of particles as the time line triggering the refinement event. As shown in <ref type="figure" target="#fig_9">Figure 8</ref>, the new front is stored as a contiguous block in the vertex buffer right before this time line. Particle positions and normal values are linearly interpolated between x i, j and intermediate values on tl i+1 as described in Equation <ref type="formula" target="#formula_14">8</ref>. </p><formula xml:id="formula_15">tl 2 tl r tl 1 tl 0 (a) (b) tl 2 tl 1 tl 0 tl 2 tl r tl 1 tl 0</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Streak Surface Triangulation and Rendering</head><p>To render the surface as a watertight triangle mesh a final pass is executed. Prior to triangulation, a geometry shader validates the connectivity and updates the neighborhood for all particles residing on time lines whose adjacent time lines have been removed due to streak line refinement.</p><p>A closed surface representation is generated by using the particle connectivity to compute a triangulation of adjacent time lines. For each particle that is sent to the rendering pipeline the geometry shader creates two triangles and appends them to the output stream. The first triangle is spanned by the vertex x i, j , its local right neighbor x i, j+1 , and its successor on the time line tl i+1 . The second triangle consists of the vertex x i, j , its local left neighbor x i, j−1 , and its predecessor on the time line tl i−1 . Since this process is performed for every vertex, a watertight surface is generated. <ref type="figure" target="#fig_11">Figure 10</ref> illustrates this triangulation process.</p><p>Triangles containing an edge that was marked invalid due to the criterion in Equation (6) are excluded from the output stream. Note that particles on the surface border (i = 0 ∨ i = n ∨ j = 0 ∨ j = m) contain at least one invalid neighbor, such that the corresponding triangle is also excluded from the stream out. Once the triangulation has been generated it can be rendered directly using various rendering styles. Since the tupels i, id i, j that are stored for each particle correspond to a surface parametrization, they can be used to texture the streak surface. In <ref type="figure" target="#fig_10">Figure 9</ref> (a) this parametrization was used to color the surface with streak lines. In (b) depth peeling was applied to create a semi transparent visualization of the streak surface, which was combined with image based edge detection to amplify sharp features on the streak surface. . In (c) the two triangles generated by the vertex x i, j are colored blue. Colored yellow are the two triangles generated by vertex x i, j+1 .</p><formula xml:id="formula_16">tl i-1 tl i tl i+1 x i,j x i,j-1 x i,j+1 x i-1,pred x i+1,succ</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.3">GPU Implementation</head><p>In mesh-based streak surface generation, analogously to the particles, each time line gets assigned a unique id and a counter indicating its refinement depth. For a time line released at time t i = t 0 + i ∆t the id is set to 0 and incremented by 2 d in each time step. New time lines that are added due to a refinement event adapt this key in the same way as it was described for particles before. This key is then used by the particles on each time line to index into a 1D array-having as many entries as there can be time lines-that stores time line specific information. On the GPU, this array is realized as 2D texture to avoid texture resolution limits. <ref type="figure" target="#fig_13">Figure 11</ref> shows the content of this array for a set of time lines before (a) and after one integration step (b). Furthermore, each particle carries two additional offsets, which are used in combination with the time line id to determine the id of adjacent time lines. These offsets are initialized with 2 d and changed accordingly whenever streak line refinement adds/removes an adjacent time line. Parallel to the buffer update during time line refinement (see 6.1.1), we bind a texture render target to the rendering pipeline and rasterize each particle as a point primitive into the texel indexed by the respective time line id. By using additive blending, the number of particles residing on each time line is obtained and can be accessed by the particles during the connectivity update and streak line refinement passes.</p><formula xml:id="formula_17">tl i-2 tl i-1 tl i 3 4 3 tl i-1 tl i 4 3 3 tl i+1 tl i-1 tl i 4 3 3 tl</formula><p>In the connectivity update pass every particle writes to a second array its absolute position in the vertex array buffer in the same way. By using a maximum blend operator, the second array contains for each time line the absolute vertex buffer position of the last particle on the respective time line. These values are needed in the streak line refinement pass to append all particles on a new time line as contiguous block to the vertex array buffer. Additionally, for each particle its distance to neighboring time lines is computed during the connectivity update, and the maximum distance to each adjacent time line is stored separately in an additional texture target. These values are then used in streak line refinement to evaluate the refinement criterion.</p><p>To find successors for particles on tl i , the connectivity pass has to search in an interval containing as much elements as there are on tl i and tl i+1 because the absolute position of a particle in its respective memory block b i is not yet known. The tuple of time line and particle ids forms a strictly monotonic increasing key over the whole vertex array buffer that is used in a binary search in the interval to the left of a particle to find its successor. The predecessor is determined analogously.</p><p>In streak line refinement, new time lines are appended as contiguous blocks to the vertex array buffer. Each particle on a time line tl i that triggered a streak line refinement decides based on its absolute position in the memory block b i whether it should contribute two particles to the new time line or account for two particles of tl i .</p><p>During both refinement passes, we do not remove neighboring particles/time lines at once. If multiple adjacent particles satisfy the coarsening criterion in the time line refinement pass, we remove only every second particle. The decision which particle will be removed is based on a modulo criterion applied to the tuple of particle id and depth counter. Analogously we do not remove adjacent time lines at once during the streak line refinement pass.</p><p>To validate our methods for GPU-based streak surface generation and rendering, we have realized the developed algorithms with the DirectX 10 API. Performance tests were carried out on a 2.66 GHz Core 2 Duo processor, equipped with a NVIDIA GTX280 graphics card with 1024 MB local video memory. Results were rendered to a 2560 × 1600 viewport. In all of our experiments an explicit fourth-order Runge-Kutta scheme at single floating point precision was used for numerical particle integration. Detailed timings for interactive streak surface construction and rendering are given below. For the efficient handling of time-varying flow fields on the GPU we utilize the two-stage streaming approach that was presented in <ref type="bibr" target="#b4">[5]</ref>.</p><p>We have tested the proposed approaches in two real-world scenarios consisting of time dependent 3D simulation results given on Cartesian grids:</p><p>• Flow around a square cylinder: Result of a DNS simulation of the three-dimensional flow around a square cylinder between parallel walls at Re = 220.0 <ref type="bibr" target="#b11">[12]</ref>. The simulation was carried out on an unstructured tetrahedral grid. We used a resampled version with a uniform grid resolution of 192 × 64 × 48 and a temporal resolution of 102 steps in the course of our work.</p><p>• Flow around a cylinder: Large eddy simulation of an incompressible unsteady turbulent flow around a wall-mounted cylinder at Re = 200.000 <ref type="bibr" target="#b5">[6]</ref>. 22 time steps were simulated. The size of the data grid is 256 × 128 × 128.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.1">Performance</head><p>Representative timings in milliseconds (ms) for integration, adaptive refinement and rendering using the patch-based approach are listed in <ref type="table">Table 1</ref>. Values in the first three columns show the number of patches n, the maximum particle lifetime m, and the refinement depth d. The values in column labeled Pts show the average number of surface patches. Column Int contains timings for integration and refinement, Vis for the rendering of the resulting surface, and column Ttl the total amount of time required for the construction of the adaptively refined streak surface and subsequent rendering. As some of the presented settings require buffers larger than the available GPU memory, we used static buffer sizes independent of the chosen parameters but increased their size in case of a buffer overflow and restarted the performance test.  <ref type="table">Table 1</ref>. Performance statistics for the patch-based streak surface generation and rendering. Timing statistics in milliseconds are listed in columns 5-7. Even for more than one million surface patches the streak surface construction and rendering took less than 60 milliseconds.</p><p>Timing statistics for mesh-based streak surface generation and rendering are given in <ref type="table">Table 2</ref>. The maximum depth for both refinement strategies were equally set to d. Values in the column labeled Pts contain the number of surface particles, column Int and Con show the times that were required for particle integration including time-line refinement and the connectivity update, respectively. Column Slr gives timings for streak line refinement and column Vis gives the time required for surface triangulation and rendering. Finally, column Ttl shows the total time required for the construction and rendering of the adaptively refined triangular mesh.  <ref type="table">Table 2</ref>. Performance statistics for the mesh-based streak surface generation and rendering. Columns 5-9 present timings in milliseconds. The construction and rendering of a mesh-based streak surface consisting of more than 350K particles took less than 40 milliseconds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.2">Quality Comparison</head><p>To compare the visual quality, we have used both approaches to generate the same streak surfaces at comparable sample densities. As shown in <ref type="figure" target="#fig_1">Figure 12</ref>, the patch-based approach suffers from artifacts that are common to point-splatting approaches. In particular, the patch alignment in regions of high curvature tends to produce rather rough surface structures. While increasing the patch areas can cure those artifacts, it tampers with the actual extracted streak surface and requires to increase the bias of the attribute pass. This, however, in turn leads to the accumulation of incoherent surface parts. In addition, blending of overlapping patch attributes tends to blur high frequent surface features. The mesh based approach, on the other hand, avoids all these problems and delivers a closed surface representation that can be rendered using standard polygon rasterization. Sharp features and high frequent geometric details are preserved and the interpolation of vertex normals results in a smooth illumination. <ref type="figure" target="#fig_1">Fig. 12</ref>. This image shows the same streak surface that was generated using the patch-based (top) and the mesh-based (bottom) approaches at comparable sample density. While patch-based splatting results in artifacts and blurring at fine surface details and silhouettes, the meshbased approach yields a high-quality surface representation.</p><p>To achieve comparable quality, the patch-based approach requires a significantly higher sampling density. The following plot shows the sample density of both approaches, extracting streak surfaces at comparable visual quality. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7.3">Conclusion</head><p>In this paper, we have presented two real-time techniques for constructing and rendering adaptively refined streak surfaces on the GPU. The patch-based approach performs particle integration and adaptive refinement in one step. In the proposed setup we tried to minimize additional complexity regarding the refinement criterion, integration expense and the maximum output performed by the geometry shader, resulting in real time performance even for huge amounts of patches traced in parallel. We also presented visualization methods for this representation by adapting point-splatting techniques to render the loose patch set as closed surface. The mesh-based approach addresses the increased integration expense by introducing connectivity information between the surface samples. This does not only remove redundant particle integration but also allows the application of more sophisticated adaption criteria as well as coarsening the particle set during surface construction. On that account, the mesh-based approach delivers visually comparable streak surfaces to the patch-based approach with a much smaller set of surface samples. Furthermore, the closed surface representation can be rendered outright and a multitude of rendering styles can be applied efficiently.</p><p>We are aware of the fact that the current triangulation can lead to distorted triangles in highly diverging flow regions or areas of high shear strain between adjacent time lines. Thus, we will investigate alternative triangulation methods in the near future.</p><p>As the proposed techniques have only been validated for flow fields on cartesian grids, we will investigate their performance on unstructured grids in the near future. Since none of our techniques inherently depend on a uniform grid structure, we expect this implementation to be straightforward. Yet, as particle tracing in unstructured grids comes at an additional expense due to more complex operations for point location and interpolation, it will most likely make the meshbased approach the favorable technique not only in terms of quality of the resulting image but also performance wise.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Manuscript received 31</head><label>31</label><figDesc>March 2009; accepted 27 July 2009; posted online 11 October 2009; mailed on 5 October 2009. For information on obtaining reprints of this article, please send email to: tvcg@computer.org .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Fig. 2 .</head><label>2</label><figDesc>(a) A patch-based streak surface representation after the first time line has been released. (b) Left: Patch p 0,1 meets the refinement criterion and is split into two patches. Right: The surface patches after the second integration step. The generation of new surface points due to the splitting operation has lead to a hole in the surface representation. (c) The corresponding layout of the linear memory segments storing the surface patches in each time step.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fig. 3 .</head><label>3</label><figDesc>(Left) Rendering of the patch centroids of a patch-based streak surface. (Right) The same streak surface rendered via quad-splatting.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 4 .</head><label>4</label><figDesc>(a) Separate triangulation and rendering of each patch leads to holes in the streak surface. (b) Holes are covered by rendering enlarged patches. (c) Rendering enlarged patches in a way similar to high-quality point splatting yields a closed and smooth surface visualization.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Fig. 5 .</head><label>5</label><figDesc>(a) In each time step a new time line is released from the seeding line. Node values show particle ids. (b) Left: Prior to integration, each particle x i, j evaluates refinement criteria based on its local neighborhood (red). Middle: x i, j satisfies a refinement criterion and performs a particle split. Right: The resulting time line after the subsequent integration step. (c) Evolution of a time line over four integration steps. Green and red nodes indicate refinement and coarsening events, respectively. Numbers next to the nodes indicate the refinement level. (d) Changes in the linear memory segment b i due to vertex refinement/coarsening. all possible patches along the seeding structure. Starting with the initial patches p i,v , which are assigned the positions v × 2 d , in every refinement step the first new patch keeps the position of the refined patch and the second patch adds 2 d−k to this position. Here, k is the current refinement level. The index i of each patch is assigned as the second parameter value.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Fig. 6 .</head><label>6</label><figDesc>Application of criterion (6) prevents a streak surface from unlimited stretching by cutting edges if no additional refinement can be performed.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Fig. 8 .</head><label>8</label><figDesc>Streak line refinement: (a) The time line tl 1 satisfies the refinement criterion and spawns the new time line tl r . The corresponding changes in the vertex array buffer are illustrated in (b).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Fig. 9 .</head><label>9</label><figDesc>(a) The surface parametrization, consisting of time line and particle ids, is used to color the surfaces with stream lines. (b) Visualization of transparent streak surfaces by application of depth peeling.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Fig. 10 .</head><label>10</label><figDesc>Streak surface triangulation: (a) Vertex connectivity and refinement events: Green edges indicate vertex splitting, blue edges indicate vertex merging, and red edges indicate streak line refinement. The resulting triangulation is shown in (b)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>Figure 11(c) depicts the change of offsets due to the refinement of time line tl i−1 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Fig. 11 .</head><label>11</label><figDesc>Three time lines of nine possible time lines exist. The number of vertices on each time line is stored in corresponding entries in a 1D array. Red/green arrows indicate the offsets every time line stores to its neighbors in the array. (a) Array indices before and (b) after one integration step. (c) Offsets to adjacent time lines change due to streak line refinement.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head></head><label></label><figDesc>Fig. 13. The plots show the sample density of both approaches during streak surfaces generation at comparable visual quality. Top: Statistics for the square cylinder data set. Bottom: Statistics for the LES data set.</figDesc><table><row><cell></cell><cell>150K</cell><cell>Patch-based</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell># Primitives</cell><cell>50K 100K</cell><cell>Mesh-based</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0K</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell>200</cell><cell>400</cell><cell></cell><cell>600</cell><cell>800</cell><cell>1000</cell><cell>1200</cell><cell></cell><cell>1400</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Integration steps</cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>400K</cell><cell>Patch-based</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell># Primitives</cell><cell>100K 200K 300K</cell><cell>Mesh-based</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0K</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell>0</cell><cell>100</cell><cell>200</cell><cell>300</cell><cell>400</cell><cell>500</cell><cell>600</cell><cell>700</cell><cell>800</cell><cell>900</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="2">Integration steps</cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>ACKNOWLEDGMENTS</head><p>The authors wish to thank Simone Camarri and co-workers for providing the square cylinder data set as well as Tino Weinkauf for providing the downsampled version. Furthermore we wish to thank Octavian Frederich et al. for providing the second time-dependent data set.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The Direct3D 10 system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Blythe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH &apos;06: ACM SIGGRAPH 2006 Papers</title>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="724" to="734" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">High-quality surface splatting on today&apos;s GPUs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Botsch</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Hornung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Zwicker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Kobbelt</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Eurographics/IEEE VGTC Symposium Point-Based Graphics</title>
		<meeting>Eurographics/IEEE VGTC Symposium Point-Based Graphics</meeting>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="volume">0</biblScope>
			<biblScope unit="page" from="17" to="141" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Real-Time Outof-Core Visualization of Particle Traces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">W</forename><surname>Bruckschen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Kuester</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE 2001 Symposium on Parallel and Large-Data Visualization and Graphics (PVG2001)</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="45" to="50" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Importance-Driven Particle Techniques for Flow Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Bürger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kondratieva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krüger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE VGTC Pacific Visualization Symposium</title>
		<meeting>IEEE VGTC Pacific Visualization Symposium</meeting>
		<imprint>
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Interactive Visual Exploration of Instationary 3D-Flows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Bürger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kondratieva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krüger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics/IEEE VGTC Symposium on Visualization (EuroVis)</title>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="251" to="258" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Flow Simulation around a Finite Cylinder on Massively Parallel Computer Architecture</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">O</forename><surname>Frederich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Wassen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Thiele</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">International Conference on Parallel Computational Fluid Dynamics</title>
		<imprint>
			<date type="published" when="2005" />
			<biblScope unit="page" from="85" to="93" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Generation of Accurate Integral Surfaces in Time-Dependent Vector Fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Garth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Krishnan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Tricoche</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Bobach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">I</forename><surname>Joy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1404" to="1411" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Surface Techniques for Vortex Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Garth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">X</forename><surname>Tricoche</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Salzbrunn</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Bobach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Scheuermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Joint Eurographics -IEEE TCVG Symposium on Visualization</title>
		<meeting>Joint Eurographics -IEEE TCVG Symposium on Visualization</meeting>
		<imprint>
			<date type="published" when="2004" />
			<biblScope unit="page" from="155" to="164" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Constructing stream surfaces in steady 3D vector fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P M</forename><surname>Hultquist</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VIS &apos;92: Proceedings of the 3rd Conference on Visualization &apos;92</title>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="171" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A Particle System for Interactive Visualization of 3D Flows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Krüger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kipfer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Kondratieva</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Westermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="744" to="756" />
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Feature Extraction and Visualisation of Flow Fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><forename type="middle">H</forename><surname>Post</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Vrolijk</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Hauser</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Laramee</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Doleisch</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics 2002 State of the Art Reports</title>
		<imprint>
			<date type="published" when="2002" />
			<biblScope unit="page" from="69" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Simulation of the threedimensional flow around a square cylinder between parallel walls at moderate Reynolds numbers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Camarri</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Salvetti</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Buffoni</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Iollo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of XVII Congresso di Meccanica Teorica ed Applicata</title>
		<meeting>XVII Congresso di Meccanica Teorica ed Applicata</meeting>
		<imprint>
			<date type="published" when="2005" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Point-based Stream Surfaces and Path Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Schafhitzel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Tejada</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Weiskopf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Ertl</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Graphics Interface</title>
		<meeting>Graphics Interface</meeting>
		<imprint>
			<date type="published" when="2007" />
			<biblScope unit="page" from="289" to="296" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">A Tetrahedra-based Stream Surface Algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Scheuermann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Bobach</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">H K</forename><surname>Mahrous</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Hamann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Joy</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Kollmann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VIS &apos;01: Proceedings of the Conference on Visualization &apos;01</title>
		<imprint>
			<date type="published" when="2001" />
			<biblScope unit="page" from="151" to="158" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Interactive Particle Tracing on Tetrahedral Grids Using the GPU</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Schirski</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Bischof</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Kuhlen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Vision, Modeling, and Visualization (VMV)</title>
		<meeting>Vision, Modeling, and Visualization (VMV)</meeting>
		<imprint>
			<date type="published" when="2006" />
			<biblScope unit="page" from="153" to="160" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Smooth Stream Surfaces of Fourth Order Precision</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Schneider</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Wiebel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Scheuermann</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Eurographics/IEEE VGTC Symposium on Visualization (EuroVis)</title>
		<imprint>
			<date type="published" when="2009" />
			<biblScope unit="page" from="871" to="878" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Interactive Visualization of Three-Dimensional Vector Fields with Flexible Appearance Control</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-W</forename><surname>Shen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G.-S</forename><surname>Li</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><forename type="middle">D</forename><surname>Bordoloi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="434" to="445" />
			<date type="published" when="2004" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">Fast Texture-based Algorithms for Vector Field Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Stalling</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1998" />
		</imprint>
		<respStmt>
			<orgName>FU Berlin, Department of Mathematics and Computer Science</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Implicit Stream Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">J</forename><surname>Van Wijk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">VIS &apos;93: Proceedings of the 4th Conference on Visualization &apos;93</title>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="245" to="252" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Smoke Surfaces: An Interactive Flow Visualization Technique Inspired by Real-World Flow Experiments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Funck</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Weinkauf</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Theisel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H.-P</forename><surname>Seidel</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Visualization and Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">6</biblScope>
			<biblScope unit="page" from="1396" to="1403" />
			<date type="published" when="2008" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
