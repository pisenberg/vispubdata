<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fine-Grain Visualization Algorithms in Dataflow Environments</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Deyang</forename><surname>Song</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign Urbana</orgName>
								<address>
									<postCode>61801-2987</postCode>
									<region>IL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Golin</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Illinois at Urbana-Champaign Urbana</orgName>
								<address>
									<postCode>61801-2987</postCode>
									<region>IL</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Fine-Grain Visualization Algorithms in Dataflow Environments</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:29+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>computer architectures to explore fine-grained con-Most of the current dataflow visualization systems are based on coarse-grain dataflow computing models. I n this paper we propose a fine-grain dataflow model that takes advantage of data locality properties of m a n y visualization algorithms. A fine-grain module works on small chunks of data one at a t i m e by keeping a dynamically adjusted moving window on the input data stream. It is more m e m o r y efficient and has the potential of handling very large data sets without taking up all the m e m o r y resources. T w o popular visualization algorithms, an iso-surface extraction algorithm (11 and a volume rendering algorithm [2], are implemented using the fine-grain model. T h e performance measurements showed faster speed, reduced memory usage, and improved CPU utilization over a typical coarse-grain system.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Dataflow visualization systems are being used by many scientists and engineers to build visualization applications. The reason they become popular is because they are flexible and extensible. But the performance issue remains the major problem in these dataflow software systems <ref type="bibr" target="#b3">[3,</ref><ref type="bibr">41</ref>. Dataflow systems tend to take up too much memory and somet,imes run slower than other monolithic systems. In this paper we present a fine-gain dataflow programming paradigm that can reduce the memory consumption, increase the execution speed and CPU utilization of visualization pipelines by controlling the granularity of both data and computations. The fine-grain dataflow model applies equally well to both multiprocessor and distributed systems.</p><p>The notion of dataflow is an ideal abstraction that captures the characteristics of the entire process of scientific visualization <ref type="bibr" target="#b5">[5]</ref>. The concept of dataflow is not new, however. Researchers have worked on dataflow currency in computer programs <ref type="bibr">[6, 71.</ref> Large-grain dataflow software systems have been shown to help problem solving at a high level in areas other than scientific visualization <ref type="bibr" target="#b8">[8,</ref><ref type="bibr" target="#b9">9,</ref><ref type="bibr">10)</ref>. Unix pipelines are examples of linear dataflow systems. They can only be connected in one dimension and they only process one-dimensional character stream. Some early uses of the dataflow model in graphics applications include GRAPE <ref type="bibr">[ll]</ref>, FRAMES <ref type="bibr" target="#b11">[12]</ref>, and ConMan <ref type="bibr" target="#b12">[13]</ref>. Recent applications of the dataflow model to scientific visualization include AVS <ref type="bibr" target="#b13">[14]</ref>, apE <ref type="bibr" target="#b14">[15]</ref>, RIVERS <ref type="bibr" target="#b15">[16]</ref>, Khoros <ref type="bibr" target="#b9">[9]</ref>, IRIS Explorer <ref type="bibr" target="#b16">[17]</ref>, IBM Data Explorer <ref type="bibr" target="#b17">[18]</ref>. There are also dataflow visual programming languages upon which both user interface and individual modules can be built <ref type="bibr" target="#b18">[19]</ref>.</p><p>In traditional dataflow models, tokens are simply assumed to be indivisible and have a flat structure, and node firing is assumed to be atomic. Extended dataflow models relax some of these assumptions. For example, in <ref type="bibr" target="#b19">[20]</ref>, the firing condition is relaxed and the tokens are typed but are of fixed length for a given type. In <ref type="bibr">[21]</ref>, the concept of variable length tokens are proposed to support composite token processing. However, the hierarchical structure of the tokens and the precise description of how they relate to the execution of the nodes have not been studied before.</p><p>In coarse-grain dataflow systems, each node of the dataflow diagram is a functional entity that can be implemented either as a function in a traditional language or as an individual program. The scheduling of these functional units can be done by a special scheduler built into the software system (e.g., in AVS) or by the underlying operating system (e.g., in apE). Every module performs one data processing function supplied by the module builder on the input data objects. Each data set is treated as one frame which is transmitted and processed atomically, much the same way as tokens are treated in a dataflow computer. The three steps of data input, data processing, and data output of one module never overlap in time.</p><p>There are two major problems in these coarse-grain dataflow visualization systems. First, since scientific data sets are inevitably very large, it takes a long time to fill the visualization pipeline. Second, since all of the intermediate data (partial results) have to reside in memory, the memory requirements for a dataflow visualization system are extremely large. These problems have been cited as the major drawbacks of dataflow systems, especially of visualization systems, and as causes of low performance <ref type="bibr">[22, 4,</ref> 231. Th' is paper demonstrates that the performance of dataflow systems can be improved by using a Fine-Grain Dataflow Computing Model.</p><p>Essentially, any computing model that can start processing the input data before seeing its end can be classified as a fine-grain model (or streaming model). For example, a fine-grain module that computes the bounding box of a scattered particle data set can perform its computation while the input data stream is being received, without having to buffer the whole data set. The fine-grain dataflow computing model we propose is called the Syntax-Directed Transformation Method (SDTM), a model that combines the dataflow programming paradigm with the syntaxdirected translation techniques. In this model, data granularity depends on both the module that implements a nodal function in a dataflow network and the actual data that the module receives. Function granularity comes as the result of data granularity. Our granulating method is described in the framework of attribute grammar, a syntax-directed translation technique. This paper concentrates on the algorithmic aspects of turning coarse-grain modules into fine-grain ones, and the reader is referred to <ref type="bibr" target="#b23">[24,</ref><ref type="bibr" target="#b24">25)</ref> for the details of using attribute grammars to define the comput at ions.</p><p>The fine-grain computing model reduces data buffering and generates more efficient data movement. In many cases, memory requirements are sublinear in terms of the input data size. The new approach also leads to execution speedups and improved CPU utilization. We will show that in many cases coarse-grain modules can be converted into fine-grain modules. In the SDTM model, a fine-grain module degenerates to a coarse-grain one in the worst case. The fine-grain model proposed here is applicable to both tightlycoupled systems such as GRAPE and IBM Data Explorer, and loosely-coupled systems such as AVS and apE.</p><p>Section 2 describes how the fine-grain computing model works. Section 3 describes two fine-grain algorithms for doing 3D visualization, and Section 4 re-ports their performance comparivns with coarse-grain modules. Section 5 discusses our experience of designing fine-grain algorithms and some thoughts on future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Fine-grain dataflow models</head><p>The basic idea of the fine-grain model is t o break a large input data set into a sequence of smaller chunks.</p><p>Computations are associated with each small chunk of data. In SDTM, we use grammar rules to describe input data and semantic functions t o represent computations. Each semantic function is attached t o a grammar rule. A computation is started as soon as a meaningful small chunk of data has been received, and output is generated as early as possible. This streaming execution model maintains a continuous flow of data in the visualization pipeline, reducing the size of intermediate buffers to the minimum amount. It has the potential of processing data sets of unlimited size.</p><p>In the ideal case, the speedup of a fine-grain pipeline over a coarse-grain pipeline can be approximated by a linear function of K , the number of stages in the pipeline <ref type="bibr" target="#b23">[24]</ref>. And in the worst case, the speedup approaches 1. In reality, the speedups are often limited by the bottleneck module in the pipeline. Memory requirements for fine-grain modules are often in the or-</p><formula xml:id="formula_0">der of O ( N 2 / 3 ) or O(N'I3),</formula><p>where N is the number of elements in a 3D data set.</p><p>The idea of keeping a window on the input data stream was first proposed by Haber and McNabb in <ref type="bibr" target="#b25">[26]</ref>. In their Rivers software, the data flow is abstracted as a stream of PVD (Per-Vertex Data) structures, each containing an XYZ location, a 3D vector, and an RGB color value. Communicating modules read from or write to a communication port through a moving window that is advanced through the data set. The window size is determined by the communication software implementing the port abstraction and thus is not known a priori to the modules. Each module must account for cases in which the window size is too small or too large. This model supports efficient pipelining of operations on geometric data. But it is not flexible enough to support other data types, and the burden lays on the module developers to build high-level data structures to support other operations.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Fine-grain visualization algorithms</head><p>In this section, we present an implementation of fine-grain algorithms for isc-surface extraction and volume rendering. The general idea for both of the algorithms is to exploit the data locality properties inherent in the algorithms and to work on the input data set slice by slice.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">The iso-surface algorithm</head><p>The fine-grain iso-surface algorithm is a restructuring of the Marching Cubes algorithm <ref type="bibr">[l]</ref>. The algorithm "marches" through each cell in the grid, and generates polygons belonging to a particular iso-surface as it goes. The implementation of the fine-grain algorithm is not particularly hard. In fact, the idea of working slice by slice has been laid out in <ref type="bibr">[l]</ref>. For the iso-surface extraction module, each slice of the threedimensional input data set is a meaningful chunk of data. Associated with each slice is a compute function that constructs surface polygons from that slice. When a slice of data is received, that compute function is called. If transparent iso-surfaces are generated, we must find a viewpoint-dependent order to generate the polygons from slices of data. But if no transparency is concerned, we can simply work slice by slice as the data comes in. Only 4 slices need to be buffered at all times: the current slice just received and the previous 3 slices. In <ref type="figure" target="#fig_0">Figure 1</ref>, slice 4 is the slice just received a t the moment, slices 2 and 3 are used to generate vertices of the polygons and slices 1 and 4 are used to derive gradients which are normalized for surface shading calculations. The efficiency enhancement techniques proposed in <ref type="bibr">[l]</ref> can also be applied here. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">The volume rendering algorithm</head><p>The volume rendering algorithm implements a class of ray-casting algorithms exemplified by the one proposed by Levoy <ref type="bibr" target="#b2">[2]</ref>. It is a two-pass algorithm. In the first pass, voxels are shaded and classified, which generates color and opacity for each voxel. In the second pass, a ray is cast from the eye point through each pixel in the image plane into the volume of data. Along each ray, colors and opacities are resampled at evenly spaced locations, and they are integrated in back-to-front order according to the following compositing formula a t each sample point</p><formula xml:id="formula_1">Gout = (1 -a)Cin + aC (1)</formula><p>where C and a are the color and opacity of the current sample point, Cin and CoUr are the result of the ray integration up to the previous and the current sample point respectively, in back-to-front order. Initially, Cin = cbg is the background color.</p><p>The first pass can be easily implemented using a fine-grain algorithm, which is similar to the one described for the Marching Cubes algorithm. The difficult part is to design a fine-grain algorithm for the second pass, which does ray-casting and ray-integration.</p><p>Suppose there are I&lt; sample points along the ray through a particular pixel and point 1 is closest to the eye point. The calculated color for that pixel can be derived as the following:</p><formula xml:id="formula_2">C = a l C 1 + ( 1 --1 ) C i n , l = alC1 + ( 1 -~Y~)~z C Z + ( 1 -a1)( 1 -a2)Cin, 2</formula><p>. . .</p><formula xml:id="formula_3">= alCl + (1 -al)a'2CZ + (1 -a l ) ( l -aZ)a3c3 + . ' ' + ( 1 -(.I) ' ' . ( I -a K ) C b g<label>(2)</label></formula><p>Equation 2 can be evaluated from left to right. It can also be reformulated as the following and be evaluated from right to left:</p><formula xml:id="formula_4">= WCl+ (1 -(Yl)(Q2C2 + ( 1 -az) [ ' ' ' [ a K C K + (1 -Q K ) C b g ] . . ' 1 ) w K -2 (3)</formula><p>We call the formula in Equation 2 a forward integration formula and the one in Equation 3 a backward integration formula. It turns out that, although ray integration is a viewpoint-dependent computation, we can use one of these two equivalent formulas to implement the ray-casting stage of the volume rendering function in a streaming fashion, i.e. doing the ray casting as the data comes in.</p><p>The second pass (ray-casting and ray-integration) is done in two steps. In the first step, an image buffer is created and initialized. The image buffer contains color and opacity values for each pixel. It stores partial values of the integration until the last slice has been received, at which point the buffer contains the final volume-rendered image. In this step, the viewpoint is known and the geometry of the grid has been received, but the actual voxel data has not come yet. If the direction of a ray is the same as the direction along which the voxel slices progress (the voxel slices always progress from slice 1 to slice L , the total number of slices), the forward integration formula in Equation 2 will be used for ray integration. Otherwise, the backward integration formula in Equation 3 will be used. <ref type="figure">Figure 2</ref> shows an example when backward integration is chosen because voxel slice 1 will be received first and the ray intersection with slice 1 is the last sample point in the integration equation (point Ii' in Equation 3). For optimization reasons, a forward perspective projection of the bounding box of the 3D grid is performed to obtain the 2D bounding box of the image in the image plane. In the image buffer, pixels outside the 2D bounding box are filled with background color. For pixels inside the bounding box, either black color (having RGB values of zero) or the background color is used to initialize their values in the image buffer depending on whether forward or backward integration formula will be applied (see <ref type="figure">Figures 3 and 4)</ref>.</p><p>In the second step, the color and opacity values in the image buffer are updated when successive slices are received. When a slice is received, a perspective projection is done to calculate the affected area in the image buffer. The color and opacity values associated with each pixel in the projected region are updated according to the formulas described in <ref type="figure">Figures 3 and 4</ref>, depending on the direction of integration. These formulas are derived from Equations 2 and 3. It is clear that backward integration requires one less storage cell for each pixel in the image buffer, but the selection of the integration direction is not decided arbitrarily, as has been mentioned before. However, the above analysis does point to a more efficient way to implement this class of algorithms in coarse-grain modules. Also in the inner-most loop (integrating sample points along the rays), the forward integration algorithm requires 3 multiplications and 2 additions, while the backward integration algorithm requires 2 multiplications and 2 additions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Implementation and performance of fine-grain pipelines</head><p>We have implemented the two fine-grain algorithms in two pipelines. The input data set to both pipelines is a 160 x 80 x 80 density field from a 3D jet simulation. Each module is an autonomous Unix process communicating through pipes. The data granularity of each module is a parameter that can be controlled by a command line option. The only difference between a fine-grain pipeline and a coarse-grain pipeline is the granularity of data communication and processing. For example, in the iso-surface pipeline, the minimum grain size is a 2D slice. The iso-surface extraction module onion takes one slice from the upstream module, constructs the surface polygons, and sends them to the downstream module. The three-step process repeats 80 times. Modules read and norm also work slice by slice. Each module in the coarse-grain performs ray-casting and ray integration through a voxel data set. Generates an image.</p><p>Again, the modules in the fine-grain pipeline process data slice by slice. Module c l a s s implements the first pass of the volume rendering algorithm, and module ray implements the second pass. The modules in the coarse-grain pipeline buffer and process the entire data set only once. Note that the input buffer size of one module must be the same as the output buffer size of the upstream module in order to obtain maximum speedup. An output image from the module ray is shown in <ref type="figure">Figure 8</ref>.</p><p>The pipelines are tested in three different configurations: a single-processor system (an SGI Personal Iris), a shared memory multiprocessor system (an SGI VGX 4D3/440), and a distributed multi-machine system (4 Personal Iris'es connected by an Ethernet).</p><p>memory usage were measured in three different computing environments. The speedup is defined as the ratio of the execution time of a coarse-grain pipeline over that of a fine-grain pipeline. Thus the speedup for coarse-grain pipelines is always 1. The CPU utilization is defined as the ratio of user plus system times to real (elapsed) time, all consumed by the whole pipeline. The total memory usage of a pipeline is the sum of the total amount of memory used by each module in the pipeline.</p><p>From these two tables, we can see that fine-grain pipelines perform better than coarse-grain pipelines in all measurements. The most impressive improvement is probably the savings in memory usage. About 80% improvement in execution time is also a noticeable gain. The 100% plus CPU utilization by coarsegrain pipelines is due to the overlap between the output of one module and the input of the next module. Fine-grain pipelines utilize more of such overlaps. The tests also show that the speedup is fairly consistent in both the multiprocessor and distribute systems. The speedup on the single-processor system is due to fewer page swaps by the operating system when running fine-grain pipelines. Note that all the tests were done using a single data set. If multiple data sets are fed into the pipeline, there will be no noticeable speedup, but the same degree of reduction read <ref type="figure">Figure 5</ref>: The iso-surface extraction pipeline. norm onion display read norm <ref type="figure">Figure 6</ref>: The volume rendering pipeline.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>class ray</head><p>in memory usage should still be observed. ory consumption and shortened execution time. On multiprocessor systems where data communication is done via shared memory, the main advantage is reduced memory consumption. In distributed systems where data communication is through message passing, the main advantage is in reduced execution time, since each module may run on a different machine, and the memory consumption is not accumulating on a single machine. Fine-grain modules can co-exist with existing coarse-grain modules, because the interface between modules is well defined by the data language. This shows the advantage of the dataflow systems, that a </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Discussions and future work</head><p>This paper describes fine-grain algorithms that implement iso-surface extraction and volume rendering. Fine-grain pipelines improve performance over coarsegrain pipelines by taking advantage of the data locality property of visualization functions. Dividing the data into a more refined granularity increases the concurrency among modules. The longer the pipeline, the bigger potential there is to improve performance using fine-grain modules.</p><p>Two performance advantages of using fine-grain pipelines are visible to ordinary users: reduced mem-pass. If the algorithm is implemented by a single module, the output from the first pass must be buffered.</p><p>Of course not all visualization functions can be implemented in a streaming fashion. But there are a large number of functions that have corresponding fine-grain algorithms to implement them. So far, we have identified fine-grain algorithms that can implement functions like normalization, color-mapping, texture mapping, iso-surface extraction, contouring, hidden-line hidden-surface removal, and volume rendering. Here we assume that the data is generated on a rectilinear grid. Some functions whose fine-grain algorithms may be hard or impossible to find include streamline integration, ray-tracing, etc.</p><p>The task of restructuring coarse-grain algorithms or designing new fine-grain algorithms is easier for some and harder for others. It is relatively easy to Pipeline Coarse grain Fine grain  implement the Marching Cubes algorithm in a finegrain way. For Levoy's volume rendering algorithm it is not clear at the first look that a fine-grain algorithm can be found. Writing a fine-grain module is usually harder than writing a coarse-grain module.</p><p>The fine-grain implementation of the volume rendering algorithm contains 2971 lines of C code, while the original implementation of the coarse-grain algorithm in apE contains only 1784 lines of code. In another implementation of a fine-grain module slicer <ref type="bibr" target="#b23">[24]</ref>, which takes a 2D orthogonal slice from a 3D data set, the increase is from 732 lines of code to 1292 lines.</p><p>Because of the difficulties in building fine-grain modules, we have developed an automatic module generation system to help module writers specify granularity of data and computations. We extended a compiler generation tool PCCTS <ref type="bibr" target="#b26">[27]</ref> that can translate syntactic and semantic specifications of a module into a C program. This allows the module writers to concentrate on writing the semantic functions without worrying about the data parsing part.</p><p>Our future work includes refinement of the finegrain model. The fine-grain model and the module generation tool provide a good framework to start with. But there are many other issues that could have better solutions. Selecting a good chunk size is still an art at this point. We are planning to work on ways that can determine the best chunk size automatically. Fine-grain algorithms can also be parallelized. But a balance has to be found between the granularity of the input data and the granularity of parallelization. This has practical values in massively-parallel systems.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>A fine-grain algorithm for iso-surface extraction.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :Figure 4 :</head><label>34</label><figDesc>If divided into slices, it consists of 80 slices, each slice Initialization: C = 0 a = l for each sample point i := 1 to K do begin c = c -4c i * a * ai a = a * ( 1ai) end Forward integration algorithm. Variable C represents color and a represents opacity. Initialization: C = background for each sample point i := K t o 1 do begin end c = c* (1a;) +c; * a ; Backward integration algorithm. Variable C represents color. is a 2D array of 160 x 80 points. consists of the following modules: read loads data from files; norm The pipeline that extracts iso-surfaces (Figure 5) normalizes 3D data using either a linear, logarithmic, exponential, or user-defined function; onion extracts an iso-surface from a 3D scalar field; d i s p l a y displays triangulated polygons</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 : 7 .</head><label>27</label><figDesc>An example of backward integration for ray-casting. The ray in the graph intersects with slices from 1 to m. pipeline processes the entire 80 slices at one time. An image dump from the module d i s p l a y is shown in The VGX machine has 256 MBytea of main memory, and each Personal Iris has 16 MBytes of main memory. Tables 1 and 2 compare the performance of the pipelines. The speedup, CPU utilization, and total Figure consists of the following modules: The Pipeline that does rendering (Figure 6) coarse-grain pipelines with that of the fine-grain files; normalizes 3D data using either a linear, logarithmic, exponential, or user-defined function; maps each voxel into an opacity value and an RGB color;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 7 :Figure 8 :</head><label>78</label><figDesc>An set. from a 3D jet simulation data Volume rendering of the same 3D jet simulation data set.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>Table 1 :</head><label>1</label><figDesc>Performance comparison of coarse-grain and fine-grain implementations of an isc+surface construction pipeline.</figDesc><table><row><cell></cell><cell cols="2">Single-processor</cell><cell cols="2">Multi-processor</cell><cell cols="2">Distributed</cell></row><row><cell>Total</cell><cell></cell><cell>CPU</cell><cell></cell><cell>CPU</cell><cell></cell><cell>CPU</cell></row><row><cell>Memory 18.0 MByte</cell><cell cols="6">Speedup Utilization Speedup Utilization Speedup Utilization 1.0 94% 1.0 146% 1 .o 139%</cell></row><row><cell>2.6 MByte</cell><cell>1.17</cell><cell>99%</cell><cell>1.65</cell><cell>244%</cell><cell>1.76</cell><cell>241%</cell></row><row><cell>Pipeline</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Coarse grain</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell>Fine grain</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Performance comparison of coarse-grain and fine-grain implementations of a volume rendering pipeline.</figDesc><table><row><cell></cell><cell cols="2">Single-processor</cell><cell cols="2">Multi-processor</cell><cell cols="2">Distributed</cell></row><row><cell>Total</cell><cell></cell><cell>CPU</cell><cell></cell><cell>CPU</cell><cell></cell><cell>CPU</cell></row><row><cell>Memory 20.4 MByte</cell><cell cols="6">Speedup Utilization Speedup Utilization Speedup Utilization 1.0 96% 1 .o 124% 1 .o 138%</cell></row><row><cell>1.88 MByte</cell><cell>1.01</cell><cell>98%</cell><cell>1.84</cell><cell>228%</cell><cell>1.44</cell><cell>202%</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>The research conducted by the authors was inspired </p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A high resolution 3d surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRAPH&apos;87</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m">Conference Proceedings</title>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="page" from="163" to="170" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Display of surfaces from volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="page" from="29" to="37" />
			<date type="published" when="1988-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Perspectives on the iris explorer visualization environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Globus</surname></persName>
		</author>
		<idno>RNR-92-021</idno>
		<imprint>
			<date type="published" when="1992-05" />
		</imprint>
		<respStmt>
			<orgName>NASA Ames Research Center, NAS Systems Division, Applied Research Branch</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">technical report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Future directions of visualization software environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">SIGGRA PHI91 Panel Proceedings</title>
		<imprint>
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">ape: Providing visualization tools for a statewide supercomputing network</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Dyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 24th Semi-Annual Cray Users Group Meeting</title>
		<meeting>the 24th Semi-Annual Cray Users Group Meeting<address><addrLine>Trondheim, Norway</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1989" />
			<biblScope unit="page" from="237" to="241" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Data flow supercomputers</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B</forename><surname>Dennis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">13</biblScope>
			<biblScope unit="page" from="48" to="56" />
			<date type="published" when="1980-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Models of data flow computation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">B</forename><surname>Dennis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Control Flow and Dataflow: Concepts of Distributed Programming</title>
		<editor>M. Broy</editor>
		<imprint>
			<date type="published" when="1984" />
			<biblScope unit="page" from="346" to="398" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Parallel processing with large grain data flow techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">G</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">17</biblScope>
		</imprint>
	</monogr>
	<note>Babb 11</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Visual language and software development environment for image processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rasure</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Imaging Systems and Technology</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Grape: An environment to build display processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Suhler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Parallel and Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="103" to="115" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
	<note>Computer Graphics</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Frames: Software tools for modeling rendering and animation of 3d scenes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Potmesil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Hoffert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="85" to="93" />
			<date type="published" when="1987-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Conman: A visual programming language for interactive graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">E</forename><surname>Haeberli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">The application visualization systems: A computational environment for scientific visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="1989-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A dataflow toolkit for visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Dyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">IO</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">Scientific visualization and the rivers project at the national center for supercomputing applications</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">B</forename><surname>Haber</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="84" to="89" />
			<date type="published" when="1989-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">IRIS Explorer User&apos;s Guide</title>
	</analytic>
	<monogr>
		<title level="j">Silicon Graphics, Inc</title>
		<imprint>
			<biblScope unit="issue">3</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An architecture for a scientific visualization system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lucas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;92</title>
		<meeting>Visualization &apos;92<address><addrLine>Boston, Massachusetts</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="107" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Data flow visual programming languages</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">D</forename><surname>Hils</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Visual Languages and Computing</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="1" to="32" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">System Oriented Extensions to Dataflow</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>Landry</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1981-05" />
			<pubPlace>Lafayette</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Dept. of Computer Science, Univ. of Southwestern Louisiana</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">PhD thesis</note>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">A pipelined dataflow processor architecture based on a variable length token concept</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Uchida</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Temma</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1988 International Conference on Parallel Processing</title>
		<meeting>the 1988 International Conference on Parallel Processing</meeting>
		<imprint>
			<date type="published" when="1988-08" />
			<biblScope unit="page" from="209" to="216" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">A software architecture for integrated modeling and animation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Chmilar</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Wyvill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">New Advances in Computer Graphics (Proceedings of CG International &apos;89)</title>
		<imprint>
			<date type="published" when="1984" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="60" to="69" />
		</imprint>
	</monogr>
	<note>draft ed.</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">ape evaluation report</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Walsten</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Garver</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">system development group report, National Center for Supercomputing Applications</title>
		<imprint>
			<date type="published" when="1991-02-27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">A finegrain dataflow model for scientific visualization systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Golin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Norman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Workshop Papers of the Fourth Eurogmphics Workshop on Visualization in Scientific Computing</title>
		<meeting><address><addrLine>Abingdon, UK</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">A fine-grain dataflow model in distributed scientific visualization software systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Song</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
		<respStmt>
			<orgName>Dept. of Computer Science, Univ. of Illinois at Urbana-Champaign</orgName>
		</respStmt>
	</monogr>
	<note>ph.d. thesis in preparation</note>
</biblStruct>

<biblStruct xml:id="b25">
	<analytic>
		<title level="a" type="main">Eliminating distance in scientific computing: An experiment in televisualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">B</forename><surname>Haber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Mcnabb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Ellis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The International Journal of Supercomputing Applications</title>
		<meeting><address><addrLine>winter</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="page" from="71" to="89" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b26">
	<monogr>
		<title level="m" type="main">Purdue compilerconstruction tool set</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Parr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Dietz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Cohen</surname></persName>
		</author>
		<idno>TR-EE 90- 14</idno>
		<imprint>
			<date type="published" when="19901990" />
		</imprint>
		<respStmt>
			<orgName>School Of Electrical Engineering, Purdue University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
