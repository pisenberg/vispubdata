<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Data Shaders</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Corrie</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">ACT</orgName>
								<orgName type="institution">Australian National University Canberra</orgName>
								<address>
									<postCode>0200</postCode>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Mackerras</surname></persName>
							<affiliation key="aff0">
								<orgName type="department" key="dep1">Department of Computer Science</orgName>
								<orgName type="department" key="dep2">ACT</orgName>
								<orgName type="institution">Australian National University Canberra</orgName>
								<address>
									<postCode>0200</postCode>
									<country key="AU">Australia</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Data Shaders</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:29+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>The process of visualizing a scientific data set mquires an extensive knowledge of the domain in which the data set as created. Because an in-depth knowledge of all scientific domains is not available to the creator of visualization software, a flexible und extensible visualization system is essential in providing a productive tool to the scientist. This paper presents a shading language, based on the RenderMan sh,ading language, that extends the shading model used to render volume data sets. Data shaders, written in this shading language, give the users of a volume Tendering system a means of specifying how a vo1um.e data set is to be rendered. This flexibility is useful both as a visualization tool in the scientific community and as a research tool in the visualization community. 2 Volume rendering Volume rendering is a conceptually straightforward process. The volume is divided into volume elements, or voxels. The voxels that contribute to each pixel in the image are determined, and the contributions of 275</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>As science is a diverse and far reaching topic, scientific visualization must be prepared to deal with diverse requirements when scientific data sets are examined, explored, and analyzed. In many cases, domain specific knowledge about the data sets being investigated is essential to the understanding of the those data sets. Although modular visualization environments, such as AVS <ref type="bibr" target="#b17">[18]</ref>, allow users to tailor much of the visualization process to their own needs, they only provide users with a limited number of rendering techniques. In such an environment, how the data set is mapped to an image is one of the key steps in the visualization process. Because of this importance, the process of creating an image must in itself be very flexible.</p><p>Volume rendering is one of several rendering techniques that can be used to visualize three-dimensional data sets. Volume rendering is the process of generating an image directly from a data set without the generation of an intermediate geonietric model. Typically this is done by mapping the data values in the volume to the color and opacity of an imaginary semitransparent material, and then rendering an image of this material.</p><p>To date, most volume renderers apply a single, monolithic shading model to the volumes being rendered. Even with a highly parameterized shading model and flexible mappings of datii to color and opacity, a single model can be overly restrictive. If the provided parameterization is not adequate for all volumes being rendered, a renderer with a different shading model must be used or a new renderer that can produce the desired visualization must be developed. This requires an in-depth knowledge of the rendering technique being used as well as a high level of skill in programming techniques. Clearly, this is an unreasonable requirement to place on the general user. A more flexible method is to allow the users of the system to describe how they want to visualize the data set, through the use of a programmable shading system. This paper presents a modular and extensible volumc: rendering system, based on programmable data shaders. Data shaders give users control over the shading and classification of a volume data set, allowing thein to apply their domain specific knowledge to the design of new and powerful data shaders and to the creation of new ways of exploring and analyzing their scientific data sets. those voxels are integrated to obtain the color for that pixel. How this integration is performed is the key difference between volume rendering techniques.</p><p>Recently, two classes of volume rendering techniques have been receiving much research attention.</p><p>Projection techniques <ref type="bibr">[8,</ref><ref type="bibr" target="#b18">19,</ref><ref type="bibr">211</ref> are object space algorithms, processing a voxel at a time and determining how each contributes to the final image. Each voxel is projected onto the image plane and scan converted to determine its contribution to each pixel that the projection covers. These techniques impose a depth order on the voxels in the volume and render them from front to back or back to front. Ray-casting techniques <ref type="bibr" target="#b18">[19,</ref><ref type="bibr" target="#b12">13,</ref><ref type="bibr">171</ref> are image space algorithms, and determine the entire volume's contribution to a given pixel before processing the next pixel in the image. A volume's contribution to a pixel is determined by casting a simulated light ray through that pixel and into the volume. As a ray traverses the volume, it is sampled at regularly spaced intervals. Each sample value is interpolated and mapped to a color and opacity. These colors and opacities are then integrated along the ray to determine the final color for the ray and therefore the pixel.</p><p>Both of these techniques use a shading model to determine how the light interacts with each voxel. The shading model determines the visual appearance of each voxel, while the techniques (ray-casting or projection) determine the sample points and the order in which they are computed. In this paper, programmable data shaders are used to create an extensible shading system for the ray-casting technique, providing a flexible framework for the exploration of three-dimensional data sets. Rather than using a single, monolithic shading model, a programmable data shader is applied at each sample point of each volume to perform the shading operation. The shader used for each volume need not be the same, and need only be as complex as the visualization requires. Data shaders could also be used to extend the shading models of the projection methods.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Shading languages</head><p>Shading languages were developed as a powerful and flexible method of specifying a shading model for the rendering of geometric primitives. They were introduced to the graphics community by <ref type="bibr">Cook</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">RenderMan</head><p>The RenderMan shading language [16, 20, 101 is an extension of Cook's shade trees, providing a small set of high level data types, a full set of flow control structures, and a rich set of mathematical and shading related functions. Six classes of programmable shaders can be used within the RenderMan framework. Each class has a distinctive set of class variables, which are used for communication with the renderer. Of the six classes of shaders, RenderMan surface shaders are the most relevant to volume rendering. Surface shaders are used to determine how incident light interacts with a surface at a given point. This interaction is similar to the light interaction that must be computed at a sample point in a volume data set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Data shaders</head><p>Data shaders are used to perform the shading and classification of the subvolume around a sample point in a volume data set. They are similar in functionality to RenderMan surface shaders except that they are applied at a sample point rather than at a point on a surface. Data shaders are written in a language based on the RenderMan shading language. The remainder of this section briefly describes the extensions that we have made to the RenderMan shading language that enabled us to implement data shaders. These extensions are described in detail in [4].</p><p>Shader definitions are similar to function definitions in the C programming language <ref type="bibr" target="#b11">[12]</ref>, except that the instance variables (the variables in the function's parameter list) are given default values. These instance variables are set when an instance of the shader is created, and can be different for each instantiation. A data shader is declared by using the data keyword in place of a return type for the function. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">An example data shader</head><p>The simple threshold data shader given in <ref type="figure">Figure 1</ref> renders the data samples between the thresholds mint and m a t as opaque and renders all other data samples as transparent. The opaque data values are assigned the color given in the c instance variable. The threshold surface is shaded by using the built-in functions ambient and diffuse, which are scaled by the ka and kd instance variables respectively. On completion, the shader returns a color and an opacity to the graphics environment through the class variables Ci and Oi.</p><p>To change the characteristics of the shader, new values can be supplied for the instance variables minty maxt , c ka and kd when an instance is created.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Class variables</head><p>The class variables provided to a data shader define the state in which the shader executes. To effectively shade volumetric data, these variables must describe the volumetric state at the sample point. The class variables defined for data shaders are similar to those defined for RenderMan surface shaders (see <ref type="bibr" target="#b15">[16]</ref> or <ref type="bibr" target="#b19">[20]</ref> for a complete list of surface shader class variables), and include variables such as the input color and opacity (Cs and Os), the sample point (P), and the incident ray along which the computed light will be returned <ref type="bibr">(I)</ref>, as well as an assortment of others. To extend the set of variables to deal with volumetric data, it is necessary to specify volume sampling information, information about how the incident ray interacts with the volume data set, and three-dimensional sample location parameters. A complete list of class variables for data shaders is given in <ref type="figure" target="#fig_2">Figure 2</ref>.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Variable cs, os</head><formula xml:id="formula_0">Vn P E, 1 c1, L Ci, O i U, v</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Built-in functions</head><p>Several built-in functions have been added to the RenderMan shading language.</p><p>The sample and gradient functions provide access to the channels of a data set. The sample function returns the sample value at the specified point in the given channel of the data set. The gradient function returns the gradient at the specified point in the given channel.</p><p>The colormap built-in function is similar to the traditional RenderMan texture statement, except the mapping that is performed is one dimensional rather than two dimensional. A value is retrieved from a map by specifying a map, a map channel, and a mapping value (between 0 and 1) to the colormap function. The function can return either a color or a floating point value.</p><p>The attenuation function computes the amount light is attenuated as it travels the distance between sample points through a subvolume of a specified opacity. The function is called with a single parameter that specifies the opacity of the volume at the sample point P. The user can implement a user-defined attenuation function if desired.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Instance variables</head><p>In the RenderMan specification: all variables have either a uniform or v a r y i n g storage class. Uniform variables remain constant throughout the life of a shader, while varying variables can have different values each time the shader is invoked. In the Render-Man specification, all instance variables are assumed to be uniform variables <ref type="bibr" target="#b15">[16]</ref>. This restricts a shader from keeping any global state between invocations. If this restriction is relaxed, and varying variables are allowed as instance variables, then global state can be maintained by assigning values to these variables. This can be important in implementing some shading techniques that require global knowledge about past calculations in a given volume.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Implementation</head><p>Our implementation of a programmable volume rendering system is based on cap-wol, a volume renderer that has been under development at the Australian National University since 1991 [3]. The extensions to cap-vol to incorporate a shading language for volume rendering are based on an implementation of a shader library that is in turn based on earlier research into image synthesis <ref type="bibr">[5]</ref>. This library provides a renderer with a procedural interface to programmable shaders. The library does not provide a shading model directly, but instead provides a means of binding externally created shaders to the geometric engine that the renderer provides.</p><p>The shader library maintains a table of shaders that are available for use by a renderer. The renderer can request that a shader be loaded at run time by specifying the name of the shader. The renderer can ask the library to create an instantiation of the shader, and then bind that instantiation to a volume data set.</p><p>Once the shaders have been bound to their respective volumes, the renderer determines the points at which the shading calculations are to be performed. At each of those points the data shader that is bound to the volume being sampled is invoked. The data shader is provided with the opacity and color computed along the ray up to the sample point. It applies its shading model and returns a composited opacity and color for the ray up to and including the contribution of the volume around the sample point. Note that the shader performs the attenuation and compositing steps, and that this requires some knowledge of the way in which the renderer works. This approach was chosen to increase the flexibility of the shader frame-work and to make it possible t,o experiment with novel volume rendering techniques.</p><p>Shaders used by the renderer are written in the shading language, and are compiled by the shader compiler into a form that can be loaded by the library. The compiler converts the shader into a C implementation, which is compiled by a standard C compiler into a relocatable object module that is suitable for dynamic loading into the renderer executable. To perform the dynamic loading, a dynamic link editor is used [ l l ] . The shading language that is supported by the shader compiler is a subset of the RenderMan shading language combined with the extensions that are described in Section 4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Results</head><p>The Dominion Radio Astrophysical Observatory. or DRAO, is a radio observatory near Penticton, British Columbia, Canada. A typical observation run at DRAO produces a three-dimensional data set that represents the radio emissions near a specific wavelength from a given region of the sky. The source of the radio emissions are molecules which emit a spectral line at a known wavelength (e.g. 21cin or 1420MHz for atomic hydrogen) (71. Astrophysicists at DRAO are interested in visualizing these data sets.</p><p>One visualization technique being used at DRAO is the combination of multiple data sets that represent the same area of sky. For example, features in a data set produced by the emissions of atomic hydrogen can be explained by features in a data set produced from the emissions of other elements, such as carbon monoxide. Two data sets can be visualized using traditional volume rendering techniques by mapping the two data sets to two different colors (e.g. mapping atomic hydrogen to grey and carbon monoxide to red). Interactions between the two data sets can then be seen as mixtures of grey and red. This provides a simple linear combination of the two data sets.</p><p>A current area of research is to provide more sophisticated ways of combining the data values of the two data sets. For example, if it is known that the interaction of specific sample values of atomic hydrogen with specific sample values of carbon monoxide are of interest, these interactions can be highlighted using a special mapping to a given color (e.g. yellow) while the grey and red mapping of atomic hydrogen and carbon monoxide could he used for less interesting sample values. Further, if the region in which the interaction takes place is known, that region can be iso1;rted by making the rest of the data set. transpar- If structure in the remaining volume is interesting, the volume in the remaining region can be made relatively transparent while the area of interest can be made relatively opaque. All of these techniques are easy to implement using data shaders. An example implementation of such a shader is given in <ref type="figure" target="#fig_3">Figure 3</ref>, and an image generated using it is given in <ref type="figure" target="#fig_6">Figure 4</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.1">Shading models</head><p>The first data shader created using the shading language reimplemented the old shading model of cap-vol. This shader implements a shading model that is similar to those described by Levoy (13) and Upson and Keeler <ref type="bibr" target="#b18">[19]</ref>. The shader shown in <ref type="figure">Figure 5</ref> is this shader, extended to include multiple color and opacity transfer functions separated by an arbitrary slice plane. Extending the shader in this manner required only a few extra lines of shading language code. An image of a 113 slice 256x256 CT scan rendered using this shader is given in <ref type="figure" target="#fig_7">Figure 6</ref>.</p><p>The shading language is also very useful for experimenting with other shading models. Using the shading language, it is relatively straightforward to implenient shaders for Levoy's isovalue contour surfaces [13] and  <ref type="bibr" target="#b16">[17]</ref>. A shader that implements Sabella's technique is given in <ref type="figure">Figure 7</ref>, and an image rendered using this shader is given in <ref type="figure" target="#fig_8">Figure 8</ref>. The data set is obtained from a global atmospheric model simulation, and gives the carbon dioxide concentrations in the atmosphere at a single time step in a full year's simulation.</p><p>One of the multi-volume visualization techniques described by <ref type="bibr">Foley and Lane [9]</ref> has also been implemented using data shaders. To render the values that lie on a value probe, it is necessary to procedurally define the probe in the shading language. For example, it is straightforward to define a sphere within the volume inside of which all data samples are opaque. This effectively defines a spherical value probe as described by Foley and Lane. Mapping color blended contours onto this sphere is relatively straightforward, as is combining the value probe with the rendered volume data. In a two channel data set, it is possible to generate an isosurface from one channel and use it as a value probe for the mapping of color blended contours for the other channel. Other more complex procedural value probes could be defined as well.</p><p>Implementing other techniques, such as the classification, matting. and surface extraction described by <ref type="bibr">Drebin et al.[8]</ref> should also be possible using data shaders. The classification scheme could be implemented through lookup tables if only one volume is being used, or through the direct computation of a probabilistic classifier if more sophisticated classification is required. Matting coiild be performed through the use of a matting volume and the sample function, or through the use of procedural matting implemented in the shading language. The shader shown in   for areas that are not of interest to the user of the shader. Normals for surface extraction could be obtained through a precomputed surface normal volume or through calculation on demand with the gradient built-in function.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6.2">Efficiency</head><p>An important factor affecting the usefulness of programmable shaders is the cost that is incurred in using them. The quality of the code generated by the shader compiler is a key determinant of the efficiency of the shader. Hanrahan and Lawson <ref type="bibr">[lo]</ref> show that the time spent compiling a shader is orders of magnitude less than the time spent executing the shader. This implies that a large amount of time should be spent optimizing the code generated to produce the most efficient shader possible. In the current implementation, the optimization technology of the C compiler is relied on to produce efficient code. Compiler directives are used to in-line the built-in shading language functions and to generate optimized code from the code that is generated by the shader compiler. The C code that is generated by the shader compiler is currently very naive, as the shader compiler does not attempt to perform optimizations in the current implementation. Hanrahan and Lawson show that a significant improvement in the efficiency of the shaders can be obtained through the use of careful optimizations at the code generation stage.</p><p>To obtain performance results, the original version of cap-vol is compared with the new version using a simple data shader similar to the capvol shader, except it does not have multiple color maps and does not use surface shading. Timing results are generated on a Sun SPARCstation 2 with 32 MB of memory. Timing results indicate that the version of cap-vol that uses the data shader (with in-line code and C compiler optimizations) takes approximately 1.7 times as long to render an image as the old version of cap-vol. Without the C compiler optimizations, the data shader version takes approximately 1.75 times that of the old version. This indicates that careful optimization at the code generation stage may very well produce significant improvements, as the standard C compiler's optimizations do not produce a significant efficiency gain. With no in-line code and no compiler optimizations, rendering with a shader takes approximately twice as long.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusions</head><p>Data shaders provide a powerful and flexible framework for exploring new and interesting visualization techniques. By using a high level language to allow the users of the system to describe how they want to visualize their data sets, it is possible for those users to apply their domain specific knowledge to the creation of new and innovative shaders. In the current implementation of the shader system, flexibility and extensibility are the design goals. This does not preclude the system from being easy to use. Abram and Whitted have developed a visual programming system for the creation and editing of shaders for geometric primitives [l]. Extending such a system to incorporate data shaders would be straight forward.</p><p>The power and flexibility of the programmable shading system has been demonstrated through the implementation of various data shaders. Shaders that display complex combinations of multiple channel data sets and shaders that implement various techniques from the visualization literature are relatively straightforward to write using this system. Providing the scientific community with the ability to create their own data shaders should result in the development of new and interesting volume rendering techniques.   </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>3 Figure 1 :</head><label>31</label><figDesc>data threshold(f1oat mint = 0.6. maxt = 0.6; float ka = 0.6, kd = 0.6; color c = I) &lt; float Vs = sample(P.0); if (Vs &gt;= mint &amp;&amp; Vs &lt;= maxt) C / * Sample is opaque, shade it as an opaque */ /* surface and composite it with previous */ */ Oi = 1; Ci = Cs + c*(I-Os)+(ka*ambient() + /* samples along the incident ray. kd*diffuse(gradient(P.O))) ; 3 else C /* Transparent, no light attenuation */ Oi = Os; Ci = Cs;3 The threshold data shader</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>of incident ray Incident light color and direction Output color and opacity Parameterized sample location Distance to sample Distance to volume entry/exit Unit distance for opacities Distance between samples Volume size in U, v, and w dimensions</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Data shader class variables 4.3 Data types To make the use of transfer functions easily accessible, a new data type is added to those provided by the RenderMan shading language. A map consists of one or more channels, each of which represents a function defined on the interval [0,1]. A value is obtained from a channel of a map through the colormap built-in function.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>data drao-mix(map mapl="grey .map". map2="red.map"; float il=0.49, r150.<ref type="bibr" target="#b15">16</ref>, i2=0.27. r2=0.06; map imap="yellow .map"; float xmin-0.1, ymin=O, unin=0.626; float xmax=O.9, ymax=O.8, zmax=0.8125; float scaleini4, scaleout=0.26) float sl, s2. 0 , dl. d2, dist; color c;/ * Choose a color based on whether or not the */ /* sample is in the interest region. si = sample(P.0); s2 = sample(P,l); dl = abs(sl-il); d2 = abs(s2-i2);if (dl &lt; rl &amp;&amp; d2 &lt; r2)C i */ dist = 1 -(dl + d2)/(2*rl + 2*r2); c = colormap(imap, dist); o = float colormap(imap[3], dist); c = colormap(map1. si) + colormap(map2, 82); o = 1 -((1-float colormap(mapl[31. si)) + (1-float colormap(map2[31, 82))); 3 else C 3 / * Compute color and opacity based on location */ if (u&gt;xmin &amp;&amp; v&gt;ymin &amp;&amp; w&gt;zmin &amp;&amp; u&lt;xmax 88 v&lt;ymax &amp;B w&lt;zmax) o *= scalein; else o *= scaleout; if (o&gt;l) o = 1; o = attenuation(o) * (l-comp(Os, 0 ) ) ; Oi = Os + 0 ; Ci = Cs + o c; The drao-mix shader ent.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 : 3 Figure 5 :Figure 6 :</head><label>4356</label><figDesc>Two astrophysical data sets rendered using the drao-mix shader data capvol(map cmapl="skin.map", cmap2="bone .map"; point plane-p = (0.42.0.6,0.6), plane-n = (1 ,O,O) ; float ka = 0.3, kd 0.6) float Vs, 0 , atten, result; point p, vec; color col; / * Determine which side of the plane the sample */ c I* point is on */ setxcomp(p, U) ; setycomp(p, v) ; setzcomp(p, ; vec = pplane-p; if (length(vec1 == 0 . 0 ) result = 0 . 0 ; else result = normalize(vec) . normalize(p1ane-n); / * Compute the opacity from one of the maps */ Vs = sample(P, 0 ) ; if (result &gt;= 0 ) o float colormap(cmap1 E31 ,Vs) ; o = float colormap(cmap2C31 .Vs) ; else atten = attenuation(o)*(l-comp(Os, 0 ) ) ; Oi = Os + atten; / * Compute the color from one of the maps */ if (result &gt;= 0 ) col = atten*colormap(cmapl, Vs); else col = atten*colormap(cmap2, Vs) ; Ci = cs + col * (ka*ambientO + kd*diffuse(gradient(P,O))); The cupvol shader (See color plates, p . CP-29.) A CT scan data set rendered using the capvol shader Sabella's HSV mapping technique</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Fig- ure 3 -Figure 7 :Figure 8 :</head><label>378</label><figDesc>implements such a procedural matting technique data sabella(f1oat gamma = 3, tau = 1.2; varying float peakv = 0. peakd = 0; varying point incident = 0) float Vs; color hsv; / * If processing new ray initialize the values * / if (incident != I) C &gt; incident = I; peakv = 0.0; peakd = 0.0; / * Compute the sample value, if it is greater */ /* than the peak values so f a r , keep it. */ Vs = tau * pow(sample(P, 01, gamma) ; if (Vs &gt; 1.0) Vs = 1.0; if (Vs &gt; peakv) { 1 peakv = Vs; peakd = (Ds -Din)/(Dout -Din); /* Compute the opacity and color */ Oi = comp(Os.0) + attenuation(Vs)*(l-comp(Os,O)); setcomp(hsv, 0, I-peakv); setcomp(hsv, 1. O.S+O.S*(l-peakd)); setcomp(hsv, 2, comp(Oi, 0)); Ci = color "hsv" hsv;&gt; The sabella shader The carbon dioxide data set rendered using the sabella shader (See color plates, p.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4</head><label>4</label><figDesc>Two astropr\vsical data sets rendered using the drao-mix shader.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 6 :</head><label>6</label><figDesc>A CT scan data set rendered using the capvoi shader.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 8 :</head><label>8</label><figDesc>The carbon dioxide data set rendered using the sabelia shader.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>characteristics [2]. Perlin [15] extended Cook's shade tree language to include general flow of control structures. Both Perlin (151 and Peachey [14] introduced[21]. Crawfis and Allison [6] have</head><label></label><figDesc>the concept of solid textures. Westover applied shading languages to scientific visualization by using an implementation of Cook's shade trees to perform the shading operations for isosurfaces in his splatting volume rendering technique developed a system and language for the interactive creation of textures and raster images, as well as a framework for mapping such images to discrete scientific data sets.</figDesc><table><row><cell>'s pa-</cell></row><row><cell>per on shade trees, in which he described a flexible,</cell></row><row><cell>tree-structured shading model capable of represent-</cell></row><row><cell>ing a wide range of shading</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>The carbon dioxide data set wm provided by Dr. John Taylor of the Center for Resource and Environmental Studies at the Australian National University.</p><p>The astrophysical data sets were supplied by Dr. Chris Rogers of the Dominion Radio Astrophysical Observatory. The CT data set is from the University of North Carolina at Chapel Hill's volume rendering test data set, and was provided by Siemens Medical Systems.</p><p>We would like to thank Dave Walsh for his assistance in implementing this system and Drew Whitehouse for his development of the initial version of the cap-vol volume renderer. We would also like to thank Greg Gilley, who provided us with an initial grammar for the RenderMan shading language.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Building Block Shaders</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gregory</forename><surname>Abram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Turner</forename><surname>Whitted</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="283" to="288" />
			<date type="published" when="1990-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Shade Trees</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Cook</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computer Gmphics</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="223" to="231" />
			<date type="published" when="1984-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Parallel Volume Rendering and Data Coherence</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Corrie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Mackerras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Visualization &apos;93 Parallel Rendering Symposium</title>
		<meeting>the Visualization &apos;93 Parallel Rendering Symposium<address><addrLine>San Jose, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<monogr>
		<title level="m" type="main">Data Shader Language and Interface Specification</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Corrie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Mackerras</surname></persName>
		</author>
		<idno>TR-CS-93-02</idno>
		<imprint>
			<date type="published" when="1993-03" />
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Australian National University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">A Workbench for Realistic Image Synthesis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Corrie</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<pubPlace>Victoria, B.C., Canada</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, University of Victoria</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">MSc. Thesis</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A Scientific Visualization Synthesizer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roger</forename><surname>Crawfis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Allison</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;91</title>
		<meeting>Visualization &apos;91</meeting>
		<imprint>
			<date type="published" when="1992-10" />
			<biblScope unit="page" from="262" to="267" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A Dissociating Star: Prototype for a new Observational Class?</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Dewdney</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Roger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Purton</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Mc-Cutcheon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Astrophysical Journal</title>
		<imprint>
			<biblScope unit="volume">370</biblScope>
			<biblScope unit="page" from="243" to="256" />
			<date type="published" when="1991-03" />
		</imprint>
	</monogr>
	<note>IRAS 23545+6508</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Drebin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Loren</forename><surname>Carpenter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">A CM Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="65" to="74" />
			<date type="published" when="1988-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Multi-Valued Volumetric Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Foley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Lane</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;91</title>
		<meeting>Visualization &apos;91</meeting>
		<imprint>
			<date type="published" when="1991-10" />
			<biblScope unit="page" from="218" to="225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A Language for Shading and Lighting Calculations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jim</forename><surname>Lawson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="289" to="298" />
			<date type="published" when="1990-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">An Approach to Genuine Dynamic Linking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Wilson</forename><surname>Ho</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ronald</forename><surname>Olsson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Software-Practice and Ezperience</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1991-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">The C Programming Language</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Kernighan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Dennis</forename><surname>Ritchie</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1988" />
			<publisher>Prentice Hall</publisher>
			<pubPlace>Englewood Cliffs, New Jersey</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Display of Surfaces from Volume IEEE Computer Graphics and Applica-Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">tions</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="29" to="37" />
			<date type="published" when="1988-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Solid Texturing of Complex Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Darwyn</forename><surname>Peachey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="279" to="286" />
			<date type="published" when="1985-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">An Image Synthesizer</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ken</forename><surname>Perlin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">19</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="287" to="296" />
			<date type="published" when="1985-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">The RenderMan Interface -Version 3.1</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename></persName>
		</author>
		<imprint>
			<date type="published" when="1989-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">A Rendering Algorithm for Visualizing 3D Scalar Fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paolo</forename><surname>Sabella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computer Graphi c~</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="51" to="58" />
			<date type="published" when="1988-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">The Application Visualization System: A Computational Environment for Scientific Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Craig</forename><surname>Upson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Faulhaber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Kamins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Laidlaw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Schlegel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeffrey</forename><surname>Vroom</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Gurwitz</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andries</forename><surname>Van Dam</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="1989-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">V-BUFFER: Visible Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Craig</forename><surname>Upson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Keeler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">A CM Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="59" to="64" />
			<date type="published" when="1988-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m" type="main">The RenderMan Companion, Addison Wesley</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Steve</forename><surname>Upstill</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Footprint Evaluation for Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lee</forename><surname>Westover</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="367" to="376" />
			<date type="published" when="1990-08" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
