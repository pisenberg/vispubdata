<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Bridging the Gap Between Visualization and Data Management: A Simple Visualization Management System</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Peter</forename><surname>Kochevix</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Digital Equipment Corp</orgName>
								<address>
									<settlement>San Diego</settlement>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Bridging the Gap Between Visualization and Data Management: A Simple Visualization Management System</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:29+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>A prototype visualization management system is described which merges the capabilities of a database management system with any number of existing visualization packages such as AVS or IDL. The prototype uses the Postgres database management system to store and access Earth science data through a simple graphical browsel: Data located in the database is visualized by automatically invoking a desired visualization package and downloading an appropriate script or program. The central idea underlying the system is that information on how to visualize a data set is stored in the database with the data set itself</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>State-of-the-art visualization systems, as exemplified by <ref type="bibr">AVS [2]</ref>, IDL <ref type="bibr">[ll]</ref>, and Data Explorer [6], are quite sophisticated in their abilities to manipulate and render data. However, they are still lacking as complete visualization management systems (VMS). Most visualization systems are poor data managers in that they give little built-in support for finding pertinent data sets other than offering a simple file browsing mechanism. This minimal capability is not so much aproblem when there are few data sets residing locally on disk and one knows the names and locations of the files containing the needed information. But, if one is not familiar with the names, locations, or even the contents of files containing the data then serious problems arise. What is needed is a database management system (DBMS) to complement visualization packages along with an effective browsing and storage tool to allow easy navigation and interaction with the information in a database.</p><p>The desire for a more complete VMS is driven by the requirements of certain segments of the scientific community. . Sequoia is a unique blend of Earth and computer scientists who are working together to create a computing infrastructure that will foster a better understanding of global environmental change <ref type="bibr">[5]</ref>. The entire field of global change is characterized by the massive amounts of information pertaining to Earth that are and will become available. The ready search for and subsequent access to this information is as important to a global change researcher as is its actual visualization.</p><p>The following paper describes a very simple VMS constructed as an early prototype within the Sequoia project. The VMS was formed by linking the Postgres DBMS [ 121 with several off-the-shelf visualization systems. The heart of this system is the Visualization Executive which is primarily responsible for locating information using a graphical database browser tailored to the Earth sciences. Once a data set is located, an appropriate visualization system is started as a separate process, a program or script which actually visualizes the data is instantiated within the visualization package, and finally the raw data composing the data set is ingested and converted to the internal format used by the visualization package. The key idea which makes the operation of the Visualization Executive possible is that information as to how to visualize a data set is stored in the database along with the data set itself.</p><p>In the balance of the paper, the Postgres DBMS will be briefly described followed by an outline of how Postgres was used to create and manage a simple Earth science database. Next, a description of the design and implementation of the Visualization Executive will be provided. Finally, a discussion will ensue about the functionality and usability of the prototype VMS and a number of ways of improving its design will be offered. Postgres is an extended relational system so called because it possesses a number of features that distinguish it from most other relational DBMSs. Some of these features include user-defined types, inheritance, user-defined functions, and support for storing large non-relational data such as satellite images. To use these features, Postgres comes equipped with its own set-oriented command language, Postquel, through which one creates, alters, and queries for information.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Basic Features</head><p>The fundamental concept in Postgres is that of a relation which Postgres calls a class. A class is a named collection of objects all of which have the same record structure. These objects, referred to as instances of the class, consist of a set of named attributes each of a specific built-in or user-defined type. The attributes correspond to fields in a record whose structure characterizes the definition of a given class.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Inheritance</head><p>Postgres supports a limited form of inheritance whereby all the fields in the record structure of class A are appended to the fields comprising the record structure of class B. In this case, class B is said to inherit from class A and class A is called class B's parent. In general, a class can inherit from multiple parent classes provided that the attribute names of each parent are unique.</p><p>An inheritance graph is a directed acyclic graph that reflects the inheritance relationships among the classes in a database. Nodes in the graph correspond to classes and a directed edge points from a node representing class A to a node representing class B if B inherits from A. All classes corresponding to nodes that can be reached by traversing a chain of edges that begin at the node representing class A are called sub-classes of class A. In general, queries in Postgres can be directed toward a class and all its sub-classes, or just the class itself.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>User-defined Functions</head><p>Postgres allows the definition of two kinds of functions distinguishable by the way they are implemented. One kind of function is a macro containing a sequence of Postquel commands while the other type is implemented in ageneralpurpose programming language such as C. Both kinds of functions can have parameters which may be values of any Postgres type or they may be instances of some class. The return values of functions are likewise either of some Postgres type or they are a set of class instances. Functions defined within Postgres can be used as part of most any database query. Of special note is the fact that object files of functions implemented in a general-purpose programming language are stored within the database itself. When such functions are referenced within a query, Postgres dynamically loads and then executes them.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>User-defined Types</head><p>Postgres lacks most type constructors of the kind available in general-purpose programming languages. In particular, there is no convenient way of creating a type that has a record structure. Instances of user-defined types are treated by Postgres as unstructured strings of bytes of known sizes-Postgres can store and retrieve these instances but it cannot "peer" inside them. All manipulation requiring access to individual bytes within an instance must be performed through functions defined within Postgres. Therefore, user-defined types in Postgres are somewhat like abstract data types with the caveat that their implementation details are also hidden from Postgres itself.</p><p>Postgres requires at least two functions to be created in order to define any user-defined type. One function converts "constants" of a user-defined type into the Postgres internal format of an unstructured string of bytes. The other function performs the opposite transformation, converting strings of bytes into constants. These constants are usually character strings which represent the way a user wishes to perceive the type as output on a terminal, say.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Large Objects</head><p>Large, non-relational data sets, such as satellite images or AVS networks, can be stored and retrieved in Postgres using the concept of a large object. Like instances of user-defined types, large objects are sequences of bytes whose structures are completely unknown to Postgres. Since large objects may be hundreds of megabytes in size, they are treated differently by Postgres than instances of user-defined types.</p><p>To handle large objects, a file system has been implemented within Postgres. This idea contrasts with the traditional view where a DBMS is implemented on top of a file system. For this reason, Postgres calls its large object management facility an inverted file system. As with most file systems, Postgres' inverted one uses a directory structure to help manage the storage and retrieval of large objects. Utilities are provided to create and delete large objects, and to make and remove directories or subdirectories. Large objects are located within the inverted file system using path names that appear exactly like those in a Unix file system. Within Postgres, large objects are always referred to by their path names which act as pointers. User created functions can be defined on and can return large object pointers hence user-defined types can be created that are based on large objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Interfacing to Postgres</head><p>Postgres adheres to the client-server model of computing where the DBMS is the server and application programs, such as the Visualization Executive, are the clients. Postgres provides an application programming interface through a set of C-callable functions known collectively as LibPQ. The functions in LibPQ provide a means for sending Postquel commands to the Postgres server and receiving data in return.</p><p>A database query in Postgres is satisfied by forming unnamed, dynamically created classes called groups which contain instances known as tuples. These groups have a record structure formed by concatenating together select fields from the record structures of different named classes defined within the database. Postgres sends to an application program query results packaged into a data structure called aportaf buffer. These buffers are structured conceptually as a sequence of tables in which each table corresponds to a group. The rows of these tables correspond to tuples and the columns to group attributes. Associated with a portal buffer is additional information which describes the gross structure of the data that is returned. This information includes the number of groups returned, the names and types of attributes for each tuple, and the number of tuples in each group.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Implementing an Earth Science Database</head><p>A simple Earth science database was implemented via the Postgres DBMS to test ideas about implementing and using a VMS. A portion of the inheritance graph which forms the backbone of this database is shown in <ref type="figure">Figure 1</ref>. As can be seen from the graph, all classes in the database are sub-classes of the Base class whose instances contain two attributes: ClassName and InstanceName. ClassName refers to the name of the class to which an instance belongs while InstanceName is a name that is unique among all instances in a given class.</p><p>The sub-tree rooted at EarthSDS in the inheritance graph represents a partial taxonomy of Earth science data types. Attributes of class EarthSDS include fields for listing a data set's source, its date and time of generation or observation, its name, and so on. Aside from this bookkeeping information, the Eart hSDS class also contains an attribute which references information as to how a data set is to be visualized.</p><p>If a sub-class of EarthSDS corresponds to a particular kind of data set, then that class has attributes which reference the locations where the actual raw data resides. An assumption is made that all raw data is in the form of a multi-dimensional array whose array elements consist of a list of numeric values. These arrays are stored within the database as large objects. The path names for these objects are encapsulated within a class called Array which also contains attributes describing the array's dimensions and the data types of the values associated with each of the array's elements.</p><p>Pointers Note that two levels of indirection exist between an instance of an EarthSDS sub-class and the location of its raw data. In general, the Classpointer mechanism was introduced to circumvent a serious flaw in Postgres, namely, there is no easy way to define a class attribute that has a record structure. Postgres does not allow composite classes, classes which have attributes that are instances of other classes, and trying to define a record-like attribute as a user-defined type is tedious with its requirement to define input and output functions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">The Visualization Executive</head><p>The operation of the Visualization Executive was intended to be somewhat analogous to the operation of the Apple Macintosh folder browser. On the Macintosh, a user traverses the folder tree until a document of interest is eventually located. The browsing of the folders proceeds visually by pointing and clicking on iconic representations of folders and documents. When a desired document is located, the user double clicks on the representative icon and the document is then "visualized" within the application which created the document.</p><p>In a similar fashion, a user of the database browser in the Visualization Executive navigates through the database by pointing and clicking on iconic representations of the database's contents. Once a data set of interest is located, <ref type="figure">Figure 1</ref> : A partial inheritance graph for an Earth science database. a user double clicks on the data set's icon and the corresponding data set is then visualized. The name of the visualization program to run and the parameters to pass to it are stored with the data set in the database.</p><p>In general, the Macintosh analogy cannot be pushed too far. For instance, in the Visualization Executive an "application" is not the program which creates a data set but rather is the method for its visualization. In addition, the same data set can be visualized in many different ways using a variety of different visualization packages whereas on the Macintosh a single application is associated with only one document. In practice, information about each of the various ways a data set is to be visualized should be stored with the data set and a way of choosing from among the possibilities should be presented to a user. But, the VMS prototype described here makes the simplifying assumption that only one visualization method is associated with a given data set.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Database Browsing</head><p>The general idea underlying the browser is that queries are made of the database and the results are displayed graphically as icons. The icons are active in that they have behaviors associated with them that can be elicited by certain picking operations. The database browser in the current incarnation of the Visualization Executive comes with two interaction tools both of which were implemented using the X-Windows-based Tcl/Tk graphical user-interface toolkit [9, 101.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Query Formation</head><p>The simplest yet most powerful database interaction tool is the text-tool whose screen representation is depicted in <ref type="figure" target="#fig_2">Figure 2</ref>. This tool allows any legal Postquel command to be sent to the Postgres server for execution. The text-tool is essentially a visually oriented text editor with a built-in history mechanism. All commands that are submitted for execution by the tool are saved in a buffer and each can be later retrieved, editted, and then resubmitted. At system startup, the history buffer is loaded with commands from a file so that frequently used Postquel commands do not have to be entered by hand each time the system is initialized.</p><p>Although the text-tool offers the utmost flexibility in interacting with the database, it is really meant to be used as a last resort. The tool is difficult to use in that textual commands must be entered from the keyboard and a knowledge of the Postquel query language is mandatory. The preferred method of interacting with the DBMS is through a pointand-click interface whose look is partially determined by the kind of information that is to be visualized. An example of such a domain-specific database interaction tool is provided by the Visualization Executive in the form of the The map-tool is an exceedingly simple geographical information system that allows limited forms of queries to be submitted to Postgres. The tool is built around a 2-D world map which forms a backdrop for graphically specifying latitude and longitude ranges (see <ref type="figure" target="#fig_5">Figure 4)</ref>. Aside from specifying such constraints, the map-tool is used to enter date and time ranges as well. Once a IatitudeAongitude map-tool. and datehime range have been entered, a query for all Earth science data sets in the database whose positional and temporal attribute values fall within the specified constraints is formulated. All Earth science data sets whose latitudeflongitude and date/time range non-trivially intersect those given in the query are retrieved from the database. The DBMS does not clip data sets to the requested ranges although such a subsetting capability could have easily been added.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Visual Representation of Information</head><p>Upon receipt of a portal buffer after a query, the Visualization Executive invokes an icon generator to assign a graphic representation to each tuple that is returned. Each sub-class of E a r t h S D S has associated with it an icon stored as a pixmap. If a tuple in a portal buffer corresponds to an instance of an E a r t h S D S sub-class, then the icon generator assigns that class' pixmap to the tuple as its icon. In all other cases, a tuple must correspond to an instance of an unnamed, dynamically generated class which is always assigned the same catch-all pixmap by the icon generator.</p><p>The icons representing the tuples in a portal buffer are arrayed in groups on a scrollable canvas as depicted in <ref type="figure" target="#fig_3">Figure 3</ref>. Icons can be repositioned manually should a user wish to do so. When an icon is selected with the middle mouse button, a separate window appears which displays the attribute names and values for the tuple represented by the icon (see <ref type="figure" target="#fig_3">Figure 3)</ref>. The attribute values can be edited within the window and the changes will be written back into the database whenever the window is closed. If an icon corresponds to an instance of an E a r t h S D S sub-class, then double-clicking on it causes the raw data referenced by the instance to be visualized according to the visualization information indicated within the instance. For example, <ref type="figure" target="#fig_5">Figure 4</ref> shows the result of a double-click on an icon which caused the corresponding climatology data set to be visualized within AVS.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Initiating Visualizations</head><p>The browser performs three actions after a data set icon is double-clicked upon:</p><p>1. Create a temporary datu set descriptionjle.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Create a temporary scriptjle.</head><p>3. Spawn a process which performs the actual visualization.</p><p>The data set description file contains information describing the raw data which comprises a given data set. The information in this file is just a listing of the attributes of certain instances of the A r r a y class. In general, a data set is a composite of several multi-dimensional arrays. For example, a data set containing regional climate information typically consists of a 3-D grid of atmospheric variables, a 2-D grid of terrain elevations, and a 2-D grid of variables representing characteristics of the topography such as total precipitation.</p><p>The script file contains a program or script specifying how to visualize a given data set. The browser makes the assumption that all visualization packages have a scripting language within which visualization programs can be Written. These programs are stored in the database as large objects and their path names are encapsulated in a class called D i s p l a y . Besides a field containing a path name, the D i s p l a y class also has a field for recording the name of the visualization package to which the encompanying script or program belongs. Class E a r t h S D S has a field of type C l a s s p o i n t e r which references instances of D i s p l a y therefore all sub-classes of E a r t h S D S inherit a pointer to visualization information.</p><p>The process that is spawned by the browser is a stand-alone executable module whose name has the form, FireUp&lt;ApplicutionNume&gt;.</p><p>The symbol &lt;ApplicationNume&gt; is a placeholder for the name of a visualization package that is to be used and this name is retrieved from an indicated instance of the D i s p l a y class. The F i r e U p programs are created by the user and there must be one such program for each visualization package that is to be supported within the Visualization Executive.</p><p>In general, the F i r e U p modules are responsible for performing three actions: retrieving raw data stored as large objects in the database, converting them into appropriate forms for use by a visualization package, and executing the commands necessary to start a given visualization package. For the data retrieval and conversion tasks, a F i r e U p module must read in the information cached in the data description file. The large object path names that reside there are used by a particular LibPQ function to actually effect the transfer of bytes of raw data from the database into a memory resident buffer. Once in memory, the F i r e U p module can do a data conversion into an internal format that is recognized by an indicated visualization package using the array dimension and element type information in the data description file.</p><p>After data retrieval and conversion, a F i r e U p module starts a given visualization package. The general procedure for doing this is to first execute the operating system level command which invokes the package and then somehow indicate to the package that the program in the script file is to be loaded and run. The details of this procedure vary greatly from one visualization package to another. In IDL, the F i r e U p module would do the following:</p><p>Transfer the large object byte stream from the database into an internal buffer making use of the information in the data description file., Write out the buffer to a temporary file, raw-data, in a format readable by IDL.</p><p>Start IDL with the command, id1 script-file, where script-file is the name of the script file created by the browser which contains an IDL program.</p><p>Note that the IDL program contained in the script file must open the temporary file raw-dat a to read in the data that is to be visualized. This is a minor nuisance since developers of IDL programs must know the name of the temporary file that the FireUp routine creates to temporarily cache raw data.</p><p>For AVS, the FireUp module is constructed differently. First, it is assumed that an AVS module, ImportData, has been created which does the data retrieval and conversion. This module does the transfer of the large object byte stream into an internal buffer and then maps the data into an AVS field type which is then exported through the module's output port. The module has a single text input parameter which is interpreted as the file name of the data description file. An AVS network specification is stored in a script file and it is assumed that a single ImportData module is part of the network.</p><p>With the creation of the Import Da t a module, the AVS version of the FireUp program would then do the following:</p><p>0 Start AVS in server mode with the command, avs -server, and establish communications via sockets (see [l] for details).</p><p>0 Send to the AVS server commands to:</p><p>-Read the AVS network from the script file.</p><p>-Send the name of the data description file to the ImportData module thereby starting execution of the network.</p><p>Note that the above procedure has been simplified by offloading the data retrieval and conversion steps to the visualization package but at the expense of complicating communications. Furthermore, data movement is more efficient with AVS since the raw data does not have to be temporarily cached in a file as with IDL.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Discussion</head><p>The prototype VMS described above was designed and built to test new ideas about linking scientific databases to visualization packages. Experience gained in implementing and using the system has provided a good understanding of what kind of methodology and functionality works, and which can be improved upon. The following are some observations about this system which have bearing on future research and development efforts:</p><p>Information presentation and the relational database model. In the Visualization Executive, icons are generated solely on a per tuple basis. This idea works satisfactorily when the sizes of classes are small but severe problems arise with large classes that typically reside in a scientific database. For instance, in one Sequoia database there is a class encapsulating station measurements of oceanographic variables whose size numbers several million instances. In this case, even restricting attention to relatively small regions on Earth still produces on the order of thousands of tuples which would easily overwhelm the present icon generator in the Visualization Executive.</p><p>In dealing with such large classes, what is needed is a hierarchical representation of retrieved data much like the concept of folders in a Macintosh system. Part of the problem in dealing with large relational data sets lies with the DBMS itself-relational systems do not easily support hierarchical encapsulation of data. Such a data structure would require attribute values to be themselves instances from another class and in general relational database systems do not directly support constructs of this kind.</p><p>Even so, hierarchical information presentation could have been enforced in the current implementation of the prototype VMS. If too many tuples are returned in a portal buffer after a query then the icon generator could start grouping them into "folders." As on the Macintosh, a separate icon would denote a folder to signify that information is being grouped hierarchically. However, the question still remains as to exactly how the retrieved data would be partitioned into folders.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Dynamic icon generation.</head><p>In the current implementation, a separate icon is associated with each class in the database and every instance of a class uses that icon as its visual representation. It would be far better to dynamically tailor more telling icons based on the information content within each retrieved tuple. A more intelligent icon generator should take into account both the type and value of each tuple attribute when constructing an icon. To make this idea work, the type information should include more than just a structural description of the encoding of a value as, say, an integer. Semantic information should also be present that identifies a value as representing some physical quantity, such as temperature, which uses a particular unit of measurement and must lie within a certain range of validity. With a deeper understanding of values, an icon generator could, say, place an image of a thermometer, indicating the appropriate temperature level, in an icon representing a tuple having temperature as an attribute.</p><p>Icon placement. Currently, icons are merely arrayed on a blank 2-D canvas so that at best they give only a quick visual estimate of the number of tuples for each class of data that is retrieved. Icons could instead be placed onto an "informational landscape" so that their position on the landscape conveys meaning. For example, the query for data sets pertaining to a certain region of Earth could result in the icons being placed on a 3-D globe. Other kinds of relational data can be displayed graphically as scatter plots, graphs, histograms, etc. using the techniques discussed by Database schema knowledge in the Visualization Executive. When constructing a browser, care should be taken to make it as independent of the database schema as possible, that is, assumptions about the structure of the database inside the browser should be minimized. In this way, the browser would not have to be recoded each time the schema changes thus affording a more general and flexible utility. In order to achieve this goal, the database needs to be self-describing, in other words, the schema design and a complete characterization of all data must be stored in the database along with the data. Having this information on-line allows a browser to "learn" about the structure of a database thereby giving it the flexibility to dynamically create graphical interfaces tailored to the information that a user seeks.</p><p>Queries via the visual interface. A graphically-oriented query tool is far preferred to one which requires the use of text to enter DBMS commands. With a textual tool, a user is required to know both the DBMS command language and the underlying database schema to even be able to formulate a query. Although graphical query tools do not have these problems, they may suffer from another problem in that general queries may not be expressible using the tool. For example, the map-tool of the present database browser only allows a visual query for Earth science data that lies in a specified latitudellongitude and dateltime range. In when making a query, more information is retrieved than was intended; in other words, the query was too general and additional constraints need to be applied. In the current system, the only alternative is to formulate a new, more fully constrained query based on the original. If the original query was created by an elaborate sequence of interactions with a graphical user-interface, then the formulation of the new query would be quite tedious and time-consuming. Information modification. Non-relational information that is stored in the database as Postgres large objects cannot be altered from within the Visualization Executive so that the changes are reflected back in the database. For instance, visualization programs must either be written by hand or they must be created within a visualization package. In either case, the resulting program must be dumped to a temporary file from where it can then be ingested into the database and stored as a large object from outside the Visualization Executive. A similar criticism holds for raw, non-relational data sets such as satellite images. What is needed is some kind of generalized, preferably graphical editor within the Visualization Executive that understands the internal structure of large objects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>The VMS that has been constructed is an early prototype for a much more elaborate, next-generation visualization system that is currently under development as part of the Sequoia 2000 Project. The prototype demonstrates the utility of merging a DBMS with most varieties of off-the-shelf visualization systems which by themselves do not provide adequate data management services. The prototype makes use of one example of a domain-specific graphical browser which is much easier and more intuitive to use than textual DBMS command interfaces. Finally, a powerful concept was introduced where visualization information is stored with data sets themselves. This idea implies that scientists do not have to waste time creating or searching for a visualization program to run in their preferred visualization package each time they wish to view a data set-scientists can concentrate more on their science rather than on the process for doing it. other words, it produces a query that cannot be further constrained by specifying desired ranges of values for other attributes as well. If scientists only want to see AVHRR satellite imagery, they must nonetheless query for all other Earth science data types that might reside in the database.</p><p>In addition, there will be times when a user would like to apply successive queries to information already retrieved rather than always against the full database. Frequently     BEST COPY AVAILABLE --</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>Beshers and Feiner [3], Casner [4], and Mackinlay [7].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>The screen representation of the text-tool. Mike Olson et al. Visualization benchmark specification for the Seauoia 2000 uroiect. unmblished reDort.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 3 :</head><label>3</label><figDesc>The display of query results. n . .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :Figure 2 :Figure 3 :</head><label>423</label><figDesc>A visualization initiated from the database browser. (See color plates, p. CP-10.) Bridging the Gap Between Visualization and Data Management: A Simple Visualization Management System, P. Kochevar et al., pp. 94-101. The screen representation of the text-tool. The display of query results.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>A visualization initiated from the database browser.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>In particular, Earth scientists in the Sequoia 2000 Project</figDesc><table><row><cell>Zahid Ahmed</cell></row><row><cell>Jonathan Shade</cell></row><row><cell>Colin Sharp</cell></row><row><cell>San Diego Supercomputer Center</cell></row><row><cell>San Diego, CA</cell></row><row><cell>have expressed a need for sophisticated data management</cell></row><row><cell>to go along with scientific visualization [8]</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>to instances of the Array class are the data references that are stored as attributes of the various EarthSDS sub-classes. Fields which contain these references are of the user-defined type ClassPointer whose values are text strings of the form "&lt;class-name&gt; : &lt;instance-name&gt; ". The first component of such a value is the name of some class in the database, e.g. Array, while the second component is an instance name within that class. Since instances of all classes inherit the ClassName and InstanceName fields from the Base class, the class and instance names encoded in values of type Classpointer single out one instance from among all those in the database.</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Proceedings of the 1990 Winter USENIX Conference, 1990In Proceedings of the I991 Winter USENIX Conference, 199</head><label></label><figDesc>.John Ousterhout. An XI 1 toolkit based on the Tcl language. 1.</figDesc><table><row><cell>.</cell><cell>I</cell></row><row><cell>Novembcr 1992.</cell><cell></cell></row><row><cell cols="2">John Ousterhout. Tcl: An embeddable command lan-</cell></row><row><cell cols="2">guage. In Research Systems, Inc. IDL User? Guide, January</cell></row><row><cell>1993.</cell><cell></cell></row><row><cell cols="2">Michael Stoncbraker ct al. The implementation of</cell></row><row><cell cols="2">POSTGRES. IEEE transactions on knowledge and</cell></row><row><cell>data engineering, March 1990.</cell><cell></cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>This work was supported by the Digital Equipment Corporation, the University of California, and the San Diego Supercomputer Center. Special thanks to Len Wanger for his help in the preparation of this paper. Thanks also to</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">of virtual worlds for visualizing multivariate relations</title>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization &apos;92 Conference</title>
		<meeting>Visualization &apos;92 Conference</meeting>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="283" to="290" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A task-analytic approach to the automated design of graphic presentations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Stephen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Casner</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="1" to="1" />
			<date type="published" when="1991-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">How Sequoia 2000 addresses issues in data and information systems&apos;for global change</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jeff</forename><surname>Dozier</surname></persName>
		</author>
		<idno>92/14</idno>
		<imprint>
			<date type="published" when="1992-08" />
		</imprint>
		<respStmt>
			<orgName>University of California</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An architecture for a scientific visualization system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bruce</forename><surname>Lucas</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Visualization &apos;92 Conference</title>
		<meeting>Visualization &apos;92 Conference</meeting>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="107" to="108" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Automating the design of graphical presentations of relational information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">D</forename><surname>Mackinlay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="110" to="141" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
