<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Texture Splats for 3D Scalar and Vector Field Visualization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roger</forename><forename type="middle">A</forename><surname>Crawfis</surname></persName>
							<email>crawfis@llnl.gov</email>
							<affiliation key="aff0">
								<orgName type="institution">Lawrence Livemore National Laboratory Livermore</orgName>
								<address>
									<postCode>9455 1</postCode>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nelson</forename><surname>Max</surname></persName>
							<email>max2@ilnl.gov</email>
							<affiliation key="aff0">
								<orgName type="institution">Lawrence Livemore National Laboratory Livermore</orgName>
								<address>
									<postCode>9455 1</postCode>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Texture Splats for 3D Scalar and Vector Field Visualization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:29+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Ideal Reconstruction Functions Volume Visualization is becoming an important tool for understanding large 3 0 data sets. A popular technique for volume rendering is known as splatting. With new hardware architectures offering substantial improvements in the performance of rendering texture mapped objects, we present textured splats. An ideal reconstruction function for 3 0 signals is developed which can be used as a texture map for a splat. Extensions to the basic splatting technique are then developed to additionally represent vector fields.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Introduction</head><p>Westover has proposed two methods of using splatting to produce volume rendering. In the first method [Westover89], the color and opacity filter kernels for each voxel are composited one by one in back to front order (in regard to their center points). In the second <ref type="bibr">[WestoveBO]</ref>, the colors and opacities for all the voxels in a layer are summed into an accumulation buffer, and then composited as a whole into the image. This second method prevents the opacity interactions of the voxels within one layer, and eliminates any possible small glitches from the change in sorting order within a layer during rotation. However, it may introduce larger glitches when the choice of the layer direction (most perpendicular to the viewing direction) changes.</p><p>We have implemented the earlier method, taking advantage of the texture mapping and compositing features in Silicon Graphics rendering engines. As in <ref type="bibr">[WestoveBO]</ref>, we put the color and opacity values for a high resolution master splat into a texture map, and then use the texturing hardware to interpolate sampled values from these maps. We also use the RGBA compositing hardware to modify the frame buffer with each splat. The Explorer product from Silicon Graphics, Inc. uses the compositing scheme, but not the texture mapping in their volume rendering. We have added extensions to Explorer for texture mapped splats for both scalar and vector volume rendering. <ref type="bibr">Laur and Hanrahan [Laur90]</ref> also used the fast compositing hardware of the SGI, but approximated each splat by a collection of polygons. Mach bands are visible at the polygon edges, and individual splats are visible, because they do not overlap smoothly. Each splat is typically created from fifteen to twenty-one triangles, or a triangle mesh. For architectures that have hardware support for texture mapping, we can replace these many polygons with a single texture mapped square. Max [Max911 developed an optimal piecewise quadratic reconstruction function for images. We used this kind of function rather than a gaussian, since its overlap extent is well known and the function goes to zero in a minimum extent. This function was designed for the reconstruction of 2D signals (images), not 3D signals. By focusing on the reconstruction of three-dimensional signals, we have developed a reconstruction function for 3D splats that is accurate from all viewing directions. This function is a piecewise cubic, offering additional degrees of freedom in the optimization. Hence it is as accurate as [Max911 for orthogonal views perpendicular to the axes.</p><p>We have mathematically optimized the splats to give a smooth overlap, from any viewing direction, with the desired property of minimal extent. If h(x,y,z) is the 3D reconstruction filter kernel for a voxel at (O,O,O), its 2D footprint f(x,y) is given by:</p><formula xml:id="formula_0">W f(x,y)= jh(x,y,z)dz. (1 1 -W As i n [Westover89]</formula><p>, we restrict ourselves to rotationally symmetric filter kernels, such that h(x,y,z)=g( x + y + z ), for a function g ( r ) of a single radius variable r. Our goal is to chose g(r) such that 1) g(r) E C', eliminating mach bands, and 2) the splats overlap into a smooth density, hiding the structure of the individual splats.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Jm</head><p>To understand this second criteria, consider a cube filled with n x n x n voxels, all emitting an intensity of one and with no opacity </p><formula xml:id="formula_1">c(x,y,z) = C C C h ( x -i, y -j , z -k )<label>(2)</label></formula><p>-00-00-00</p><p>with voxel centers at the integer lattice vertices (i,j,k). Our filter kernel has a finite support, so each of these infinite sums is in fact finite.</p><p>Except for edge effects where all terms in this finite sum are not present, the total density for two comparable pixels in our cube projection comes from two integrals of ( 2 ) along parallel segments of the same length, and should not vary much if the 3D reconstruction does not.</p><p>The 3D optimization is then a 3D version of the 2D optimization of [Max91]. We assume g(r) is zero for r &gt; t, and is represented by two cubic polynomials, p ( r ) for O S r I s , and q ( r ) for s I r I t (see <ref type="figure" target="#fig_0">Figure 1.</ref>). The condition that h(x,y,z) be C' at the origin means that the linear term of p ( r ) is zero, hence, p ( r ) takes the form:</p><formula xml:id="formula_2">p ( r ) = a + br2 + cr3.</formula><p>The condition that q(r) meets the zero constant function in a C1 fashion are r = t means that q(r) takes the form</p><formula xml:id="formula_3">q ( r ) = d ( t -r J 2 + e(t -r + .</formula><p>The condition that p(r) and q(r) meet in a C* fashion at r = s gives two more linear constraints on the variables a,b,c,d and e . We solved for c and e in terms of the other variables, a, b and d. Finally, since we were only interested in relative variation, we set a = 1. This gives four independent parameters, s, t, b and d. We minimized the relative variance of the sum in equation <ref type="formula" target="#formula_1">2</ref>using an unconstrained optimization algorithm <ref type="bibr">[Gay83]</ref>. This algorithm estimates the gradients and Hessian matrices needed for minimization from function evaluations. There is no absolute minimum, since the relative variance can be arbitrarily small if t is arbitrarily large. Therefore, we searched for a local minimum with a reasonably small f, and found one at t = 1.556228, and s = 0.889392. The relative variance was 0.001 19, and the maximum relative deviations from the mean were -0.00233 at  <ref type="table">Table   projection</ref> along the z axis of one layer of glowing, completely transparent volhme splats. (In this case the relative deviation is independent of the number of layers.) The maximum projected value was 1.00249 at (.5,.5), and the minimum was 0.99845 at (.25,.25). The intensities in figure 2. were scaled to exaggerate the deviation approximately 250 times. From this we can see that the total variation is only about one part in 256, or one bit with most 8-bit color accuracy.</p><formula xml:id="formula_4">x = y = z =</formula><p>We use this function to generate a texture that is used as the splat. The texture is generated with an extent of 1.6 and the splats are built up in back to front order. <ref type="figure" target="#fig_2">Figure 4b</ref> was generated using this technique.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Combined Vector and Scalar Textures</head><p>We can integrate vector fields into the scalar reconstruction function, by adding a slight disturbance in the function, such as tiny vector particles, or scratch marks. For the master splat, these vector indications are created in the x-axis direction. <ref type="figure">Figure 3</ref>. illustrates a series of twelve such splats. These twelve are part of a larger table that will be explained later in this paper. For the splatting of vector splats, two additional calculations must be carried out. First, the vector field direction for each splat is determined and transformed to viewing coordinates. The projection of this vector (v,,vy) is then used to determine a rotation matrix for the polygon splat.</p><p>The splat is rendered by selecting a splat from the splat table in <ref type="figure">Figure 3a</ref> as an intensity map, and for scalar fields, the same splat in <ref type="figure">Figure 3b</ref> for an opacity map. There are several texture mapping possibilities in SGI's GL graphics library [GL91]. We chose a two-component texture consisting of an intensity and an opacity component for our texture splats. Different texture mapping operations are used for representing only a vector field versus a scalar and vector field.</p><p>The MODULATE operator [GL91] multiplies the polygon's color by the splat's intensity and opacity. This operator is used for representing a single vector field. The splats in <ref type="figure">Figure 3a</ref> are used for both the intensity and opacity. The resulting splat's color will thus be:</p><formula xml:id="formula_5">R = Ri, * I,,, G = Gin * Itex B = Bin * I, , A = Ai, * A,,,.</formula><p>The polygon's color () (the resulting splat's color) can be used to convey the magnitude of the vector field. Alternatively, we can map a separate scalar field or use an axes coordinate as an additional spatial cue.</p><p>The BLEND operator [GL91] will produce a dissolve between the polygon's color (Rin,Gin,Bin) and a specified constant color using the splats intensity (Ite,) as the fraction to take from each. The polygon's opacity (Ain) is modified as with the MODULATE operator. The resulting splat's color will thus be:</p><formula xml:id="formula_6">R = Rin * ( 1 -Itex 1 + &amp;onst * Itex G = Gin * ( 1 -Itex ) + Gconst * Itex B = Bin * ( 1 -Itex ) + Bconst * Itex A = Ai, * Ate,</formula><p>Using the texture maps in <ref type="figure">Figure 3</ref>, this function will give us (RCOnSt,GCOnSt,BCOnSt) colored vectors, with the appropriately colored splats, both of which are attenuated by the polygon's opacity Ai,. The vector color can be changed for each splat, allowing the vectors to be color coded by magnitude, or offering an additional threedimensional cue by tying the color mapping to the splat's world coordinate position. When representing a single vector field, we can stretch the polygon in the vector direction, producing a "streaky" or paint brush affect.</p><p>These operations define the texture mapping used to create a data dependent splat with the proper transparency and colors. This splat is what is then composited into the final image.</p><p>So far, we have only indicated the xy-projection of the vector direction. No indication of the component of the vector directed towards the eye is given. This can be represented by a foreshortening of the vector based on the viewing direction component in relation to the overall vector length. If we are only representing a vector field or if we separate the vector and scalar splats, an easy method of achieving this is to simply shorten the polygon in the vector direction. This is simply the x-axis direction of the base splat, since we use the transformation pipeline to orient the splat in the direction of the vector. A second alternative is to change the texture mapping coordinates in the x-axis direction (increasing the frequency content of the resulting image). Unfortunately there is no way to automatically have the resulting repetitive texture windowed using current hardware. A third method which will also work for combined scalar and vector fields, is to create a table of textures indicating different amounts of foreshortening. This is represented across the columns in <ref type="figure">Figure 3</ref>. The z component vz of the vector direction is used to index into a column in <ref type="figure">Figure 3</ref>.</p><p>The series of splats represented in <ref type="figure">Figure 3</ref>, also are used to provide animation of the flow field. Going up the rows of <ref type="figure">Figure 3</ref>, we have the vector component of the splats moving across the scalar reconstruction. It should be noted that the vector component is windowed, but given a slightly larger extent than the scalar splat. We assign each splat a random index into the rows. For animated flows, a changing phase shift is added to the indexing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>System Design</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Inventor I Explorer</head><p>With the help of SGI, we have extended the VolumeToGeom and Render modules of the Explorer system from SGI. These modules implement the octree volume rendering scheme of <ref type="bibr">Laur and Hanrahan [Laur91]</ref>. The main enhancement is the inclusion of Textured Splats, Vector Splats, and combined Vector and Scalar Splats. The Render module in Explorer uses Inventor, an objectoriented graphics library, from which we developed C++ subclasses for the various splats. By adding a timer Sensor, available in Inventor, we can change the phase of the splats. We have created a set of sixteen windowed vector texture maps, where each map has the vectors propagated forward (and cyclically) in the map before being windowed (rows of <ref type="figure">Figure 3)</ref>. We attach a Slider (another useful Inventor feature) to the Timer, that allows the user to control the speed of the animation of the vector field (see the accompanying Video Proceedings). The use of C++ allows us to easily extend the capabilities of the volume rendering when using splats.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Performance</head><p>The performance of the algorithm on scalar data sets is dependent on the overall size of the splats. For many small scalar texture splats the algorithm is actually faster than the gaussian splats used by Explorer. This comes about from the trade-off of rendering one texture mapped square versus rendering a Gourand shaded triangle strip consisting of many triangles. As the amount of screen space the splats occupy increases, the performance reverses, and the polygonal gaussian splats are faster than the textured splats. The relative difference in speed is never very substantial for the test cases we have run. The quality of the image is however much better when using the textured splats with the optimal reconstruction kernel described above.</p><p>The vector splats incur about a fifty percent performance penalty in the matrix multiply required with each vector to transform it to screen space. The inverse of the viewing matrix is needed for this, but the four by four matrix inverse is computed only once for the entire octree. There is also a minor amount of additional work in calculating the rotation matrix and the vector foreshortening.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Results</head><p>Figures 4a and 4b are volume renderings of a sample Explorer data set. <ref type="figure" target="#fig_2">Figure 4a</ref> was generated using the polygonal mesh with 3 radial samples and seven azimuth samples to approximate the gaussian. <ref type="figure" target="#fig_2">Figure 4b</ref> was generated using our ideal reconstruction function and texture mapped squares. Both images used a splat size of 1.6. Artifacts of the polygonal mesh and the rapid cutoff of the gaussian are clearly evident in <ref type="figure" target="#fig_2">Figure 4a</ref>. <ref type="figure" target="#fig_3">Figure 5</ref> illustrates the vector splatting on a dummy test tornado data set. The magnitude of the vector field is used to control the opacity and a noisy color map of browns is used to add some variations. <ref type="figure" target="#fig_4">Figure 6</ref> shows a global climate data set. Here, the jet stream winds are represented by the vector splats. The magnitude of the winds is mapped to both opacity and color, and a stretched vector splat is used to provide a wispy appearance in the wind field direction. <ref type="figure">Figure 7</ref> uses the GL blend operation to add white vectors flowing through the volume rendering of the magnitude of an airflow through an aerogel (ultr light weight insulator) substance. Polygon data representing the aerogel fibers are embedded into the volume rendering. <ref type="figure">Figure 8.</ref> represents the scalar field percent cloudiness and the vector field of winds of the climate data over North America. The winds are color coded to give an indication of the placement within the altitude and are also restricted to where there is a high concentration of clouds.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Future Work</head><p>We need to experiment with different textures for better representation, particularly textures with an animated component. The texture used here was our first try, more effective textures certainly exist. Much work could also be done to improve the performance of the texture-mapping, paying particular attention to the amount of available texture map memory. We have many different application areas that we will be testing these techniques out on in the next few months. These include: fluid flow, electromagnetics, underground water contamination, and structural mechanics. Since we can easily extend our C++ classes, multivariate splats, tensor splats, and possible combinations can be added. Our current plans include working on splats to represent relationships between two or three scalar variables and possibly a vector field, as well as representing two vector fields, such as the electrical (E) and the magnetic (H) fields in electro-magnetic simulations.    </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 .</head><label>1</label><figDesc>Ideal reconstruction functionprojection of this cube should be as constant as possible, within the region bounded by the projections of two parallel faces, where the ray path lengths are equal. Since this should be true for all It, and all viewing angles, it presents a difficult optimization problem. Instead, we have chosen to minimize the relative variance (r.m.s. deviation from the mean, divided by the mean) of the reconstruction c(x,y,z) of this constant function</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>0.26, and 0.00534, at x = y = 0.5 a n d z = 0. By dividing the constants a, b, c, d, and e by the mean of c(x,y,z), scaling the reconstructed function to values near 1, we get: 0.557526 -1. 157743r2 + 0.671033r3 0 I r I s 0.067599(t-r)2 +0.282474(t-r)3 s l r l f 0 s 2 t Figure 1. shows a graph of this function. The integral ( 1 ) can be computed in closed fom, since f ( x , y ) = T g ( d m ) d z = T g ( m , d z where r = .\i.z.y'. (Polynomials of low degree in z 2 appear in tables of indefinite integrals.) This closed form solution was used to compute the footprint function f ( x , y ) . Figure 2. shows 2 x 2 periods of a 2D Figure 3: a) Portion of Intensity Table b) Portion of Opacity</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 4 :</head><label>4</label><figDesc>a) Gaussian Splats. b) Texture Splats with an optimal reconstruction texture.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 5 :</head><label>5</label><figDesc>Test tornado.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 6 :</head><label>6</label><figDesc>Wind velocities (jetstreams). Color mapped to wind magnitude.Figure 7: Airflow through an aerogel substrate. Vector direction in white, magnitude is volume rendered.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 :Figure 6 Figure 5 Figure 8</head><label>8658</label><figDesc>Percent cloudiness and wind velocities. The wind velocities are color coded by altitude (See color plates, p, CP-27.)Figure 4, a) Gaussian Splats. b) Texture Splats with an optimal reconstruction texiure Wind velocities (letstreams) Color mappecl to hind magnitude Test tornadG Figclre 7 Airflow throhgh OP aerogel substrate VecfOr direction in white magnitude I S volume renderecl w m Percent cloudiness and wind velocities The wind velocities are color coded b y altitude cp-27</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was performed under the auspices of the U.S. Department of Energy by Lawrence Livermore National Laboratory under contract number W-7405-ENG-48, with specific support from an internal (LDRD) grant. The authors would like to thank SGI for their cooperation, in particular, Roy Hashimoto and Bob Brown. The Global Climate data is courtesy of the Program for Climate Model Diagnosis and Intercomparison and the European Centre for Medium-range Weather Forecasts. The aerogel data is courtesy of Tony Ladd and Elaine Chandler, LLNL</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Algorithm 6 1 1, Collected algorithms of the ACM</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Gay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">also in ACM Transactions on Mathematical Software</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="503" to="524" />
			<date type="published" when="1983" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title/>
	</analytic>
	<monogr>
		<title level="j">Graphics Programming Library Guide. Silicon Graphics, Inc</title>
		<imprint>
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Hierarchical Splatting A Progressive Refinement Algorithm for Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Laur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint/>
	</monogr>
	<note>SIGGRAPH 91</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An Optimal Filter f o r Image Reconstruction, in Graphics Gem 11</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nelson</forename><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">James Arvo</title>
		<imprint>
			<biblScope unit="page" from="101" to="104" />
			<publisher>Academic Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Westover</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Footprint Evaluation for Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Westover</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">376</biblScope>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m">SIGGRAPH 90)</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page">367</biblScope>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
