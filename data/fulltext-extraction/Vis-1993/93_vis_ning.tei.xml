<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fast Volume Rendering of Compressed Data</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Ning</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering Stanford University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Lambertus</forename><surname>Hesselink</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Electrical Engineering Stanford University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Fast Volume Rendering of Compressed Data</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:29+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Volume rendering has been proposed as a useful tool for extracting information f r o m large datasets, where non-visual analysis alone may not be feasible. The scale of these applications implies that data management is an important issue that needs t o be addressed. Most volume rendering algorithms, however, process data in raw, uncompressed form. I n previous work, we introduced a compressed volume format that may be volume rendered directly with minimal impact o n rendering time. I n this paper, we extend these ideas t o a new volume format that not only reduces storage space and transmission time, but is designed for fast volume rendering as well. The volume dataset i s represented as indices into a small codebook of representative blocks. With this data structure, volume shading calculations need only be performed on the codebook and image generation is accelerated by reusing precomputed block projections.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>A primary motmivation for the development of scientific visualization techniques is the need t o understand and interpret large, multi-dimensional datasets. Visualization does not eliminate, however, the problem of data management; rather, data management issues must be addressed by the visualization tools themselves. Common problems resulting from the size of these datasets include demands on storage space and transmission bandwidth. Rendering algorithms also are usually slower as the datasets grow large. In this paper, we present a data compression technique for volumetric (3-D) scalar datasets that not only reduces storage and transmission costs but also results in significantly faster volume rendering. The compressed volume may be used for efficient previewing or initial study; in many applications, the original data should be retained for final evaluation. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Background and Motivation</head><p>Traditional applications of data compression aim to reduce the number of bits required t o represent such data as text, speech, or images. Some example algorithms are entropy coding, predictive coding, and transform coding. In computer graphics, hierarchical or multi-resolution techniques may also be considered a form of data compression since they reduce the number or complexity of geometric primitives needed to describe a scene.</p><p>In <ref type="figure" target="#fig_0">Figure 1</ref>, we illustrate the potential targets of compression algorithms for visualization systems. These are shown as demands on system resources that are ideally minimized. Clearly, sforage space and transmission time may be reduced by appropriate application of compression. For some schemes, e.g. hierarchical geomehic modeling, processing f i m e required in rendering may be minimized a s well.</p><p>In the case of 3-D scalar field visualization, the need for some form of compression has been demonstrated for both polygonal isosurface generation and volume rendering. For larger datasets, the number of polygons in isosurface models often exceeds the real-time rendering capabilities of available graphics worksta tions; several schemes have been proposed to reduce this number and consequently improve storage space, transmission time, and rendering time [11][15] <ref type="bibr" target="#b9">[18]</ref>. The size of the raw dataset itself may also be a concern; for volume rendering applications, vector quantization has been proposed as a solution which improves both storage space and transmission time while remaining Compatible with direct rendering <ref type="bibr" target="#b2">[12]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Overview</head><p>This paper describes a vector quantization approach to volumetric compression that is designed to speed up volume rendering of scalar fields, using ray tracing as a specific example. We extend our previous work <ref type="bibr" target="#b2">[12]</ref> in two ways. First, the surface normal field is compressed in addition t o the scalar samples; this requires appending additional elements to the vector to be quantized. Second, the coherence of the compressed volume is exploited to give fast volume shading and ray tracing; this involves some precomputation on the vector quantization codebook and subsequent reuse of the results throughout the volume.</p><p>In the next section, we review the basic concept of vector quantization and discuss its application to volume rendering. Then we describe how the coherence of the compressed data may be exploited for fast shading and ray tracing. Implementation details are then given, including results on some example datasets. We conclude with possible topics for future work.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Vector Quantization : A Compression Format for Volume Rendering</head><p>Volume rendering has generally been applied to datasets no larger than 2563 samples. As raw dataset sizes grow beyond these limits, memory and disk requirements become a significant concern that must be addressed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Full Volume Representation</head><p>Consider a volume of N 3 voxels; for simplicity, we assume these lie on a cubical grid. In general, the full volume representation uses So bits where</p><formula xml:id="formula_0">So = N3svO,<label>(1)</label></formula><p>and suo= is the storage in bits for a single voxel. </p><formula xml:id="formula_1">A</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Volume Compression by Vector Quantization</head><p>In previous work, we examined the problem of selecting a data compression scheme for volume datasets that is compatible with direct volume rendering, and proposed as a solution vector quantization applied to blocks of voxels extracted from the volume. Unlike the standard use of compression in which a volume data file is compressed for disk storage and decompressed when rendering is desired, the vector quantized volume is amenable to direct rendering, thus retaining the compression savings throughout processing.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Vector quantization (VQ) [4] maps every k-</head><p>dimensional input vector X to some reproduction vector X i selected from a finite codebook of M candidate vectors (codewords), and encodes X by the index i of X i . An optimal encoder performs a nearest neighbor mapping so that the best available reproduction is used. If the codebook is well-designed, its vectors are representative of the data source to be encoded and the coding error is low. If M is small, then each index requires few ( m = logz M ) bits and compression is achieved. Decoding involves a simple table lookup into the codebook using the transmitted index. Several codebook design methods have been developed and we describe a particular technique in Section 4.</p><p>Vector quantization may be applied to volume data in the following manner. The volume is partitioned into contiguous blocks of Z x J x K voxels, where each voxel may contain up t o five distinct fields { f , n,, ny , n, , IlVfll}, depending on the material model desired (note that c and CY are not included here since they are usually modified by the user of a volume rendering application). Each block is then interpreted as a vector by concatenating all of its voxels, and this vector is quantized with an appropriately designed codebook. For the simple material model, only f is needed at each voxel so the vector dimension is L = I J K . For the most complex model, both the gradient direction and magnitude are included so the vector dimension is k = 5 x ZJK.</p><p>Given the codebook of M k-dimensional codewords, each block in the volume may be represented by an index, i , into the codebook. Compression is achieved by replacing the entire volume with a new data structure consisting of the codebook and the indices of the blocks. Note that during volume rendering, additional fields such as c and CY may be needed so the storage for each codeword is augmented. For large datasets, however, the codebook storage is small compared to that of the indices, so the overall compression savings remains essentially constant. Direct volume rendering of the compressed data requires fast, random access t o voxel values. Since voxel decoding is just a simple table lookup in the codebook, volume renderers may use the vector quantized data with negligible impact on rendering time; tests with a cell projection algorithm, for example, showed only a 5% overhead for processing the compressed format compared to the original volume <ref type="bibr" target="#b2">[12]</ref>. Thus, vector quantization is a good match for volume rendering applications.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>A 2.3 Compression Ratio</head><p>To examine the compression ratio achieved by vector quantization, we consider the case of cubical blocks  for this block size depends on the particular block arrangement selected <ref type="figure">(Fig. 2)</ref>. The votel-spanning strategy covers all of the voxels, but results in regions of the volume that do not lie completely within a block (specifically, those portions that fall between consecutive voxels of neighboring blocks); this arrangement requires rN/b1 indices. The space-filling strategy, which shares voxels among neighboring blocks, does not leave cracks and is more appropriate for the fast ray tracing algorithm described in the next section; Then the storage occupied by the compressed volume is</p><formula xml:id="formula_2">s v q = Sindices + Scodebook = [N/l13m + Mb3suox w [N/l13m ( 3)</formula><p>where the approximation indicates the desired case in which the codebook is relatively small.</p><p>Comparing this expression t o that of the full volume, we obtain the compression ratio</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(4)</head><p>Resulting values of Rs for the smallest block lengths are given in <ref type="figure" target="#fig_2">Fig. 3</ref>, which assumes suo, = 40 bits (this is the case implemented in Section 4 and corresponds to storing {f, n,, ny, n=, c } per voxel at 8-bit resolution). The example codebook sizes are selected because they give indices which fall conveniently on byte boundaries. Note that for any dataset that satisfies the approximation in Eqn. 3, the compression ratios in <ref type="figure" target="#fig_2">Fig. 3</ref> are always achievable but not necessarily practical since the corresponding image qualities must also be examined. In Section 4, we show images for the case m = 8 and 1 = 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Fast Rendering of Vector Quantized Volumes</head><p>So far we have seen how the vector quantization data format can reduce dataset size with minimal impact on rendering time. In this section we describe how the coherence captured by the codebook may also be used t o accelerate both the shading and the ray tracing stages of a volume renderer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Shading</head><p>The shading computation assigns a color c and opacity CY to each voxel in the volume. In many common shading models, a voxel's color depends on both the field value and the surface normal vector, c = c(f,n,, n y r n,); f is mapped to surface reflection coefficients and (n,, ny , n,) is compared to the lighting and viewing directions. A voxel's opacity is usually defined as a function of the field value and the gradient magnitude, CY = a(f, IlVfll).</p><p>If each voxel is shaded in tu,, seconds, then conventional shading of the full volume takes N3tuoa seconds. To shade the compressed data, one need only process the blocks in the codebook since these codewords represent all voxels in the volume. Thus, for a given codebook size shading complexity is reduced from O ( N 3 ) to O(1). The net shading speedup is which applies to both voxel-spanning and space-filling block arrangements.</p><p>Example results for this relation are given in <ref type="figure">Fig. 4</ref>, which assumes a dataset size of N = 128. For the space-filling arrangement, the block sizes b = 2 and b = 3 correspond to the block lengths used in <ref type="figure" target="#fig_2">Fig. 3</ref>.</p><p>Clearly, the shading speedup can be quite dramatic as the dataset grows even larger.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Ray Tracing</head><p>The standard ray tracer for full volume rendering integrates the color and opacity by resampling these q-&amp; 303 1.2 values along each ray and composit,ing the samples <ref type="bibr" target="#b20">[6]</ref>. Assuming the voxel spacing is unity, and the pixel density in the image plane and sampling density along each ray are p(') and ~(0') samples per unit length, respectively, we obtain the total ray t.racing time as Thus, the total time is the number of steps, no, multiplied by the time per step, t o . At each step along a ray, the computation consists of incrementing the position ( i n c ) , resampling the color and opacity fields (trilerp), and blending the sample into the pixel (composite).</p><p>For the compressed volume, we propose a more efficient ray tracing algorithm <ref type="figure">(Fig. 5)</ref>. First, each block in the codebook is ray traced from the desired viewpoint to form a set of projected pixmaps; for small codebooks, t.he time required for these precomputations is negligible. Second, the entire volume is ray traced by stepping from block t,o block and compositing the appropriate pixels from the precomputed pixmaps. Compared to the standard ray tracer for full volumes, fewer steps are taken since the increment is on a block basis instead of a sample basis, and the cost of each step is less since no interpolat,ion is required. Note that this algorithm requires that the blocks fill the entire volume, so only the space-filling block arrangement is appropriate in this case.</p><p>Assuming the codebook is small enough so that the pixmap computation time is negligible, we have </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>P =</head><p>where p is a view-dependent factor that ranges from From Eqns. 6-8 we can calculate the ray tracing  to be approximately 6.0; this is reasonable since one trilinear interpolation is equivalent to seven linear interpolations (e.g. composite), and increment computations are inexpensive. Note that a range of speedups is possible depending on the geometry factor P.</p><formula xml:id="formula_3">1 to 6.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Experiments</head><p>We test the combination of VQ compression and accelerated volume rendering on two 1283 datasets, a C T study ("Head") and a coflowing air jet seeded with smoke ("Jet"). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Vector Quantizer Design</head><p>Each dataset consists of 1273 = 2.05 x lo6 spacefilling blocks of 2 x 2 x 2 voxels. These blocks are interpreted as vectors of length 32 since every voxel has four components { f , n,, ny , n,}. Designing codebooks of only 256 representative blocks for these datasets requires some care in order to obtain reasonable fidelity in a modest amount of processing time.</p><p>Our approach ( <ref type="figure" target="#fig_10">Fig. 7)</ref> is based on Classified VQ [13], which separates vectors into distinct classes and designs separate codewords for each class; the final codebook is the union of these codewords. We choose a simple scheme which defines only two classes : uniform blocks and active blocks. Uniform blocks are those in which all eight normal vectors are identically zero; all other blocks are classified as active. As a preliminary step before classification, normals are set to zero if the gradient magnitude is below some small threshold. This provides some tolerance for noisy data during classification, as well as control over the relative sizes of the classes.</p><p>The uniform blocks are encoded with MO codewords, each of which is constrained to have eight identical voxels {f,n,,ny,n,} = {fi,O,O,O}, o 5 i 5 MO -1. In our implementation, MO is selected so that a visually acceptable reconstruction of the uniform blocks is obtained (typically this is small, e.g.  . This technique begins with a training sequence of vectors and successively merges close ones until the number of vectors matches the desired number of codewords; these final vectors are used as the quantized reconstructions. In our application, a natural choice for the training sequence is the complete set of active blocks extracted from the volume. Due to memory and speed considerations, however, we select only a fraction of these blocks (every tenth) for training. The designed codewords are then used to encode all active blocks. An important parameter for this design is the normal vector scale factor, g n . At 8-bit resolution, the range of f is 0-255 and the (non-zero) signed normal vectors have magnitude 127. This nominal weighting causes the P N N algorithm t o place too little emphasis on accurately encoding f as opposed to the normals. By scaling the training sequence normals by a factor g n &lt; 1 prior to P N N design, a better balance is achieved. <ref type="figure">Figure 9</ref>: Slices of ny : (left) originals and (right) compressed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Results</head><p>Total design and encoding time is 48 minutes for the C T study and 32 minutes for the air jet. <ref type="figure" target="#fig_11">Figures 8 and  9</ref> show slices o f f and ny from the two datasets. <ref type="figure" target="#fig_0">Figure 10</ref> shows volume rendered images from the original and compressed data. The volume renderings are obtained with conventional ray tracing applied to the original data and accelerated ray tracing applied to the VQ volume. Images are volume rendered a t 256 x 256 resolution with a shading model that incorporates field-and normal-dependent <ref type="figure">peeular(f, n,, ny , nz)</ref>, and field-dependent opacity,   The 256 pixmaps for the CT rendering are shown in <ref type="figure" target="#fig_0">Fig. 11</ref> as a 16x16 matrix of 8x8 images. The displayed pixels represent the product of the color and opacity values. Note that a variety of intensities and patterns are present, indicating the codebook captures a diverse set of block types.</p><formula xml:id="formula_4">C,</formula><p>Statistics for the compression and rendering of the example datasets are given in <ref type="figure" target="#fig_0">Fig. 12</ref>. As is evident from the vector quantizer design table, more than half of the blocks in the original volumes are uniform, and these are represented with only 10 or 11 codewords. The reconstruction quality for the scalar field is meai sured by S N R j , which is the ratio of the signal variance to the error variance expressed in dB. The accuracy of the reconstructed normal vectors is given by Bavg, the average angular deviation from the actual normal.</p><p>As indicated by the gains  <ref type="figure" target="#fig_0">Figure 12</ref>: Performance on datasets.</p><p>speedup compare favorably with actual performance. These results demonstrate that the compressed format is a very attmctive alternative t o conventional volume represent at ion.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusions and Future Work</head><p>We have introduced a new compressed volume format that exploits statistical coherence between blocks in order t o obtain both storage savings and volume rendering acceleration. Compression gains are demonstrated for a codebook of 256 2 x 2 x 2 blocks applied to 1283 volumes in a space-filling arrangement, and are close t o predicted performance measures. A similar application of vector quantization to voxel-spanning blocks would increase the compression ratio t o 40 ( <ref type="figure" target="#fig_2">Fig. 3)</ref> and retain the observed shading speedups; the technique for ray tracing acceleration, however, would not apply.</p><p>Several topics merit future investigation. It would be desirable to automate selectmion of the volume encoding parameters that currently require manual intervention (gn and M O ) . The gradirnt magnitude can also be encoded so that more general opacity mappings are allowed. The block-stepping ray tracer can be combined with other techniques for fast ray tracing to obtain further speedups (e.g. adaptive sampling <ref type="bibr" target="#b22">[8]</ref>, early ray termination <ref type="bibr" target="#b21">[7]</ref>, and presence acceleration <ref type="bibr" target="#b21">[7]</ref>). To improve the accuracy of the compressed data, larger codebooks should be used and different vector quantization designs should be tested. The use of larger block sizes would provide even greater ray tracing speedups <ref type="figure" target="#fig_5">(Fig. 6)</ref>; this would probably require larger codebooks to produce reasonable images. A hi-(See colorplates, p.  erarchical arrangement of variable-size blocks may be used to adaptively compress and render volume regions according to some complexity measure.</p><p>Finally, we believe that other data compression techniques may also prove useful for volume rendering, as well as for visualization systems in general. The utility of any compression scheme depends, of course, on the accuracy requirements of the individual application. In some circumstances, however, processing large datasets may not be possible unless some form of compression is introduced.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>Visualization process; S is storage space, Tt is transmission time, and T, is processing time.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>4 Figure 2 :</head><label>42</label><figDesc>of b x b x b voxels. The number of indices required ((a) Voxel-spanning block arrangement and (b) space-filling block arrangement; B is a block.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Compression ratio, Rs oc svox (shown for suo, = 40).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>it requires r(Nl)/(b -1)13 indices. To cover both strategies, we assume N w N -1 and introduce the block length 1 defined as (2) e { b for voxel-spanning blocks for space-filling blocks b -1</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 4 :Figure 5 :</head><label>45</label><figDesc>Shading speedup, oc N 3 (shown for a: Ray tracing the vector quantized volume (a) pixmap computation (b) block-stepping.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 6 :</head><label>6</label><figDesc>Ray tracing speedup, (shown for ~'0') = 2.0 and U = 6.0). a p 5 ) u</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head></head><label></label><figDesc>The pixel density in the image plane p(') is identical t o that of rendering the original volume but the density of steps along the ray &amp;) differs from ~(0'). We use the block-stepping algorithm of[l], which passes (IAzI + lAyl + lAzI)/(b -1) blocks over a ray displacement vector(Az, Ay, At.). This gives a step density along</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>made the substitution U = t,/t,,.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 6</head><label>6</label><figDesc>shows the expected speedups for block sizes b = 2 and b = 3, using a typical value of p?) = 2.0. The factor U is experimentally determined</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>Experiments are performed t o determine image quality and rendering speedups, in addition t o storage savings. All results are obtained on a Silicon Graphics 4D/220GTX with 48MB of memory. The volumes are compressed with a codebook of 256 codewords representing blocks of 2 x 2 x 2 voxels. A space-filling block arrangement is selected in order to demonstrate ray tracing acceleration. Also, we use a shading model sensitive to surface normals so { f , n,, ny , n,} is encoded at each voxel. For purposes of comparison we implement a conventional volume ray tracer which stores {f, no, ny , n,, c} a t each voxel at 8-bit resolution (s,,, = 40 bits).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 7 :</head><label>7</label><figDesc>Volume encoding.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 8 :</head><label>8</label><figDesc>Slices o f f : (left) originals and (right) compressed. MO = 10). It should also be possible to automate this selection according to some @nimum error criterion. To determine a good set of {f;}, we first compute the average field value faug for each uniform block in the volume. An optimal scalar quantizer of MO levels is then designed for the distribution of faus using the iterative Lloyd algorithm [9]. The resulting quantization levels are the values for {f;}. By reducing the uniform block design to a scalar quantization problem, processing the uniform class is very fast and is a negligible portion of total design time. Even with small thresholds for the gradient magnitude, over half of the blocks in the two datasets are assigned t o this class, thus greatly simplifying overall design. For the remaining (active) blocks, a vector quantizer of M -MO codewords is designed with the fast Pairwise Nearest Neighbor (PNN) algorithm [3]</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>CY</head><label></label><figDesc>= (~( f ) . The codebook pixmaps are ray traced at 8 x 8 resolution, and color and opacity are stored in the pixmaps as 8-bit quantities. The rendered images from the compressed volumes are visibly different, with the main artifacts being some additional "blockiness" and contouring in regions of smoothly varying intensity (note, for example, color, c = Cambient(f) + C d i f f u s e ( f r n z , n y , nz) + (See color plates, p. CP-2.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>Figure 10 :Figure 11 :</head><label>1011</label><figDesc>Volume renderings : (left) originals and (right) compressed. Head Jet Codebook pixmaps for Head.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>the top of the head). Most features are preserved, however, such as the thin strap across the forehead in the CT study, and the ripples in the surface of the air jet.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>of a by table lookup on f and IlVfll, suo, becomes 48 bits. In [22], (n,, ny , n,) is represented by 13 instead of 24 bits, and c is implicitly defined as a lookup on the 13-bit table; this reduces suo, further t o 29 bits.</head><label></label><figDesc></figDesc><table><row><cell>volume renderer computes an image from</cell></row><row><cell>these voxels by assuming a translucent material</cell></row><row><cell>model and rendering from a given point of view</cell></row><row><cell>[2] [5] [6][ 101 [ 141 [IS][ 171 [ 19][20] [2 11. The material model</cell></row><row><cell>is defined by assigning a color, c, and an opacity, a,</cell></row><row><cell>to each point in the volume (here we assume the scene</cell></row><row><cell>is monochromatic so c is a scalar); these values are</cell></row><row><cell>integrated along viewing rays to form final pixel in-</cell></row><row><cell>tensities.</cell></row><row><cell>In the simplest material model, color and opacity</cell></row><row><cell>are user-defined mappings of the scalar field value, f ,</cell></row><row><cell>and are implemented as lookup tables; thus, only a</cell></row><row><cell>single number is stored a t each voxel, e.g. svoz = 8</cell></row><row><cell>bits. More complicated implementations, however,</cell></row><row><cell>require the storage of additional variables at each</cell></row><row><cell>grid location. For example, the surface normal vec-</cell></row><row><cell>tor, (n,,ny,nz), which is given by the direction of</cell></row><row><cell>the field gradient, is often included so that the color</cell></row><row><cell>value incorporates directional shading. In addition,</cell></row><row><cell>the gradient magnitude, IlVfll, may be stored t o in-</cell></row><row><cell>fluence the opacity level. Finally, c and a may also</cell></row><row><cell>be explicitly stored for each voxel so that the same</cell></row><row><cell>material model can be rendered from different view-</cell></row><row><cell>points without recomputing color and opacity. In all,</cell></row><row><cell>the full volume representation in a volume render-</cell></row><row><cell>ing application may consist of seven values per voxel,</cell></row><row><cell>{f,n,,ny,n,,((Vf((,c,a}; at &amp;bit. resolution this re-</cell></row><row><cell>quires s , , , = 56 bits.</cell></row><row><cell>Some simple schemes can reduce this number. For</cell></row><row><cell>example, by replacing explicit st,orage</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>table, the predictions for compression ratio, shading speedup, and ray tracing I</figDesc><table><row><cell cols="2">Vector Quantizer Design [ Unif Blocks I Act Blocks [ Data I Orig VQ I gn I S N R f I Bavg I I VQ I Orig Head 1 1.2M 11 I 833K 245 I 0.4 [ 17.6dB I 20.0Â° I Jet I 1.4M 10 I 629K 246 I 0.3 I 17.7dB I 22.6' I I</cell></row><row><cell>Original/VQ Storage and Rendering</cell><cell></cell></row><row><cell cols="2">Data I p r ) I I Storage I Shade I R a y Trace Head I 2.0 I 1.0 I 10/2MB I 13410.12sec I 6 4 2 1 5 4 s~ I Jet I 1.7 I 1.3 I IOj2MB 1 77jO.08sec I 417j54sec 1</cell></row><row><cell>Actual/Predicted Gains</cell><cell>I</cell></row></table><note>I Data I Rc I R(_shade) I R(_raytrace) I</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We wish to thank Ram Subbarao and Brian Cantwell for providing the air jet data, and the University of North Carolina for providing the CT data. This work is supported by NASA under contracts NAG 2-701 and NCA 2-579, including support from the NASA Ames Numerical Aerodynamics Simulation Program and the NASA Ames Fluid Dynamics Division, and by NSF under grant ECS 8815815.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0" />			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Proceedings of San Diego Workshop on Volume Visualization</title>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="27" to="33" />
			<date type="published" when="1990-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Octree Pruning for Variable-Resolution Isosurfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Ning</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hesselink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visual Computing</title>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1992-06" />
			<biblScope unit="page" from="349" to="363" />
		</imprint>
	</monogr>
	<note>Proceedings of Computer Graphics International &apos;92</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Vector Quantization for Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Ning</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hesselink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Boston Workshop on Volume Visualization</title>
		<meeting>Boston Workshop on Volume Visualization</meeting>
		<imprint>
			<publisher>ACM Press</publisher>
			<date type="published" when="1992-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Classified Vector Quantization of Images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Ramamurthi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Gersho</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Tmns. Commun</title>
		<imprint>
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="1105" to="1115" />
			<date type="published" when="1986-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">A Rendering Algorithm for Visualizing 3D Scalar Fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Sabella</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH &apos;88</title>
		<meeting>SIGGRAPH &apos;88</meeting>
		<imprint>
			<date type="published" when="1988-08" />
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="51" to="58" />
		</imprint>
	</monogr>
	<note>Computer Graphics</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Decimation of Triangle Meshes. Proceedings of SIG-GRAPH &apos;92</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Zarge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">In Computer</title>
		<imprint>
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="65" to="70" />
			<date type="published" when="1992-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A Polygonal Approximation to Direct Scalar Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Shirley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Tuchman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of San Diego Workshop on Volume Visualization</title>
		<meeting>San Diego Workshop on Volume Visualization</meeting>
		<imprint>
			<date type="published" when="1990-11" />
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="63" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Tiede</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">H</forename><surname>Hoehne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Bomans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Pommert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Riemer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wiebecke</surname></persName>
		</author>
		<imprint>
			<biblScope unit="page" from="69" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">3D-Rendering Algorithms</title>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="page" from="41" to="53" />
			<date type="published" when="1990-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">&amp;-Tiling Polygonal Surfaces</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Turk</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH &apos;92</title>
		<meeting>SIGGRAPH &apos;92</meeting>
		<imprint>
			<date type="published" when="1992-07" />
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="55" to="64" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Ume Rendering</surname></persName>
		</author>
		<title level="m">Proceedings of SIGGRAPH &apos;88</title>
		<meeting>SIGGRAPH &apos;88</meeting>
		<imprint>
			<date type="published" when="1988-08" />
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="59" to="64" />
		</imprint>
	</monogr>
	<note>Computer Graphics</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Footprint Evaluation for Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Westover</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of SIGGRAPH &apos;90</title>
		<meeting>SIGGRAPH &apos;90</meeting>
		<imprint>
			<date type="published" when="1990-08" />
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="page" from="367" to="376" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">A Coherent Projection Approach for Direct Volume Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Wilhelms</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Gelder</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics</title>
		<imprint>
			<date type="published" when="1991-07" />
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="275" to="284" />
		</imprint>
	</monogr>
	<note>Proceedings of SIGGRAPH &apos;91</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Achieving Direct Volume Visualization with Interactive Semantic Region Selection</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">S</forename><surname>Yoo</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">U</forename><surname>Neumann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Fuchs</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">M</forename><surname>Pizer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Cullip</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rhoades</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Whitaker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of IEEE Visualization &apos;91</title>
		<meeting>IEEE Visualization &apos;91<address><addrLine>San Diego</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991-10" />
			<biblScope unit="page" from="58" to="65" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A Fast Voxel Traversal for Ray Tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Amanatides</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Woo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings Of Eurographics &apos;87</title>
		<meeting>Of Eurographics &apos;87</meeting>
		<imprint>
			<biblScope unit="page" from="3" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Drebin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Carpenter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
		<title level="m">ume Rendering&apos; Proceedings Of &apos;IGGRAPH</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Keeler</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>V-Buffer</surname></persName>
		</author>
		<title level="m">Visible Vel-Computer Graphics</title>
		<imprint>
			<date type="published" when="1988-08" />
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="65" to="74" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<monogr>
		<title level="m" type="main">A New Vector Quantization Clustering 3 7 j lo</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">H</forename><surname>Equitz</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1989-10" />
			<biblScope unit="page" from="1568" to="1575" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Vector Quantization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Gray</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE ASSP Magazine</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="4" to="29" />
			<date type="published" when="1984-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Digital Reconstruction Methods for Three-Dimensional Image Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">M</forename><surname>Jaffey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Dutta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hesselink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Proceedings of SPIE</title>
		<imprint>
			<biblScope unit="volume">507</biblScope>
			<biblScope unit="page" from="155" to="162" />
			<date type="published" when="1984-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Display of Surfaces from Volume Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="29" to="37" />
			<date type="published" when="1988-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Efficient Ray Tracing of Volume Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<date type="published" when="1990-07" />
		</imprint>
	</monogr>
	<note>IEEE Trans</note>
</biblStruct>

<biblStruct xml:id="b22">
	<analytic>
		<title level="a" type="main">Volume Rendering by Adaptive Refinement</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="page" from="2" to="7" />
			<date type="published" when="1990-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b23">
	<analytic>
		<title level="a" type="main">Least Squares Quantization in PCM</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">P</forename><surname>Lloyd</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Trans. Inform. Theory</title>
		<imprint>
			<biblScope unit="volume">28</biblScope>
			<biblScope unit="page" from="127" to="135" />
			<date type="published" when="1982-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b24">
	<monogr>
		<title level="m" type="main">Area and Volume Coherence for Efficient Visualization of 3D</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hanrahan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
