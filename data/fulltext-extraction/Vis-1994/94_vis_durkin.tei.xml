<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Nonpolygonal Isosurface Rendering for Large Volume Datasets</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">James</forename><forename type="middle">W</forename><surname>Durkin</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Program of Computer Graphics</orgName>
								<orgName type="institution">Come11 University Ithaca</orgName>
								<address>
									<postCode>14853</postCode>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">E</forename><surname>Hughes</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Computer Science Department Brown University Providence</orgName>
								<address>
									<postCode>029 12</postCode>
									<region>RI</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Nonpolygonal Isosurface Rendering for Large Volume Datasets</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Sulface-based rendering techniques, particularly those that extract a polygonal approximation of an isosulface, are widely used in volume visualization. As dataset size increases though, the computational demands of these methods can overwhelm typically available computing resources. Recent work on accelerating such techniques has focused on preprocessing the volume data or postprocessing the extracted polygonization. Our new algorithm concentrates instead on streamlining the sulface extraction process itselfso as to accelerate the rendering of large volumes. The technique shortens the conventional isosu$ace visualization pipeline by eliminating the intermediate polygonization. We compute the contribution of the isosulface within a volume cell to the resulting image directly from a simplified numerical description of the celVsulface intersection. Our approach also reduces the work in the remaining stages of the visualization process. By quantizing the volume data, we exploit precomputed and cached data at key processing steps to improve rendering efficiency. The resulting implementation provides comparatively fast renderings with reasonable image quality, &apos;The notable exception is frequency-domain volume rendering [ 5 , 9 ] , with a complexity of O(n2 logn).</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Background</head><p>Increasingly complex environments present an ongoing challenge to computer graphics. A dominant source of increased complexity in volume visualization is growth in data size. Early volume datasets typically ranged from M3 to 1283 voxels, while many of today's volumes are reaching the 5123 to 10243 voxel range. The introduction of higher resolution data acquisition devices and more complex simulations suggests this growth trend will continue.</p><p>The essential difficulty such growth poses is that the computational complexity of most volume rendering algorithms is O(n3) for a dataset of size n x n x n.' Thus doubling volume dimension, say from 2563 to 5123, yields an eightfold increase in computational cost. Even today's fastest workstations are, at best, barely keeping pace with the demands of rendering large volumes in reasonable amounts of time.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Prior work</head><p>Volume data has, by itself, no visible manifestation. Implicit in its visualization is the creation of an intermediate representation, some visible object or phenomenon, that can be rendered. Levoy Among the classes are sulface-based techniques, those USing polygons or surface patches as the representation. Such techniques have proved popular due to their ease of use, range of applicability, and comparatively fast execution.</p><p>Surface-based techniques are characterized by the application of a surface detector to the data, followed by a fitting of geometric primitives to the detected surface, and the rendering of the resulting geometric representation. The techniques differ primarily in their choice of primitives and the scale at which they are defined. The primitives are typically fitted to an approximation of an isosurface of the continuous scalar field within cells of the volume.2</p><p>The best known of these techniques is the Marching Cubes algorithm <ref type="bibr" target="#b2">[4]</ref>. Processing the volume cell by cell, the algorithm classifies each cell based on the value of its voxels relative to that of the isosurface being reconstructed. The classification yields a binary encoding that provides an index into a table describing the polygonal approximation of the isosurface within the cell. Polygon vertex positions are computed by interpolating voxel values, as specified by the indexed table entry. The generated polygons are transferred to a hardware or software polygon renderer for display. Gouraud shading is often used to achieve a smoother image. To do this, the algorithm approximates the volume gradient at voxel positions and interpolates these gradient vectors to produce normals at polygon vertices.</p><p>Wyvill et al. <ref type="bibr" target="#b9">[12]</ref> present a very similar technique. They too classify cell voxels relative to isosurface value and calculate polygon vertex positions by voxel value interpolation. Their technique differs from Marching Cubes in that it uses an approximate value at the center of a cell face to select among alternate polygon configurations.</p><p>An alternative to isosurface polygonization is the pointbased Dividing Cubes algorithm <ref type="bibr">[ 11.</ref> It subdivides volume cells into sub-cells with lattice spacing equal to the image grid spacing. Data values for sub-cell vertices are interpolated from the divided cell's vertex voxels. Sub-cells intersecting the surface are identified as those having values both above and below the isosurface value. For these sub-cells, a normal vector is interpolated from volume gradients as in Marching Cubes. This normal is used to shade the intersection point, considered to lie at the sub-cell center, which is then projected onto the image plane where the computed intensity is assigned to the appropriate pixel.</p><p>Recent work has focused on improving the performance of such techniques. <ref type="bibr">Wilhelms</ref>  tial data structures as a preprocess to reduce the work devoted to regions within the volume of little or no interest. Schroeder et al. <ref type="bibr" target="#b6">[8]</ref> reduce the number of triangles required for the polygonal representation of objects through a postprocess, making the extracted representation renderable on typical graphics hardware.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.3">Motivation</head><p>As dataset size grows, the processing demands of conventional techniques can severely tax even the fastest workstations. Consider an example. The industrial CT dataset of the turbine blade in <ref type="figure" target="#fig_9">Figure 6</ref> (also illustrated by Schroeder et al. <ref type="bibr" target="#b6">[8]</ref>) contains 300 slices, each of size 5 1 2~ 512. The isosurface created from this data by Marching Cubes contains approximately 1.7 million triangles. Several stages in the algorithm are particularly expensive when processing such complex surfaces. The number of floating point operations required to calculate position, normal, and color information for the 5.1 million triangle vertices is enormous, even when reusing data at shared vertices. The amount of data transferred to the display system is also enormous: at 50 bytes per vertex, it is roughly 250 megabytes of information. Finally, rendering 1.7 million polygons is beyond the capabilities of all but the most advanced workstations.</p><p>The necessity of such expensive processing is an open question. In a typical image, say 5 12 x 5 12 pixels, these 1.7 million polygons are each rendered at sub-pixel size. One can well suggest that, given the small contribution of each polygon to the final image, the tremendous work involved in processing polygons for such a surface is probably excessive. An alternative to preprocessing the volume data or post-processing the polygonal surface is to concentrate instead on the surface extraction process itself. Our technique streamlines the isosurface visualization pipeline by eliminating the intermediate polygonization stage and reducing the work required at the remaining stages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Foundations</head><p>Our algorithm is based, in part, on three observations about the surface-based rendering of large volumes:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Cell projections are small</head><p>In a 'complete' image of a large volume, a cell projects to about the size of a pixel. If we make the correspondence exact (i.e., volume inter-voxel spacing equals image interpixel spacing), an orthographic projection of an n3 volume has a maximum image size of &amp;n x f i n pixels. For n between 5 12 and 1024, the image occupies from 6&amp;240% of a typical workstation screen, suggesting that using such a correspondence produces sufficiently large images.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>lsosurfaces are locally almost planar</head><p>The intersection of an isosurface with a cell is almost always well approximated by a plane. The function whose isosurface we are reconstructing was sampled in some way to generate the volume data. Unless the original function was band-limited before sampling, the data will contain aliasing. We therefore assume we are reconstructing the isosurface of the (unique) band-limited function f whose samples constitute our volume. Such band-limited func- tions are always @". Sard's Theorem <ref type="bibr" target="#b4">[6]</ref> guarantees that for almost every (in the measure-theoretic sense) isosurface value v, the isosurface f-' (v) contains no zeroes of the gradient off. Thus almost every isosurface is locally smooth (by the implicit function theorem). Smooth surfaces can be approximated by their tangent planes, to an accuracy that depends on the surface curvature. The inaccuracy of our method is thus quantified by the local curvature of the isosurface. Near singular points, this can become arbitrarily large, but surface-based methods typically suffer from this: cells containing singular points are generally ambiguous.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Data can be quantized</head><p>To reduce rendering expense, we want to exploit precomputed and cached data whenever possible (e.g., using a precomputed approximation of the isosurface within a cell). To keep such data of reasonable size, we need to index it not by full-range volume data, but by a quantized representation of a cell's voxel values. Quantized data can produce a reasonably accurate isosurface approximation. <ref type="figure" target="#fig_1">Figure 1</ref> shows that quantizing the data introduces some error; increasing the allowable range for the quantized representation reduces the error, but cannot eliminate it. Although we have not formally analyzed the error due to quantization, our empirical results suggest that the visual artifacts that result are acceptable. In any event, the quantization error is in the sub-cell placement of the isosurface, and hence (after projection) in the sub-pixel placement of the surface image. If the original data indicates the presence of surface within a cell, so too will the quantized data (if processed properly): isosurface topology is not altered, so no spurious surfaces or erroneous holes are introduced.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Algorithm overview</head><p>To render an image, we start with a volume dataset, an isolevel e, a viewing direction, and lighting information.</p><p>As we precompute an approximation of the isosurface within a cell and index it by voxel values, our first step is to limit the data range within the volume. We choose a range r and quantize voxel values to an interval of length r that contains e. To illustrate, let us assume that e lies halfway along this interval (in practice this is not a requirement). Next is the computation of the planar isosurface approximation data, the isoplane table (see Section 4.1). This table depends only on rand C, and can therefore be precomputed. For each possible eight-tuple of values at the cell vertices, the table contains a description of the planar approximation of the isosurface within that cell, including the area of the plane within the cell and the plane normal.</p><p>The second step of the algorithm proper is initialization of the image, corresponding to a region on the projection plane. The inter-pixel spacing on this plane is made equal to the inter-voxel spacing in the volume. Thus the projection of a cell overlaps at most nine image pixels. The color and a channels of the image are initialized to zero.</p><p>The third step in the algorithm uses the isoplane table to compute a rendering of the isosurface. The volume is traversed from front to back and each cell is examined. The quantized voxel values at a cell's vertices are used as an index into the isoplane table, which contains the area and normal vector for the isosurface approximation within the cell.</p><p>If the area is zero (the isosurface does not intersect the cell), or if the dot product of the normal and the projection direction is negative (the surface is back-facing), the cell is ignored. Otherwise, the area is multiplied by this dot product to find the projected area of the cell's isosurface on the image plane. We compute the light reflected from the surface fragment (if not previously computed) and record it in a cached data structure called the intensity table (see Section 4.2), indexed by the cell's eight voxel values.</p><p>We accumulate into the image the light reflected from the surface fragment towards the image plane. Lacking precise geometric information describing the position of the surface within the cell, we assume that the projection of the surface fragment is evenly distributed across that of the entire cell onto the image plane. We can therefore clip the cell's projection against the pixels in the image plane to compute the fraction of the reflected light that should be composited into each of the nine pixels the cell projection may overlap. We avoid repeated clipping by precomputing a table describing the projectiodpixel overlap for a representative set of the possible projection positions (see Section 4.3).</p><p>Using a modification of standard compositing (see Section 4.4) we accumulate values in the image until the a value for a pixel is 1.0, after which no more light is composited into the pixel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Algorithm details</head><p>This algorithm exploits precomputed and cached data wherever possible, an approach that might well be termed look-up tables everywhere. We discuss the most important of these tables, and other implementation details, below.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Isoplane table</head><p>The precomputed planar approximation of the isosurface within volume cells depends on the quantized data range r and the isosurface level tmore precisely, on the location o f t within an interval of length r. We therefore create a corresponds to a cube whose vertex 0 has value VO, vertex 1 has value V I , and so on. Given the values V O , . . . , v7 at these comers (whose positions we denote P O , . . . , p7), we approximate the isosurface by a plane determined by these values.</p><p>We do this by one of three methods, all variants of the same technique. Certain vertices of the cube are marked, and those vertices alone are used to find a least-squares bestfit plane. That is to say, we seek the function</p><formula xml:id="formula_0">f ( x , y , z ) = Ax + By + Cz + D such that ( f ( p i ) - where M = {marked vertices} iEM</formula><p>is minimized. This is a straightforward least-squares problem in the unknowns A, B, C, and D.</p><p>The three methods differ in the choice of which cell vertices to mark. The first method marks all vertices, yielding a least-squares solution using all available data. We call this method all-voxels. In the second, we mark only cube edge endpoints with values on opposite sides of the isosurface level. The method, called edge-crossings, is analogous to Marching Cubes' identification of polygon vertex locations. In the third method, if any vertex has a value at either extreme of the quantized data range, and all three neighbor vertices (those connected to it by an edge) share the same value, then that vertex is unmarked; all others vertices are marked. This approach reduces the error in the approximation of the plane equation by eliminating data values that violate the assumption of linearity due to the limited range of the table. We term this technique sans-clamped. For any cell intersecting the isosurface, there are at least four marked voxels for any of the three methods, so the leastsquares problem always has a unique solution.</p><p>Having found the function f above, we consider the plane f ( x , y , z ) = C' to be our 'best linear approximation' to the isosurface. We clip this plane to the bounds of the cell, compute the area remaining, and record this in the table along with A, B, and C, which constitute the plane normal.</p><p>The table as described has r8 entries. We store the area and normal data as floating-point numbers. At four bytes per value, we have sixteen bytes per table entry. Using ten megabytes as a rough limit for such precomputed data, the maximum allowable r is 5.</p><p>Fortunately, we can exploit the symmetry of the cube to give us a table compression scheme. A cube centered at the origin has many geometric symmetries: rotations about the x-, yand z-axes, reflections in the xy-, yz-, and xz-planes, and combinations of these. For any eight-tuple of values labeling the cube's vertices, we consider the labelings derived from it by applying such symmetries to the cube as equivalent. That is, the area of the planar isosurface approximation for each is the same, and the surface normals are simple transformations of one another. We wish to map each such equivalence class to a single entry in our compressed isoplane In accessing the compressed table, the voxel values at cell vertices are permuted according to the above scheme, and the permuted tuple is used for table look-up. The permutation is a linear transformation of the cell, so we apply the inverse adjoint of this transformation in extracting the normal vector. The processing required to access data from the compressed table is approximately double that for the uncompressed table. Only with such compression though, is this precomputation technique feasible for larger values of r. In practice, we observe an actual increase in rendering time with compressed isoplane tables of only 1-10%. That this is lower than the raw increase in access time suggests, makes sense; isoplane table access is not the only step in rendering, nor do all cells intersect the isosurface (access time for 'empty' cells is the same for both table forms).</p><p>The incentive to use as large an r as possible is strong, as the quantized data range is a major factor in determining image quality. <ref type="figure" target="#fig_3">Figure 2</ref> shows the result of using tables of varying r value. As expected, image quality improves with larger table^.^ We typically keep precomputed tables for ranges of 2, 4, 6, and 8, with C' at the range midpoint.</p><p>The first two tables are usually kept uncompressed, and the latter two in compressed form.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Intensity table</head><p>In examining each cell, we look up its isosurface approximation in the isoplane table and apply the user-defined 3The test sphere, with its large, constant-curvature surface, highlights the effects of the quantization and linear approximation; lower r values frequently produce satisfactory images on real-world datasets. With an uncompressed isoplane table, we could add the information to that table at run-time, but for a compressed table, the need to permute the surface normal makes this impossible.</p><p>In principle, this table is of size 9. To limit the size in practice, we allocate space for the intensity table in parts. We first allocate a table of pointers of size r4, indexed by the cell's first four voxel values. This part of the table is quite small, requiring only 4,096 pointers for r = 8. We allocate 'data pages' only when we must compute the light intensity for a given eight-tuple of values on that page. The data pages are of size r4, and are indexed by the cell's last four voxel values. Individual entries on the data pages are computed only as needed, and are reused by later cells with the same eight voxel values.</p><p>To minimize space requirements, we use only four bytes per entry, one byte each for the red, green, and blue color values plus a byte for flags used in table management. This follows the heuristic that eight bit color values are adequate in image compositing, but higher accuracy is required for the a-channel. We compute the a value elsewhere in the rendering process (using the projected area of the cell's isosurface) and do not cache it in the intensity table.</p><p>This approach provides what we feel is the best tradeoff among access time, memory usage, and time spent computing intensity values. In practice, cell voxel values are not evenly distributed (they tend to cluster), so for typical r values (4 and above) we rarely allocate all data pages or compute a large percentage of the entries on allocated pages.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Cell projection table</head><p>As we restrict ourselves to parallel projections, the projections of any two cells onto the image plane are congruent. By precomputing a limited set of cell projections, we can <ref type="figure" target="#fig_4">(See color plates, page CP-33.)</ref> approximate the projection of any volume cell and avoid the expense of repeated projection operations. We exploit this in computing the contribution to the image of a cell's projected isosurface fragment.</p><p>At the start of rendering, we project the vertices of a single cell onto the image plane and compute their convex hull, thus providing the polygonal projection of the whole cell. We calculate the position of the lower left comer of the projected polygon's bounding rectangle and designate it as the projection marker (see <ref type="figure" target="#fig_4">Figure 3)</ref>. The polygon is translated so that the projection marker lies at the origin of the image plane: the polygon now lies on a 3 x 3 pixel grid whose lower left comer has coordinates [0, 01. We clip the polygon to each of the nine pixels and record the fraction of its area lying within each. If we offset the position of the polygon so that its marker lies at each of a discrete set of sub-pixel positions in the region <ref type="bibr">[O, 1)</ref> x [0, l ) , performing the clip and record operation each time, we then have a reasonable approximation of the cell's projected area over the 3 x 3 grid for any projection (and hence any cell) position. We use a 20x20 array of sub-pixel positions, which can be computed quickly and provides reasonable accuracy.</p><p>We can compute the position of the projection marker for each cell intersecting the isosurface, and use the fractional part of that position (modulo the discretization rate) as an index into the cell projection table. The corresponding table entry gives the fraction of the light contributed by the cell to be composited into each of the nine pixels its projection may overlap. Exploiting the congruency further, we need perform the complete projection marker calculation only for the first cell visited; the position of any other projection marker can be computed via a simple offset from the first cell's marker, based on the x, y, and z offset of the cell's position relative to that of the initial cell.</p><p>Distributing the light contributed by a surface fragment evenly across the cell's projection is an approximation. Some approximation is necessary to avoid the prohibitive expense of storing in the isoplane table a precise geometric description of the isosurface intersection. Using an even distribution is roughly equivalent to averaging over all positions within the cell of a fragment with that area and normal.</p><p>Clipping the cell's projection to pixel boundaries is equivalent to convolving the projection with a box filter and point sampling at pixel centers. It would be straightforward to extend the method to use arbitrary filters, and as the cell projection table is precomputed the cost would be negligible. Our experience, however, indicates that box filtering, in conjunction with the averaging operation just discussed, yields sufficiently good results.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Compositing</head><p>As described above, for each cell containing a frontfacing piece of the isosurface we compute the amount of light reflected toward the image plane, and then distribute that light to the nine pixels onto which the cell projects.</p><p>In essence we are compositing a series of 3 x 3 pixel subimages into an accumulating larger image. Porter and Duff's image compositing algebra <ref type="bibr" target="#b5">[7]</ref> assumes that the contents of two pixels being composited are randomly dis- tributed. In our situation this assumption is almost always false, so we extend the algebra by a new operator to compensate.</p><p>Consider the case where adjacent cells both project onto the same image pixel and contain adjoining bits of the isosurface (see <ref type="figure" target="#fig_6">Figure 4</ref>). The composited pixel has less coverage than expected and appears too dark. In this case, the contents were not at all independently distributed. To address this situation we replace over with a new compositing operator, add. For add the values of FA and FB are F~= l . 0 and F~= m i n ( ( l . O -a~) / a B , 1.0).</p><p>The a value of the composited pixel (A add B) is now ( F A x~A ) + ( F B x~B ) = ( 1 . 0~0 . 5 ) + ( 1 . 0~0 . 5 ) = 1.0. This gives the composited pixel the expected (full) coverage and the correct intensity.</p><p>The assumption that the contributions from multiple cells to a single pixel is not independent fails in some cases. If non-neighboring cells contribute to the same pixel, the Porter-Duff independence assumption is valid. We therefore expect slightly-too-bright edges when multiple silhouette edges project onto the same pixel. We have not observed this in practice, nor do we expect to: a pixel generically is the projection of the interior of a surface, and being on the projection of a silhouette is unusual. Being on the projection of two silhouettes is very unlikely, and should happen only at isolated pixels. The error is dual to that made by a Z-buffer renderer, in which a nearby polygon that partially covers a pixel can totally obscure a distant polygon that completely covers the pixel, yielding a too-dim image.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Algorithm extensions</head><p>The algorithm as described makes every effort to reduce the work at key steps in the rendering process. The characteristics of the volume data and its rendered image that make the acceleration possible also limit the types of data we can process and the kinds of image we can render. Limitations include quantizing the volume as a whole prior to rendering, restricting processing to regular-uniform data4, and rendering only orthographic views.</p><p>These limitations are not, however, fundamental: each can be relaxed or eliminated, at some additional cost. We have extended the algorithm in various ways. The more important extensions implemented so far are described below. We give the user control in enabling these extensions, so that the visualization needs can dictate the tradeoff between flexibility and speed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Cell-based quantization</head><p>Our extensive use of precomputed and cached data requires restricting the volume's data range, so that we can use the cell voxel values as a look-up table index. Normally this involves processing the volume once per isosurface level, prior to the start of rendering. This quantization requires visiting each voxel only once, and is comparatively fast.</p><p>Quantizing prior to rendering gives the best speed-up, but limits our accuracy in approximating the isosurface within a cell. The range of values across cells intersecting the isosurface is not always the same, and can be much less than the data range over which we quantize the volume as a whole. We can therefore achieve a more accurate approximation if we quantize voxels on a cell-by-cell basis rather than once per volume. Unfortunately, cell-by-cell quanti-4Regular volumes are those with voxels arranged on a regular lattice, with constant spacing along each axis. Uniform refers to equal spacing along all axes. We do, however, allow cell-based quantization. When specified, we skip the quantization preprocess and quantize during the rendering. For each cell that contains isosurface, we copy its voxel values to local storage and quantize using the data range over just that cell. We then use these quantized values as our table look-up index.</p><p>For certain data, this processing can produce a marked improvement in image quality, particularly surface smoothness. The dataset for <ref type="figure" target="#fig_7">Figure 5</ref> is a 2563 volume, with fullrange eight bit data. The volume contains a 'spherical' isosurface, of radius 120, at a level of 127.5. The data in the vicinity of the surface ranges from 0 to 255, via a linear ramp, over a distance of eight voxels. Prequantizing the volume from the full range of 256 into a range of 8 (corresponding to the isoplane table range used for rendering) leaves us roughly one bit of accuracy per voxel value, for cells intersecting the surface. Using cell-based quantization allows us to achieve almost the full three bits allowed by the isoplane table. The resulting improvement in image quality is clear. While in practice, only a limited number of volumes actually exhibit such characteristics, the feature is always available for use as desired.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Non-uniform volumes</head><p>The isoplane table data is computed for cubical cells. If the voxel spacing in the volume is not uniform, so that the cells are parallelepipeds, we typically resample the volume to make it uniform. By modifying our algorithm slightly we can avoid this resampling. The transformation from a cube to a general parallelepiped is just a non-uniform scaling, so we can still use the precomputed isoplane table data. The area and normal information extracted from the table must, however, be transformed prior to its use.</p><p>Let us denote the inter-voxel spacing along the three axes of the non-uniform volume by S,, S,, and S,. We index into the isoplane table using the quantized cell values, as described previously. Before using the isosurface fragment's area and normal though, we must first compute its 'scaletransformed' normal and area, N' and A' respectively.</p><p>We transform the normal vector N by the scale transfor- To compute NI, we normalize U ,</p><formula xml:id="formula_1">N' = U/IIUII.</formula><p>The transformed area A' is The factor (SxSySz) can be computed once for the entire volume. The net expense of this non-uniform scaling is therefore three divides, one vector normalization, and two multiplications per cell.</p><p>We must also adjust the size of our pixel grid in the cell projection table, since the projection of a cell in the nonuniform volume may not always lie within a 3 x 3 pixel area (for a 1 x 1 x 2 inter-voxel spacing, the projection may cover any of the pixels in a 4 x 4 region).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Results</head><p>We illustrate the algorithm's use with datasets from the medical and industrial communities. The data was processed and rendered on Hewlett-Packard Series 700 workstations, typically with machines having sufficient real memory to contain both the volume data and the precomputedcached tables. No graphics hardware acceleration was used. All images were rendered with a r = 8, edgecrossings, compressed isoplane table.    is fairly noisy, but the algorithm nonetheless extracts sufficient fine detail to interpret the key elements of the blood vessel structure. Although rendered with a r = 8 isoplane table, for data of this type smaller ranges (e.g., r = 4) produce nearly identical results. Rendering time for the image was 86.5 seconds.</p><p>In considering the rendering performance, note that the algorithm currently make no use of spatial data structures, such as octrees or bounding volumes, to accelerate the rendering. As such, every cell in the volume is examined in generating the surface representation. Clearly spatial data structures can reduce the effort expended on regions of the volume not intersecting the isosurface, yielding a corresponding improvement in performance. We chose to focus on reducing the work at cells containing isosurface, knowing that spatial acceleration techniques could be integrated later. Based on existing work using such approaches (e.g., Wilhelms and Van Gelder [ 1 I], Laur and Hanrahan [2]) and our own observations on the small percentage of cells that intersect a typical isosurface, we expect a substantial speedup from using such a technique, quite likely a factor of ten or more.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Futurework</head><p>After integrating a spatial acceleration mechanism, next on our list of future work items is an error analysis of the algorithm. The approximations made at various stages of the rendering process to minimize cost introduce some 'errors' into the resulting image. The main sources of error are data quantization, the approximation of the surface within a cell by a plane, and the projection of that surface approximation onto the image plane. It is fairly straightforward to quantify the error at each stage. The more difficult problem is relating the separate error metrics in a way relevant to actual image quality. We could use such error measures to improve accuracy, even if we cannot develop a single quality metric. For instance, we could store an error value based on the closeness of the planar surface approximation, for each isoplane table entry. We could use this value, alone or in combination with some quantization error measure, to decide whether the surface approximation for a given cell is sufficiently accurate. If not, we could subdivide the cell, interpolating interior values as necessary, and recursively apply our surface approximation method to the resulting sub-cells.</p><p>We are also interested in examining higher-order isosurface approximations that could be stored in a minimum of space. One motivation for this stems from what we term ambiguous cells. For a cell intersecting the isosurface, it is possible for the least-squares solution in Section 4.1 to have A =B=C=O. Such ambiguous cases have reflectance functions that are not well approximated by the reflection function of a plane. An extended algorithm might enhance the isoplane table in these cases by storing a second-order approximation of the reflectance function.</p><p>Finally, we hope to develop a parallel or distributed implementation of the algorithm. The minimal processing in the main rendering loop, mostly table index generation and look-up table access, makes the algorithm comparatively simple to implement in a multiprocessor environment. Its object-order nature also provides for convenient data partitioning without replication across processing nodes. The only communications-intensive step would be compositing sub-images to produce a complete image of the isosurface.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Acknowledgements</head><p>This work was supported by the NSFIAFWA Science and Technology Center for Computer Graphics and Scientific Visualization (ASC-8920219). The first author also received support as an ONR-NDSEG fellow. We gratefully acknowledge the equipment grants from Hewlett-Packard Company and Sun Microsystems, on whose workstations this research was conducted. We also wish to thank those who provided us with volume data: Terry Yo0 of the University of North Carolina at Chapel Hill, William Schroeder of General Electric Company Corporate Research and De- </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>[3] classifies volume rendering algorithms by the intermediate representation they employ.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Geometric change resulting from data quantization. Left: original values and placement of planar approximation of the level 6 isosurface. Right: data quantized to a range of 3 centered on the original isolevel, and resulting shift in isosurface position.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>The quantization may be as simple as clamping values to the range er / 2 . . . e+ r / 2 , or may involve a more complicated scaling of values from a larger range, encompassing both r and e, into the range e-1-12 . . . e + 1-12.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2 :</head><label>2</label><figDesc>Test volume containing a 'spherical' isosurface, rendered using isoplane tables with different values of r. Clockwise from upper left, values for r are 2,4, 6, and 8. lighting definition to the data found there, computing the color of light reflected from the cell's isosurface fragment. To avoid repetitive calculations, we cache this information in the intensity table, indexed by the cell's voxel values.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Projection of a cell onto the image plane. The fraction of the projected area lying within each of the nine pixels is stored in the cell projection table, which is indexed by the sub-pixel location of the projection marker.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>As the first cell's surface fragment is composited onto the target pixel, the pixel becomes partly covered; as the second cell's surface fragment is composited, the previously uncovered part of the pixel becomes completely covered. Let us call the first cell's projection the foreground pixel A and the second cell's projection the backgroundpixel B, and assume that the a value for each is 0.5. Using the Porter-Duff over operator, where FA = 1.0 and FB = l . O -a~, the a value of the composited pixel (A over B) is (FA x ~A ) + ( F B x a~) = (1 .Ox 0.5)+(0.5 x 0.5) = 0.75 .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 :</head><label>4</label><figDesc>The isosurface projected from adjacent cells is not independently distributed within the image pixel.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 :</head><label>5</label><figDesc>Test volume illustrating the potential difference between quantization strategies. Lefr: volume quantized as a whole prior to rendering. Right: volume processed during rendering using cellbased quantization. zation may give a voxel different quantized values depending on the cell being evaluated. To do this as a preprocess would require storing multiple values per voxel, which is prohibitively expensive for large volumes.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>(</head><label></label><figDesc>See color plates, page CP-33.)mation, saving the result as the vector U to be used in computing N' and A'. U is calculated as U = [(NX/SX)&gt; (Ny/Sy)r (Nz/Sz)l.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 6</head><label>6</label><figDesc>shows a CT scan of a turbine blade. The original dataset comprised 300 slices, each of size 5 12 x 5 12, with a 1 x 1 x 2 cell aspect ratio. To obtain cubical cells, we resampled the volume to size 5 12 x 5 12 x 600, using trilinear interpolation. The image shows fine detail and smooth shading.The holes on the leading edge of the blade, the slots along its tail, and the serial number on the base are all clearly visible. The concave surface of the blade is smoothly shaded. The slightly rough texture on the surface of the base results from features in the original data (either noise or actual surface information) that are visible when viewing slices in isolation. The few minor artifacts visible along some flat surfaces are caused by the limited range of normals available due to data quantization. The image took 10 minutes, 9.6 seconds to render.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 7</head><label>7</label><figDesc>shows a human pelvis CT study. The original data contained 56 slices, each of size 256 x 256. To obtain cubical cells we again interpolated intermediate slices, this time using a cubic B-spline. The resulting 256 x 256 x 11 1 volume was rendered in 18.1 seconds. Notice the smooth shading along bone surfaces and the fine detail visible on the spinal column.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>Figure 8</head><label>8</label><figDesc>is an image of an angiography dataset showing vasculature in the pelvic region. The dataset was 80 slices, with 256 x 256 samples each. We resampled the volume to 384 x 384 x 240 for rendering, both to obtain cubical cells and provide a larger volume for testing. The original data</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 6 :</head><label>6</label><figDesc>Industrial CT scan of a turbine blade [volume size: 5 12x 5 12 x 600 -isoplane table range: 81.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head>(Figure 7 :</head><label>7</label><figDesc>See color plates, page CP-33.) CT study of a human pelvis [volume size: 256 x 256 x 11 1 -isoplane table range: 81.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head>Figure 8 :</head><label>8</label><figDesc>Angiography dataset showing pelvic vasculature [volume size: 384 x 384 x 240 -isoplane table range: 81. velopment, and Dr. E. Kent Yucel of Massachusetts General Hospital -Harvard Medical School. Finally, special thanks to Richard Lobb for his encouragement during the writing and his assistance with volume resampling.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head></head><label></label><figDesc>and Van Gelder [ 111 use spa-We adopt the terminology of Wilhelms [IO], referring to individual volume data points as voxels, and to a region of space bounded by a set of voxels (typically eight for regular volumes) as a cell.</figDesc><table /><note>*</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head></head><label></label><figDesc>table whose entries are indexed by eight-tuples of values [VO, . . . , v7] (vi in the range 0 . . . r-1) and associated with a level C' between 0 and r-1. Suppose the vertices of the unit cube are labeled by binary numbers so that, for example, vertex 6 has coordinates [x, y,z] = [ 1,1,0] (as 610 = 1102). Table entry [VO, V I , . . .]</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>table . Table 1 :</head><label>.1</label><figDesc>Doing so requires that we produce just one Isoplane table information for r in the range 2-10. Shown are the number of entries for the uncompressed and compressed forms, and the compression factor for each r value. entry for the equivalence class in generating the table, and that we can identify that entry and appropriately transform the stored data when accessing the table.To identify a canonical element for the equivalence class,</figDesc><table><row><cell>Data</cell><cell>Uncompressed</cell><cell>Compressed</cell><cell>Compression</cell></row><row><cell>range</cell><cell>size</cell><cell>size</cell><cell>factor</cell></row><row><cell>2</cell><cell>256</cell><cell>65</cell><cell>3.94</cell></row><row><cell>4</cell><cell>65,536</cell><cell>5,995</cell><cell>10.93</cell></row><row><cell>6</cell><cell>1,679,916</cell><cell>100,446</cell><cell>16.72</cell></row><row><cell>8</cell><cell>16,777,2 16</cell><cell>193,650</cell><cell>21.14</cell></row><row><cell>I O</cell><cell>100, OOO, OOO</cell><cell>4,076,2 15</cell><cell>24.53</cell></row></table><note>we permute the eight-tuple of cell vertex values [vo, . . . , v7] (using only permutations allowable under rotation and re- flection) so that the value at p~ is the smallest of the eight and the values at p1, p2, and p4 satisfy the relation V I 5 v2 5v4. In generating the table, we limit ourselves to one entry per equivalence class by iterating over values that obey the stated restrictions. Using this scheme, the size of the iso- plane table for a range r isr-1 r-1 r-1 r-1 c c c a=O b=a c=b d=c an eighth-degree polynomial in r. In the limit, as r -+ 00, the size approaches 1/48 3. Table 1 gives size information for representative values of r.</note></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot">[ l l ] Jane Wilhelms and Allen Van Gelder. 11(3):201-227, July 1992. (See color plates, page CP-33.)</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Two algorithms for the three-dimensional reconstruction of tomograms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Ludke</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Crawford</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">C</forename><surname>Teeter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Medical Physics</title>
		<imprint>
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="32" to="327" />
			<date type="published" when="1988-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Hierarchical splatting: A progressive refinement algorithm for volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Laur</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Pat</forename><surname>Hanrahan</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Introduction to Volume Visualization -SIGGRAPH &apos;91 Course Notes</title>
		<imprint>
			<date type="published" when="1991-07" />
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="page" from="285" to="288" />
		</imprint>
	</monogr>
	<note>Computer Graphics (SIGGRAPH &apos;91 Conference Proceedings)</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Marching cubes: A high resolution 3D surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Harvey</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;87 Conference Proceedings)</title>
		<imprint>
			<date type="published" when="1987-07" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="163" to="169" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Fourier volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Malzbender</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="233" to="250" />
			<date type="published" when="1993-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<monogr>
		<title level="m" type="main">Topology from the Direrentiable Viewpoint</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">W</forename><surname>Milnor</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1965" />
			<publisher>The University Press</publisher>
			<pubPlace>Virginia, Charlottesville, VA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Compositing digital images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Thomas</forename><surname>Porter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tom</forename><surname>Duff</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;84 Conference Proceedings)</title>
		<imprint>
			<date type="published" when="1984-07" />
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="page" from="253" to="259" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Decimation of triangle meshes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jonathan</forename><forename type="middle">A</forename><surname>Zarge</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Graphics (SIGGRAPH &apos;92 Conference Proceedings)</title>
		<imprint>
			<date type="published" when="1992-07" />
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="65" to="70" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Frequency domain volume rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Takashi</forename><surname>Totsuka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings: SIGGRAPH &apos;93 Conference</title>
		<meeting>SIGGRAPH &apos;93 Conference</meeting>
		<imprint>
			<publisher>ACM SIGGRAPH</publisher>
			<date type="published" when="1993-08" />
			<biblScope unit="page" from="271" to="278" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">1. Octrees for faster isosurface generation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jane</forename><surname>Wilhelms</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">State of the Art in Volume Visualization -SIGGRAPH &apos;91 Course Notes</title>
		<imprint>
		</imprint>
	</monogr>
	<note>Decisions in volume rendering</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Data structures for soft objects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Geoff</forename><surname>Wyvill</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Craig</forename><surname>Mcpheeters</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Wyvill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="227" to="234" />
			<date type="published" when="1986-04" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
