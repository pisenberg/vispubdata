<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">The Design and Implementation of the Cortex Visualization System</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Deb</forename><surname>Banerjee</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Wayne Smith Fluent Inc. Centerra Resource Park Lebanon</orgName>
								<address>
									<postCode>03766</postCode>
									<region>NH</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Chris</forename><surname>Morley</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Wayne Smith Fluent Inc. Centerra Resource Park Lebanon</orgName>
								<address>
									<postCode>03766</postCode>
									<region>NH</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">The Design and Implementation of the Cortex Visualization System</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Cortex has been designed for interactive analysis and display of simulation data generated by CFD applications based on unstructured-grid solvers. Unlike post-processing visualization environments, Cortex is designed to work in eo-processing mode with the CFD application. This significantly reduces data storage and data movement requirements for visualization and also allows users to interactively steer the application. Further, Cortex supports high-performance by running on massively parallel computers and workstation clusters. A n important goal for Cortex is to provide visualization to a variety of solvers which differ in their solution methodologies and supported flow models. Coupled with the co-processing requirement, this has required the development of a well defined programming interface to the CFD solver that lets the the visualizalion system communicate eficiently with the solver, and requires minimal programming effort for porting to new solvers. Further, the requirement for targeting multiple solvers and application niches demands that the visualization system be rapidly and easily modifiable. Such flexibility is attained in Cortex by using the high-level, interpreted language Scheme for implementing user-interfaces and high-level visualization functions. By making the Scheme interpreter available front the Cortex text interface, the user can also customize and extend the visualization system.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Cortes is a visualization system developed for interactive control and visualization of simulations performed with a variety of unstructured CFD solver codes. Most current visualization systems for CFD are either post-processing systems <ref type="bibr">[l, 61</ref> or dataflow visualization <ref type="bibr">[ 131 systems</ref>. Post-processing systems read in data which the CFD application has written out to disk in a format recognizable by the visualization system. A drawback of this paradigm is that it hinders interactivity. The user cannot conveniently observe the solution as it evolves or modify flowsolution parameters in response to those observations. Dataflow visualizations systems allow co-processing where the CFD application can run as a module in the network. This lets the user observe the flow-field at frequent intervals as the solution evolves. However, the visualization modules in the network may require a copy of the flow-field to perform the visualization. In addition to increasing data storage requirements, such data movement can cause significant network communication when the CFD application runs on a remote compute-server and the rendering modules run on the users local workstation. Additionally, in dataflow systems the flow of data is directed from the application towards the display. Features such as application steering and data probes require data-flow in the reverse directionfrom the user-interface or display to the CFD application. Cortex is a co-processing visualizing system which has a well-defined programming interface to the CFD application. This programming interface was designed to minimize data storage and data movement requirements. This programming interface has been ported to a variety of unstructuredgrid solvers that differ in their solution methodologies and supported flow models. Currently, Cortex is available as the visualization system for the following CFD codes: (1) Rampant[lO] designed for solving transonic compressible flows, (2) Fluent/UNS designed for solving low-speed incompressible flows and (3) Nekton <ref type="bibr" target="#b7">[8]</ref> for very low-speed creeping flows. These solvers have 2D versions based on triangular and quadrilateral cells and 3D versions based on tetrahedral and hexahedral cells.</p><p>Cortex has been designed for providing interactive visualization to a wide variety of solvers and application niches. This requires that the visualization system be able to provide user-interfaces that are customized to the application. In Cortex, both graphical and text interfaces are implemented in the highlevel, interpreted language Scheme. This lets developers and users interactively and rapidly modify the user-interface. Similarly, most high-level visualization functions are also implemented in Scheme on top of low-level functions that are implemented in C. The advantage of using Scheme is that it supports rapid, interactive development lending flexibility to the visualization system. Currently CFD solvers are solving increasingly larger problems. For example, Cortex has been used to visualize a Rampant simulation over a 3D tetrahedral automobile intake cylinder head mesh consisting of 800,000 cells. This has driven the implementation of those codes on massively parallel computers and workstation clusters. In addition to reducing run-times, larger problems can be run only on parallel computers due to larger available memory. Often, these problems cannot even be run on a serial computer. Domain decomposition is a commonly used programming model for parallelizing solversthe flow-domain is partitioned among processors and an instance of the solver is run on each node. A serial visualization system for a parallel CFD solver would require that the entire flowdomain be copied over across the network. It is more efficient if the visualization system, or at least those portions of it that require access to the flow-domain, also be implemented in parallel and run on the same processors as the solver. Cortex has been parallelized on a variety of parallel architectures including Intel IPSC/860, Intel Paragon and on workstation clusters.</p><p>Cortex and the CFD application exist as either a single process, two processes or multiple processes for the parallel version. The Cortex implementation has various forms: (1) a library for a single process application, (2) a visualization process and a client library that links in the CFD application to form the solver process, (3) a visualization process (same as in ( 2 ) ) and multiple instances of client libraries that communicate with the visualization process through a portable communication library for the parallel versions. However, all these implementations are derived from a single set of sources files by using different C preprocessor switches during compilation and linking.</p><p>The rest of the paper is organized as follows. In Section 2, we describe the primary goals that have driven the design of Cortex. The software architecture of Cortex is outlined in Section 3. Among the software modules described in Section 3, the data mapping module is of special interest since it accesses solver data through an API(app1ication programming interface). This module and its integration with the solver is described in Section 4. Further, the data mapping module is that portion of Cortex that runs on massively parallel computers and on workstation clusters. The parallel implementation is described in Section 5. The ability to customize and extend Cortex using Scheme is described in Section 6 and, finally, Cortex is compared to other visualization systems in Section 7.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Design Goals</head><p>The Cortex visualization system has been designed to provide advanced visualization techniques, a modern graphical interface, and a programmable textual interface to a family of unstructured CFD codes which differ in their solution methodologies and supported flow 1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>models. The major design goals of Cortex are:</head><p>Interactivity: User interaction must be supported by a variety of means including direct manipulation of view parameters via a virtual trackball method and interactive modification of color maps. In addition, users should be able to query data values on a displayed object. For example, users can ask for cell coordinates and velocity Values at any point of an iso-surface by simply clicking at that point. Finally, users can interactively steer the simulation by modifying solution parameters of the flow-solver or by adapting the grid.</p><p>Scalability: The visualization system should support CFD applications running on workstation clusters and massively parallel computers. The visualization system should minimize data storage and network communication requirements. It should store only that part of the flowfield that makes up the displayed object which, in general, could be orders of magnitudes smaller than the entire flow-field data. In addition to reducing computation time, an important reason for running simulations in parallel is the large available memory which makes it feasible to run very large problems involving millions of cells. Since the flow-field can not even be stored on a serial computer, the portion of the visualization system that requires access to flow data must also be executed in parallel with the solver.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3.</head><p>4.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>3</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Solver Portability:</head><p>The visualization application should provide user-interfaces and visualization functions to a variety of CFD solvers which are organized around potentially distinct domain data structures and are targeted towards distinct application areas. Integration with new solvers should require minimal additional programming effort. Access from the visualization system to solver data structures should be through clear, well-defined interfaces.</p><p>Flexibility: Since the visualization system is targeted towards multiple solvers and application niches, it should be flexible, i.e., extensible and customizable. For example, implementing application steering requires that solvers provide userinterfaces that allow modification of flow-solution parameters. Both the user-interfaces and flowsolution parameters are solver-specific. The visualization system should allow rapid interactive development and modification of user-interfaces and visualization functions when porting to new solvers.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Software Architecture Overview</head><p>The serial implementation of Cortex has the follow-1. Data Mapping: Data mapping functions including iso-surface extraction, particle tracking, generation of contours and velocity vectors are implemented here. This is the only portion of Cortex that runs as part of the CFD application process. It has has access to the solver through a well-defined API (Application Programming Interface). This module is described in greater detail in Section 4. It is also that portion of Cortex that h w been implemented to run on massively parallel computers and workstation clusters as described in Section 5.  text interface. The Cortex graphical user interface is based on Motif. Routines for implementing various widgets including tables and lists are defined in this module.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Graphics:</head><p>Scheme Interpreter: A Scheme interpreter is available from the Cortex text interface. This local interpreter which runs as part of the visualization process has access to a wide variety of C functions implemented in other Cortex modules.</p><p>Graphical and text interfaces have been implemented as Scheme functions that call Cortex C routines which have been made accessible to the interpreter. Similarly, there is a Scheme interpreter which runs as part of the remote solver process.</p><p>When a serial CFD solver runs under the Cortex visualization system, the resulting application has one of the following structures. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>Single Process: The solver and Cortex runs as a single process. In this case Cortex is implemented as a library that is linked in with the solver.</p><p>Two Process: The solver and Cortex runs as two processes. In this case, the Cortex modules All graphics operations such as rotations, panning, color-map editing etc. are performed in this process thereby providing greater interactivity and frees the compute-server concentrate on running the simulation only. The Cortex data mapping module, is linked with the solver to form the solver process that may possibly run on a remote high-performance compute-server. The solver process communicates with the visualization process through sockets and RPC's. User commands are sent from the user-interface to the solver process via sockets and display data is transmitted from the solver process to the visualization process via RPC's.</p><p>An interesting feature in Cortex is the use of Scheme interpreters in the visualization process and the solver process. C functions in each process can be made accessible to the respective Scheme interpreters. This is done at run-time by registering the C function and its Scheme name with the interpreter. This allows the interpreter to evaluate the scheme function by simply calling the relevant C function. Cortex transforms all user commands from the GUI and text interface into a collection of Scheme function calls. These Scheme functions are either evaluated locally in the Application steering is implemented in Cortex by defining C functions in the CFD application that modify appropriate solution parameters or adapt the grid. Next these C functions are bound to Scheme function names and made available to the solver Scheme interpreter. Finally, the GUI and text user interfaces are implemented for this feature. These user-interface functions are converted into a collection of Scheme fuuction calls by the local Scheme interpreter, Some of these calls will be evaluated remotely in the solver Scheme interpreter by calling relevant C functions. Section 6 provides more details on using Scheme for interactively defining user-interfaces.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Parallel Implementation</head><p>The parallel implementation of Cortex is based on domain decomposition. This model was chosen since this is a commonly used model for parallelizing CFD solvers. In fact, both the CFD solvers, Rampant and Kebrton, have been parallelized(l1, 21 using this model. In this model, the flow domain is partitioned among multiple processors and an instance of the solver is run on each processor or node. In parallel Cortex, the data mapping module is partitioned into a host program and a node program as shown in <ref type="figure" target="#fig_3">Figure 2</ref>.</p><p>The node module is linked in with the solver node program and executes on each processor. The visualization process remains unchanged from the serial implementation since the host makes it appear as zf the data is coming from a serial solver process. Details are provided in Section 5.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Data Mapping in Cortex</head><p>Data mapping[l2] consists of transforming application data into renderable objects. Functionally, this module receives data from the the solver, converts it to desired geometric objects, and transmits the converted data to the rendering engine. For example, during contouring, a 2D triangular cell from the grid is mapped into a 2D triangle with color map indices (based on field values) at each node and is then sent to the renderer for display. The module handles visualization functions such as isc+surfacing, particle tracking, contouring and velocity vector generation. Section4.l describes how this module uses surfaces to minimize network communication. Data mapping requires intensive access to the application's data structures. In traditional post-processing visualization systems, this module loads in the entire grid along with required field-values at each node. In Section 4.2, we show how Cortex reduces its memory overhead by having the data mapping module execute with the solver as part of the same process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Surfaces</head><p>In Cortex, a visualization may be performed by defining portions of the domain that are of interest.</p><p>These portions are represented and stored as surfaces in Cortex. For example, users may create an isosurface of any of the stored or derived solution quantities, or use quadratic functions in x,y,z to define lines, planes or other geometry. They may then observe flow-field variables such as density, pressure and velocity vectors on that surface. Such surfaces are c r e ated, typically, at the beginning of the simulation and the flow-field is observed on it at frequent intervals as the simulation unfolds through time. This makes it useful to store surfaces during creation so that successive displays of flow-field values on it will avoid re-computation of the surface grid. Further, storing such surfaces on the visualization process which executes on the local graphics workstation results in reduction in network traffic. This is because only field-values and not the surface grid needs to be transported from the solver process to the visualization process across the network during, for example, contour and velocityvector displays. Since network data movement can bottleneck distributed visualizations, such techniques are important for enhancing performance.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Data Mapping API</head><p>Cortex has been designed to be integrated with the CFD application and has access to the solver's data structures through a well-defined API. However, it is important that the solver-specific components of the API be as small as possible, thereby minimizing programming effort in porting Cortex to a new solver. Only the data mapping module in Cortex accesses solver functions and data through the API. This is achieved by having the data mapping module share the solver process's address space. The rest of Cortex may run as a separate process as is the case in the two-process and parallel implementations. The data mapping API of Cortex has two components:</p><p>Solver Defined: These functions are provided by the solver. The data mapper uses them to query the solver about data values including cell and node values and coordinates, and cell connectivity. Cortex can handle triangular, quadrilateral, tetrahedral and hexahedral cells. Further, these cells may have sub-cells defined within them. Effort has been made to keep the solver API concise and simple since it has to be implemented separately for each specific solver.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Cortex Defined:</head><p>These functions are exported by Cortex for use directly in CFD applications. <ref type="figure" target="#fig_1">Figure 3</ref> provides some of the API functions.Cortex has been integrated with three separate solvers: (l)Rampant, (2) Nekton and (3) Fluent/UNS. The only additional programming effort for integration was in implementing the solver-defined portion of the data mapping API in each solver.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Parallel Implementation of Cortex</head><p>In this section we describe the implementation of Cortex on massively parallel architectures and workstation clusters. The need for parallelization was driven by the fact that the solver may be running in parallel. Running a parallel solver under serial Cortex requires significant data movement from the solver to Cortex though slow communication networks. Further. Cortex requires large amounts of memory, often not available on serial workstations, to store the resulting data. Our approach was to parallelize the data mapping module which, as described earlier, runs as part of the solver process in the serial environment. A n additional possibility is to parallelize the renderer. Currently, we have not pursued this possibility. It is not clear whether parallel renderers can out-perform workstations with hardware support for rendering. In fact i n <ref type="bibr" target="#b2">[3]</ref>. i t is reported that it would take between 10 and 20 high-end RISC workstations to equal the performance of the SGI VGX graphics system. The data mapping module performs functions that include iso-surface extraction, particle tracking, surface contouring, and generation of velocity vectors. Most visualization functions except particle tracking are embarassingly parallel. Particle tracking is communication intensive since particles frequently migrate across processors.</p><p>Parallel implementations of CFD solvers are usually based on a domain decomposition strategy in which the spatial domain for a problem is partitioned into smaller sub-domains or partitions, and a separate instance of the solver is invoked to simulate the flow within each partition. Information is transferred between neighboring partitions along partition boundaries. Communication is proportional to the perimeter of the partition which is usually an order of magnitude smaller than the size of the partition, and hence does not slow down the simulation. We have parallelized the data mapping module using domain decomposition. A separate instance of the module runs in each processor or node and performs the visualization on its portion of the data. These sub-visualizations are sent to a host instance of the module which combines the sub-instances and sends the data over to the visualization process for display.</p><p>Our parallel implementation of iso-surfacing, based on the marching cubes algorithm <ref type="bibr" target="#b6">[7]</ref>, is similar to that reported in <ref type="bibr">[4]</ref>. Sub-surfaces generated on each node must be communicated to the host which then transfers it to the visualization process. The visualization process is the same as in the serial implementation the host process makes it appear as if there is a serial solver process generating the data. The creation of each local iso-surface does not require any communication since all cells are stored locally. This is achieved by having the solver store cells lying on the boundary of domain partitions on both processors. As described before, representations of surfaces are maintained both in the visualization process and the solver process. The reduces network communication requirements, e.g., when a surface is contoured only the field-values at each point need to be transmitted form the nodes to the host and then onto the visualization process for display.</p><p>We have observed that network communication is usually the slowest component in parallel visualization. In the above example, the iso-surfaces can be generated quite quickly, but they have to be transmitted to the host process, one at a time. Other visualization functions such as particle tracking have even higher communication overhead. In particle tracking the track of a massless particle in the flow-field is generated and displayed. The user specifies the set of points from where the particles are released. Particles keep falling off sub-domains and require to be restarted at a sub-domain stored in a remote partition causing large communication overheads.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Extensibility and Customizability through Scheme</head><p>User-interfaces and high-level visualization functions have been implemented in Scheme in Cortex. Scheme is a high-level interpreted language with features such as dynamic typing, automatic garbage collection and has functions as first class objects. These features make Scheme highly suited for rapid interactive prototyping. User-interfaces and visualization functions can be modified dynamically in the same Cortex session. Such customization is performed not only by developers but also by users. This flexibility is achieved by making a Scheme interpreter available from the text interface. Examples of such Scheme functions are provided in <ref type="figure">Figure 4.</ref> cx-clear-menubar clears the menu bar. menus is a Scheme variable that contains the menu-names with their descriptors. %cx-delet e-menu is implemented in C in the user-interface module. cx-add-item adds a new menu-item. %cx-add-item is defined in C in the user-interface module.</p><p>In Cortex, Scheme is used primarily for two purposes.</p><p>1. User interfaces: All GUI panels, application nieiiubars and callbacks are defined in Scheme in terms of functions implemented in a low-level Motif toolkit in C. CFD application developers and users can add or modify existing interfaces and add new ones interactively without quitting the session. This is particularly important for Cortex since it has been to targeted to a number' of distinct solvers which support different flow-models.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>Modify and define new visualization functions: Visualization functions that have been implemented in Cortex in C are accessible from the Scheme interpreter. Users can define new visualization functions using Scheme with these predefined visualization functions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Comparisons With Other Visualization Systems</head><p>Cortex provides an easy way for CFD developers to integrate advanced, parallel and distributed visualization techniques and modern graphical interfaces into their applications. Different aspects of Cortex such as integration with the CFD application, use of Scheme as an extension language and parallel and distributed execution have been implemented in other visualization systems. To our knowledge, Cortex is the first visualization application that integrates them into a coherent whole and has been implemented on a wide variety of platforms for 3 different CFD solvers.</p><p>General purpose visualization systems such as Fieldview[G], FAST <ref type="bibr">[l]</ref> and PV-WAVE are designed for post-processing which requires the CFD application tp write out one or more files containing the complete results of the simulation. Cortex, however, provides an integrated visualization environment for CFD applications where simulation data is accessed directly from the application through a well-defined interface. The lack of integration implies that the stand alone visualization systems must read in the entire flowfield to process it, and users cannot steer the solution process. The Cortex visualization environment is quite flexibledevelopers and users can rapidly and interactively modify user-interfaces and visualization functions through a high-level interpreted language. The extension language in Cortex is a full-featured, standard high level programming language, rather than an ad-hoc scripting language. Cortex resembles SuperGlue[S] in providing Scheme as an extension language. SuperGlue is designed for post-processing and offers object-oriented extensions to Scheme. Integration of the visualization system with the CFD application has also been implemented successfully in pV3 <ref type="bibr" target="#b2">[3]</ref>.</p><p>There are a number of visualization packages such as AVS[13], Explorer and I&lt;horos[S] which are organized around the data flow model and allow users to interactively create customized visualization systems through a visual programming environment. While Cortex does not provide such an appealing interface to customize the visualizations, it also does not exhibit many of the problems of the data flow approach. There is a single visualization process, rather than the multiple processes common in data flow systems. This  <ref type="figure">! id (%cx-add-item (menu-&gt;id m)</ref> item accel mnemonic callback)) (menu&lt;-item m item id test) id)) <ref type="figure">Figure 4</ref>: Examples of Scheme Functions for User Interfaces reduces the consumption of system resources such as file descriptors and memory. In addition, data-flow visualization system are designed for dataflow in the forward directionfrom application to display. Features such as interactive querying of simulation data values from an image are difficult to implement in such systems. On the other hand, Cortex is directed towards the CFD domain, and is therefore not as general as some existing visualization systems.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>Display and view manipulation routines are implemented in this module. All lowlevel graphics subroutines are implemented by calls to the HOOPS[14] graphics library to provide platform independent graphics. This module receives data from the data mapping module via RPC's. ing software modules as shown in Figure 1.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>3 .</head><label>3</label><figDesc>User Interface: Cortex provides a graphical point-and-click user interface and a command-line 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>( 2 )</head><label>2</label><figDesc>, (3) and (4) make up the visuulimtion process that runs on the user's local work-station.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 1 :</head><label>1</label><figDesc>Software Architecture of Cortex (Two-Process Implementation) visualization process or transmitted to the Scheme interpreter on the solver process via sockets.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 3 :</head><label>3</label><figDesc>The f l o a t SV-Cell-Coordinates PROTO( (CX-Cell-ID c , i n t dim) ) ; void SV-Cell-Values PROTO((CX-Cell-Id c , f l o a t *Val)); f l o a t SV-Node-Value PROTO((CX-Node-Id n ) ) ; void CX-Contour-Poly PROTO((int n p t s , f l o a t *points, f l o a t * v a l s ) ) ; Functions in the Data Mapping Module API separate Cortex process communicates with the data mapping module through sockets and RPC's.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>(</head><label></label><figDesc>define (cx-clear-menubar) (for-each (lambda (m) (Xcx-delete-menu (menu-&gt;id m))) menus) (set! menus J ( ) ) ) (let ((m (if (string? menu) (name-&gt;menu menu) (id-&gt;menu menu))) (define (cx-add-item menu item accel mnemonic test callback) (id # f &gt; &gt; (if (not m) (error "cx-add-item: no such menu." menu)) ( s e t</figDesc></figure>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">FAST: A multiprocessed environment for visualization of computational fluid dynamics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">V</forename><surname>Bancroft</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;90</title>
		<meeting>Visualization &apos;90<address><addrLine>San Francisco, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990-10" />
			<biblScope unit="page" from="14" to="27" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Patera. Parallel spectral element methods for viscous flows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">F</forename><surname>Fischer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Rmquist</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">editor, Parallel Supercomputing: iblethods, Algorithms and Applica-~J O R S</title>
		<editor>G. F. Carey</editor>
		<imprint>
			<publisher>John Wiley</publisher>
			<date type="published" when="1989" />
			<biblScope unit="page" from="223" to="238" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">pV3: A distributed system for large scale unsteady CFD visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Haimes</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
			<publisher>AIAA Paper</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Massively parallel isosurface extraction</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">D</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Hinker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Vasualizafion &apos;92</title>
		<meeting>Vasualizafion &apos;92<address><addrLine>Boston, Mass</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992-10" />
			<biblScope unit="page" from="107" to="114" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">SuperGlue: A programming environment for visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P</forename><surname>Hultquist</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">L</forename><surname>Raible</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;92</title>
		<meeting>Visualization &apos;92<address><addrLine>Boston, Mass</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992-10" />
			<biblScope unit="page" from="243" to="251" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Advanced visualization on desktop workstations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Gi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Al</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Legensky</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Visualization &apos;91</title>
		<meeting>Visualization &apos;91<address><addrLine>San Diego, California</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1991-10" />
			<biblScope unit="page" from="372" to="377" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">A high resolution 3D surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graph-Z&apos;CS</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="163" to="169" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Spectral element methods for the incompressible navierstokes equations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Y</forename><surname>Maday</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">T</forename><surname>Patera</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">State of the Art Surveys on Conzputational Mechanics</title>
		<editor>A. K. Noor and J . T. Oden</editor>
		<imprint>
			<publisher>ASME</publisher>
			<date type="published" when="1989" />
			<biblScope unit="page" from="71" to="143" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A visual language and software development environment for image processing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rasure</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Argiro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Sauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">International Journal of Imaging Systems and Technology</title>
		<imprint>
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">Unstructured grid flow solver applied to trains, planes, and automobiles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Smith</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Spragle</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993" />
			<publisher>AIAA</publisher>
		</imprint>
	</monogr>
	<note>Paper 93-0889</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">An efficient unstructured multigrid solver for MIMD parallel machines</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Tysinger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Smith</surname></persName>
		</author>
		<imprint>
			<publisher>Fluent Inc</publisher>
		</imprint>
	</monogr>
	<note type="report_type">Technical report</note>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Volumetric visualization techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">State of the Art in Computer Graphics, chapter 5</title>
		<editor>D. F. Rogers and R. A. Earnshaw</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1991" />
			<biblScope unit="page" from="313" to="350" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">The application visualization system: A computational environment for scientific visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">HOOPS Graphics System: Reference Manual, Verison 3.1. Ithaca Software</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Wiegand</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Covey</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1001" />
			<pubPlace>Marina Village Parkway, Alameda, CA 94501</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
