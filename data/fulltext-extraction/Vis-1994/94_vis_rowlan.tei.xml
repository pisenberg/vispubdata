<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A distributed, parallel, interactive volume rendering package</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">S</forename><surname>Rowlaii</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Mathematics Computer Science Division Argontie National Laboratory Argonne</orgName>
								<address>
									<postCode>60439</postCode>
									<region>IL</region>
								</address>
							</affiliation>
						</author>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">Edward</forename><surname>Lent</surname></persName>
							<email>lent@mcs.an1.gov</email>
							<affiliation key="aff0">
								<orgName type="laboratory">Mathematics Computer Science Division Argontie National Laboratory Argonne</orgName>
								<address>
									<postCode>60439</postCode>
									<region>IL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Nihar</forename><surname>Gokhale</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Mathematics Computer Science Division Argontie National Laboratory Argonne</orgName>
								<address>
									<postCode>60439</postCode>
									<region>IL</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sbaiinon</forename><surname>Bradshaw</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Mathematics Computer Science Division Argontie National Laboratory Argonne</orgName>
								<address>
									<postCode>60439</postCode>
									<region>IL</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A distributed, parallel, interactive volume rendering package</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:31+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>Scientific Visualization</term>
					<term>Distributed Algorithms</term>
					<term>Volume Rendering</term>
					<term>Massively Parallel Procwsing</term>
				</keywords>
			</textClass>
			<abstract>
				<p>This paper presents a parallel ray-casting voluirie rendering algorithiri and its iinpleirientation on the iiiassively parallel I B M SP-1 coinpuler using the C&apos;hairieleon iriessage passing library. Though this algorithm takes advantage of inany of the unique features of the SP-1 (e.g. high-speed switch, large irieiiiory p e r node, high-speed disk array, HIPPI display, et al), the use of Chameleon allows the code to be executed on any collection of workstations. The algorithiri is image-ordered and distributes the d a t a and the coiriputational load to individual processors. After the voluirie data is distributed, all processors then perforiri local raytracing of their respective .subvoluiries concurrently. N o interprocess coininunication takes place during the ray tracing process. After a subiiriage is generated by each processor, the final image is obtained by coiriposing subiiriages between all the processors. The prograiri itself is iiripleiriented as an interactive process through a GlJI residing on a graphics workstation which is coupled t o the parallel rendering algorithm via sockets. The paper highlights the Chaineleon iiripleirientation, the GUI, some optimization iiriproveirients, static load balancing, and direct parallel display t o a HIPPI frairiebuffer.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Though direct volume rendering is computeintensive, it is recognized as being a powerful tool for visualizing complex internal structures within scalar and vector datasets defined on three-dimensional grids.</p><p>This paper presents an interactive, parallel, raycasting volume rendering algorithm which uses an image-ordered subdivision of work. In addition to riirining over various types of workstations, the program is implemented on the distributed memory parallel computer, the IBM SP-1. The code takes advantage of many of the unique features of this machine such as, the high-speed switch, large disk array, HIPPI framebuffer, and large memory per node.</p><p>To be useful, a volume rendering program must provide high quality data representation, be usable on large datasets (greater than 500-cubed values, for instance), allow interactive spatial manipulation, and fast rendering. It must also allow the user to change parameters, such as color and opacity, and see results immediately and execute on a multitude of workstations and parallel computers. The volume rendering software discussed in this paper offers these characterist ics.</p><p>With 128 Megabytes of memory on eac.h node of the SP-1, and using 128 nodes, we are able to use the volume renderer on volumes as large as l000xl000xl000 floating point values. lJsing single-byte values increases this to 1100-c.ubed. These values also reflect the storage of a floating point gradient grid in meniory as well as the sc.alar values within the volume data set. Imminent memory improvements to the machine should significantly improve this to over 2000-cubed.</p><p>Our renderer is front-ended by a GL-based graphical user interface (CUI) proc,ess that runs on a remote graphics workstation. This allows the results of the renderer to be viewed at any workstation that can run X-windows or GL, and also provides an easy-touse GlJ1 to change rendering parameters and spatial interaction.</p><p>Accessing the HIPPI framebuffer in parallel provides a fast display device.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">TheIBM SP-1</head><p>The IBM SP-1 is a distributed-memory, message passing parallel computer.</p><p>The Argonne SF'-1 consists of 128 nodes and a compile server. Each node is essentially an RS/6000 model 370. The nodes are housed in 16-node clusters, which each fourth node having a Fiber Channel Switch connection. Key features of this system are: The peak performance of each node is 125 MFlops (1 64-bit floating-point add and 1 floating-point multiply in each clock cycle). In practice, each node can achieve between lfj'and 70 MFlops on Fortran code.</p><p>Higher performance can be reached by using the BLAS or ESSL routines.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Parallel Volume Rendering Algorithm</head><p>The ray-casting algorithm conducts an imageordered traversal of the image plane pixels. At each pixel a ray is shot into the data volume. ( h e r a l l y only one ray per pixel is necessary (assuming the image sample density is greater than the volume data sample density), and a sample usually occu~s at a rate from one to two samples per voxel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>-</head><p>At each sample point on the ray the color and opacity are determined by using a trilinear interpolation from the data values at each of the nearest voxels. A lookup table (often called an opacity map) is provided to determine the color and opacity returned from the interpolated data value. In our algorithm, we use the normalized gradient of the data volume as a surface normal for shading calculations.</p><p>The sampling continues until the summed opacity has become greater than or equal to one, or the ray has exited the volume. The final pixel value is determined by summing, front to back, the colors and opacities sampled along the way. A detailed description of this process can be found in Hansen and Painter <ref type="bibr" target="#b1">[2]</ref>. Descriptions of the ray-casting method can be found in <ref type="bibr" target="#b4">[5]</ref> and <ref type="bibr" target="#b5">[6]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Data Distribution/Load Balancing</head><p>The algorithm we use is a divide-and-conquer type which requires the partitioning of volume data into subvolumes which are then sent to each processor for rendering. The subvolumes are required to produce an unambiguous front-to-back ordering of their respective subimages to establish the required order for compositing subimages.</p><p>In an ideal case, each processor would be given an appropriate amount of data such that they each perform the same amount of work. There are many methods to perform load balancing to try and achieve this. One of the most interesting is the worker-farm paradigm outlined in Corrie and Mackerras <ref type="bibr" target="#b3">[4]</ref> which breaks the volume data into small sections and farms them out to processors that are not busy. In this case there are significantly less nodes than subvolumes. &lt; A simpler method of load balanc.ing is to subdivide the entire volume into n nodes where n is the number of proc.essors. In this case each node gets l/nth the data.</p><p>If the view point is known and an orthonormal raycasting projection is used then the data can be subdi-vided in a way that would eliminate the need for image compositing. This would reduce the cost of merging the subimages which can, as will be seen later, represent a significant part of the calculation. (:ompositing cannot be avoided in algorithms that use perspective projection or rotational/translational animation, however, as this requires a complete rerendering of the volume data.</p><p>Since our program allows the user to change the orientation of the volume interactively, and we are using Hansen and Painter's <ref type="bibr" target="#b1">[2]</ref> compositing method, we subdivide the volume data using a k-D tree structure <ref type="bibr" target="#b6">[7]</ref> with alternating binary subdivision of the coordinate planes at each level in the tree. Note, we use a different method of data subdivision when using spherical datasets (See Section 10.0)</p><p>Though not a true load-balancing routine, we find this method works well on most data volumes. Good load balancing occurs when interesting data (sometimes defined as where the gradients undergo the most change) is evenly distributed throughout the data volume. Conversely, poor load balancing occurs when interesting data is concentrated into a small section of the overall data. As reported in <ref type="table">Table 1</ref>, we routinely find a load imbalance of a factor of two (some processors do r i p t o tjwice the work of some others).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Static Load Balancing improvment</head><p>Since the volume renderer is often used to repeatedly analyze an existing dataset, it seemed reasonable to consider using a load-balancing scheme that performed some dataset analysis prior to rendering. We developed a pre-computation filter that. when applied to on-line datasets, generates a map file which the volume-renderer uses instead of the st&lt;andard K-d tree.</p><p>This pre-filter loads a data set and its corresponding map file and samples each data point. The program applies the K-d tree subdivision but adjusts the placement of the cutting planes according to the accnmmnlated opacities within each section. Small opacities receive more weight because we assume that voxels with small opacities would generally require more sampling than those with large opacities.</p><p>Whenever we reused a dataset we would apply the In general, pre-filter program and compare results.</p><p>we saw about a twenty percent improvement in the load-balancing with this adjustment of the K-d tree algorithm. Another good method for static load balancing is found in <ref type="bibr">[ l]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Using the Chameleon message passing library</head><p>Message passing is a common method for writing programs for distributed memory parallel computers. IJnfortunately, the lack of a standard for messagepassing has hampered the c.onstruction of portable and efficient parallel programs. In an attempt to remedy this problem, a number of groups have developed their own message-passing systems, each with its own strengths and weaknesses. Chameleon is a secondgeneration such system <ref type="bibr">[lo]</ref>. Rather than replacing these existing systems, Chameleon is meant to supplement them. (.:hameleon's goals are to (a) be very lightweight (low overhead), (b) be highly portable, antl (c) help standardize program startup and the use of emerging message passing operations such as collective operations on subsets of processors.</p><p>(:hameleon is tracking the MPI (Message €'assing Interface) draft standard and will provide both an MPI implementation and an MPI transport layer. ( :hameleon provides support for heterogeneous coniputing by using p4 and PVM. (:hameleon's support for homogeneous computing includes the portable libraries p4, PI(:L, and PVM, and vendor-specific irnplementations for IBM SY1, Intel NX and Thinking Machines (:MMD ((!M-.5).</p><p>(:hameleon is portable, simple to install antl iise, and efficient. It is not difficult to port and is installed on most new parallel processor systems as they become available. (:hameleon is available on t,he Sun, DEC, Silicon (iraphics, and IBM RS6000 workstations, IBM SP1, HBN T(:-2000, Int(e1 iF'S(:/X60, Delta, and Paragon.</p><p>We use the ( :hameleon call Plbcastsrc() to initially distribute the data to the processors. After sending the specified data to all the processors, each processor then picks out the data that it is responsible for. This method is somewhat inefficient in that the entire volume dataset is sent while only a portion of it is actually used. However, as can be seen in <ref type="table">Table 1</ref>, the setup time increases only slightly with an increase in number of processors.</p><p>For interprocess communication and compositing we use the PIbsend() and PIbrecv() calls. These calls send data to or receive data from a specific processor. On the SP-1 they communicate over the high-speed Omega switch. The sending node packs half of it's subimage image into a large packet and sends it to it's partner to composite. It's partner composites the new data with half of it's image and also packs and sends the other half of the subimage to back to it's partner. On the SP 1 these are point-to-point communications and network collisions do not occur.</p><p>To collect the subimages we use a modified version of PIgcolx(). This function is used to collect and assemble the final image. It's algorithm is binary-tree based and is O(log2(n)) where n is the number of processors.</p><p>Portability is the main reason we use Chameleon for message passing. To run on a different architecture or use a different library one only needs to recompile. For development of our volume renderer we used networks of Suns, IBMs, SGIs, and the SP-1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Optimization</head><p>We explored four methods for improving performance from the basic code, which was based on the Hansen and Painter model. The first method was to perform the ray casting on some fraction of pixels, interpolating the color value of the non-ray-traced pixels from its neighbors. The second method was to improve the bounding box calculation to insure that samples along a ray were taken from within the data volume. The third was to incorporate a variable samplestep size, and the forth was to explore the feasibility of applying seperate processors to the render and compositing functions. <ref type="bibr">'</ref> </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Interpolation</head><p>For many images produced by the volume renderer, we noticed that, except at opaque object boundries, the change from one pixel to a neighboring pixel was often quite small. Therefore, we implemented an interpolation scheme that performed ray-casting on every second pixel within the image plane row and column. The pixels that were not ray-traced were colored by performing a linear interpolation between the pixels that were.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>;</head><p>In practice, we found that interpolated images and non-interpolated images could rarely be told apart. Of course, interpolation produces a slight blurring between discrete opaque object boundaries and the background. This blurring, however, was difficult to notice and actually often acted as an antialiasing feature.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Speedups achieved by interpolating averaged about</head><p>3.85 times as fast as the non-interpolated times. Since only one forth of the pixels are ray-traced, we expect a speedup of 4;OO as optimum for this feature.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Improved bounding box</head><p>Image-ordered volume rendering algorithms generally perform their ray-casting in screen-space coordinates. This means that the data volume, or subvolume in the parallel case, must be transformed to screen space before the ray-tracing can occur.</p><p>The standard image-ordered volume rendering algorithm creates a bounding box about the transformed subvolume that has a face parallel to the image plane. The bounding box is also oriented with the edges of this face either orthogonal or parallel to the x and yaxis of the image plane. The result is a cube within screen space that can be easily traversed by screen coordinates. When the data volume is oriented at any angle to the screen, this bounding box method produces samples along rays that lie outside of, or rays that completely miss the data volume, as can be seen in figure 1.</p><p>We attempted to improve this method by performing a simple intersection calculation between the ray and data volume, see figure 2. We call this method a confoniiing bounding box. The conforming bounding box conforms to the data volume exactly, eliminating the extra space contained in the traditional bounding box. We do this by creating six planes that define the faces of the data volume.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>' .</head><p>We use the maximum and minimum array indices along each axis to create data points for each corner of the data volume "box." These points are then transformed into screen space. Three points on each face Light <ref type="figure">Figure 1</ref>: Standard bounding box are used to calculate the normal and define the boundaries of the plane. A ray is shot into this collection of six planes. For each plane, a ray hit-time is calculated along with whether or not the ray is entering or exiting. The greatest entry time is used for the new ray start and the least exit time is used for the new ray end.</p><p>The benefit of this method is that, instead of starting at the bounding box, which can be several steps away from the data, we start exactly at the data boundary and also end when we leave the data. If we find that our ray completely misses the data, we can immediately exit that ray traversal. Speedups achieved by our improved bounding box method averaged about 1.20 times as fast as when using the standard bounding box method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Variable sample step size</head><p>An adaptive ray sampling algorithm looks at data more closely when it is more interesting and less when it is not. The number of samples per unit of data has a large effect on renderered image quality. If too few samples are taken, then the image looks like a paring knife has been used upon it, see Color Plate 1. If a large number of samples are used then the increase in render time is almost linear; doubling the sample rate There are several possible ways to define interesting data such as material opacity or a high rate of change between two samples. In our algorithm, if a sample is not in the color-opacity map or it is totally transparent then we take a larger step. [Jnfortuneately, because of the variable nature of volume data and other variables, this improvement is difficult to quantify. However, we found that incorporating this feature generally improved rendering times by a few percentage points.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Overlapping the Render and Composite functions</head><p>The advantage of Hansen and Painter's compositing algorithm [t2] is that, during the compositing stage, all nodes are participating throughout the entire composite process. To further improve the performance of the compositing function, we assigned specific processors to the task of compositing. This effectively overlaps the two functidns and can significantly improve total rendering speed. We call this mode of the algorithm vector mode since the process resembles that of arithmetic functions of a vectorizing CPU.</p><p>From previous timings we noticed that as the number of processors increased, the time-per-node spent in rendering decreased while the time-per-node spent in compositing stayed roughly the same. Therefore, as the number of processors increased and the rendering function became more efficient, the time spent in compositing became more significant. The data set used for these results was the now classic IJNC Chapel Hill MR head a t a size of 128x 128x 128. In <ref type="table">Table 1</ref>, we summarize CPU times for each function. As the image size increases, the rendering time linearly increases. Composite times tend to be similar irregardless of number of processors. If the rendering and compositing functions were both of comparable time, than using n/2 processors for rendering and n/2 processors for compositing could be overlapped to out-perform the standard n-processor algorithm, see <ref type="figure" target="#fig_2">Figure 3</ref>. <ref type="table" target="#tab_1">Table 2</ref> shows the results of our first test. In this case we used an equal number of processors for the render and composite functions. The results clearly show that using n/2 render nodes and n/2 compositing nodes outperforms the use of n/2 nodes in the standard algorithm. They do not, however, outperform the use of using n-nodes in the standard algorithm. This is simply because the composite function does not require the same magnitude of time as does the render function. But the results do convince us that allocating a small number of processors to the task of compositing should improve the overall render times for a multiple-image run.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Performance</head><p>The most significant portion of time is spent during the set-up process. This is primarily due to the time it takes the nodes to read the entire volume dataset from disk and extract their respective subset. Our parallel data input feature (see next section) avoids this bottleneck for run-time simulations. Accessing the data from the high-speed disk array should improve this time significantly.</p><p>Note that the improved bounding box method and image interpolation are used in these timings. Setup time represents the time to send volume data to all the nodes and establish internodal communication. After setup, an initial image was created followed by nineteen rotational translations. Render, composite, image collect and display timings are the average of these twenty images.     ulations that produce data the volume renderer is intended to visualize (such as global climate modeling, strudural biology, and superconductor modeling), are done on massively parallel supercomputers. These simulations are usually time-dependent and often generate megabyte-sized (or larger) datasets at each time step. A typical program execution might require the generation of many hundreds or even thousands of timesteps to produce a meaningful animation. The result can be many terabytes of data.</p><p>Traditionally such data is often stored on disk to be visualized and reviewed on a graphics workstation at a later date. With data of this size, however, storing the data on disk may not be practical. Therefore we have extended our vplume renderer to accept data in parallel from ongoing computational simulations. This is done in one of two ways:</p><p>1. The "single-node-collect version" The parallel simulation collects the data on one node and sends it to the root node of the volume renderer who then disperses it.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2.</head><p>The "parallel-collect" Each node has a connection to a simulation node.</p><p>The single-node-collect version uses a subset of our run-time data collection tool called PORTAL <ref type="bibr" target="#b2">[3]</ref>.</p><p>PORTAL is a library that allows data distributed asynchronously across a distributed memory machine to be easily sent from any collection of processors, and be collected and collated on a receiving machine. ,for use in visualization.</p><p>In the parallel-collect version, each simuiation node sends it's data to a specific volume rendering node when a simulation timestep is completed. The data subvolume is then rendered. Therefore, the entire process of simulation, computation, and image production is done in parallel. On the SP-1; the image itself can then be sent in parallel to the HIPPI framebuffer for display, further eliminating the serial bottleneck.</p><p>Currently this function is limited in that the number of rendering nodes must equal the number of nodes doing the computational simulation. Though this enhancement does not effect overall rendering speeds, it significantly reduces the setup times for reading in each new dataset fed into the renderer, as well as saving disk space. Generally setup time is significantly longer than time to render and composite one image. Parallelizing the data input with n processors decreases setup time by l/n.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Image Artifacting</head><p>During the early stages of development of this algorithm, we often produced images that displayed a banding artifact similar to Mach bands <ref type="bibr" target="#b7">[8]</ref>. The effect was most pronounced in curved surfaces.</p><p>The banding effect was controllable by decreasing the sample size increment along the rays cast into the data volume. Color Plate 1.0 shows the banding effect with the sample increment equal to 0.2, 1.0, 2.0 and finally 4.0 voxel units. As can be seen from the figures, a ray increment of less than one produced the best results. As expected however, an increment value of 0.2 increased the rendering by almost a factor of five. For non-opaque surfaces, any decrease in increment size requires a similar decrease in color map opacity values, or the extra sampling would create an opacity of one too quickly.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>, 8 Distributed Interactive Front-End GUI</head><p>One of the significant features of this code is its interactivity. The user can move the volume around, adjust colors and opacities, and receive immediate feedback. This is done by using a graphical user interfac.e (GrJI) built on the FORMS GUI library <ref type="bibr" target="#b8">[9]</ref> for data input, the Silicon Graphics G L library to display a bounding box and read trackball movements, and IJnix socket connections to communicate with and drive the volume renderer on the SP-1.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Outputting the image to the HIPPI framebuffer</head><p>At the end of the compositing stage, each processor has a subimage that must be sent to an X-window for display. This is usually done by collecting subimages on a single node prior to display.</p><p>IJtilizing a high-speed HIPPI channel on the SP-1 and a HIPPI framebuffer, we have implemented a HIPPI-display library for sending and receiving images in parallel. The volume renderer offers the option of displaying to this device. Because of the extremely fast data transfer rate of the HIPPI channel, animation rates of 10-15 frames per second are possible for high resolution (1280x1024) images.</p><p>Our experience has been that writing an image of this size to an X-window over a typical Ethernet network will generate about one frame per second at best. Therefore, when the volume renderer is rendering multiple frames per second, it is best to use the HIPPI framebuffer.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="10">Spherical and Rectilinear Volume datasets</head><p>The standard algorithm is designed to operate in uniform, rectilinear datasets. To accommodate data generated from global climate modeling applications, we have extended the volume renderer's data capability to inc.lude spherkal datasets.</p><p>Various sections of the code that are different for spherical datasets include: a new data volume subdivision using spherical wedges rather than alternating binary subdivision of the coordinate planes, different bounding box routines, and a slightly different interpolation routine.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="11">Conclusions</head><p>We have produced a practic.al volume visualization tool that is easy to use, provides interactivity and immediate feedback, and is portable to networks of workstations or almost any parallel computer through the use of the Chameleon message passing library. The algorithm is particularly effective when taking advantage of the unique features of the SP-1 architecture; the 128 Megabytes of memory per node, coupled with 128 nodes of the SP-1, allow rendering of data volumes in excess of 1000-cubed.</p><p>Currently the code is being heavily used for modeling the results of a molecular dynamics project.</p><p>SPlVREN source libraries, detailed documentation, and working examples can be obtained by anonymous ftp from info.mcs.anl.gov from the file volren.tar.Z from the directory pub/volren.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="12">Future Directions</head><p>We are currently incorporating variable extent planes into the front-end G U I to increase rendering speed and allow more controlled exploration of the volume data set. For a more detailed view of voxels with specific densities and connectivities, we are also incorporating a feature to allow the user to select a particular voxel and have the renderer image only closely connected voxels of similar density.</p><p>The scientists using the renderer to model molecular dynamics are interested in coupling volumerendered results of field data with geometric models of molecular structure. We are exploring methods for easily coupling the two disparate images types.</p><p>Improvements to the SP-1 version of the renderer will include use of Unitree and the high-speed disk array to significantly reduce the amount of time spent in reading the volume data.</p><p>With our current configuration of the SP-1 we are limited to datasets of size about' 1000-cubed values. To generate normals, the algorithm calculates gradients on the volume data and generates three arrays of floats, eac.h the size of the original volume data. This gradient information takes up much of the memory. By storing gradient and volume data as .chars we should be able to increase the dataset size to about 2000-cubed.</p><p>As stated in the section on optimization, we believe that allocating a small number of processors to the compositing function will significantly improve perforniance during multi-image generation where the render and composite functions can be overlapped. We will continue to experiment with this improvement.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>0 128 00</head><label>128</label><figDesc>MBytes of memory per node 0 1 (:;Byte local disk on each node (400 MBytes available to users, rest for paging) Full IJnix on each node (IBM AIX 3.2.4) Each node accessible by Ethernet from the Internet 0 High-performance Omega switch (50 usec latency, 8.5 MBytes/sec bandwidth when using EUI-H). 0 A large high-performance file system (220 (:;Bytes of RAID disk and a 6-TByte automated tape library).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Improved bounding box doubles the time needed for rendering.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 3 :</head><label>3</label><figDesc>Hypothetical 10-image run, where overlapping the render and composite functions out-performs the standard algorithm.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 4 :</head><label>4</label><figDesc>Speedups of the Render function</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 5 :</head><label>5</label><figDesc>Parallel Data Input to the Volume Renderer</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>' 6 Parallel Data Input</head><label></label><figDesc></figDesc><table><row><cell></cell><cell></cell><cell></cell><cell>max</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell></cell><cell></cell><cell></cell><cell>render</cell><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell></row><row><cell cols="10">512x512 E 1 2 4 8 16 32 64 Table 1: Standard algorithm on IBM SP-1. (128-cubed volume size, no load balancing) 50.456 27.624 17.802 10.149 6.967 3.788 2.715 0.514 0.536 0.655 0.668 0.692 0.744 0.625 0.679 0.586 0.636 0.539 0.549 30.551 19.834 11.510 7.854 4.818 3.581</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell>min</cell><cell>max</cell><cell></cell><cell>image</cell><cell>X</cell><cell>Loop</cell></row><row><cell>size 512x512 j 1 ; ;</cell><cell>(.:PUS setup 1 na 3 2 9.77 179.64 187.20 176.14 167.95 167.65</cell><cell cols="2">render render na na</cell><cell cols="4">composite composite collect na na na 0.134 0.134 0.039 0.623 0.644 0.082 0.708 0.720 0.102 0.728 0.781 0.14 0.632 0.701 0.18 0.614 0.656 0.205</cell><cell>display na 0.008 0.010 0.007 0.011 0.006 0.010</cell><cell>Total na 5 1.256 29.118 18.001 10.262 7.088 3.87</cell></row><row><cell cols="2">J function</cell><cell>1</cell><cell>2</cell><cell>4</cell><cell>8</cell><cell>16</cell><cell>32</cell><cell>64</cell><cell>128</cell></row><row><cell cols="2">Interpolation</cell><cell cols="8">3.932 3.867 3.774 3.855 3.754 3.876 3.965 3.876</cell></row><row><cell cols="3">(:onforming bounding box 1.21</cell><cell>1.20</cell><cell>1.20</cell><cell>1.20</cell><cell>1.21</cell><cell>1.22</cell><cell>1.20</cell><cell>1.20</cell></row><row><cell></cell><cell></cell><cell></cell><cell></cell><cell></cell><cell cols="5">Many of the large-scale computational science sim-</cell></row></table><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 2 :</head><label>2</label><figDesc>Vector Mode algorithm on IBM SP-1. (128-cubed volume size, no load balancing) 0 Total Processors 1 rendering time I render speedup I time per image I per image speedup U</figDesc><table /><note></note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 3 :</head><label>3</label><figDesc>Processor Speedups for Rendering a 512x512 Image. (128-cubed volume size)</figDesc><table /><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was supported be the Office of Scientific Computing, 1J.S. Department of Energy, under Contract W-31-109-Eng-38.</p><p>We would like to thank Chuck Hansen and Mike Krogh of Los Alamos National Laboratory, and Jamie Painter of the IJniversity of IJtah. Without their help and their initial code, we would still be trying to light oiir first pixel.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Proceedings of the 1994 Scalable High-Performance Computing Conference in Knoxville</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Karia</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="252" to="258" />
		</imprint>
	</monogr>
	<note>Load Balancing of Parallel Volume Rendering with Sc,attered Decomposition</note>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">A Data Distributed, Parallel Algorithm for Ray-Traced Volume.,.Rendering</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">[i</forename><surname>Hansen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Painter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Kwan-Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Parallel Rendering Symposium</title>
		<meeting>the Parallel Rendering Symposium<address><addrLine>San Jose, Ca</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993" />
			<biblScope unit="page" from="15" to="22" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">PORTAL: A communication library for run-time visualization of distributed, asynchronous data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Rowlan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">T</forename><surname>Wightman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 1994 Scalable High-Performance Computing Conference in</title>
		<meeting>the 1994 Scalable High-Performance Computing Conference in<address><addrLine>Knoxville</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Parallel Volume Rendering and Data Coherence on the Fujitsu AP 1000</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Corrie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Mackerras</surname></persName>
		</author>
		<idno>TR- CS-92-11</idno>
	</analytic>
	<monogr>
		<title level="m">The Australian National IJniversity</title>
		<imprint>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Display of Surfaces from Volume Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="29" to="37" />
			<date type="published" when="1988-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Volume Rendering, A Hybrid Ray Tracer for Rendering Polygon and Volume Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="33" to="40" />
			<date type="published" when="1990-03" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Multidimensional Binary Search Trees IJsed for Associative Searching</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bentley</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Communications of the ACM</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">8</biblScope>
			<biblScope unit="page" from="509" to="517" />
			<date type="published" when="1975-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<monogr>
		<title level="m" type="main">Mach Bands: Quantitative studies on neural networks in the retina</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">F</forename><surname>Ratcliff</surname></persName>
		</author>
		<imprint>
			<publisher>Holden-Day</publisher>
			<pubPlace>San Francisco</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">Forms Library: A graphical user interface toolkit for Silicon Graphics workstations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">H</forename><surname>Overmars</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992-11" />
			<pubPlace>Netherlands</pubPlace>
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, .Utrecht . IJniversity</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<monogr>
		<title level="m" type="main">IJsers Manual for the Chameleon Parallel Programming Tools</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">D</forename><surname>Gropp</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Smith</surname></persName>
		</author>
		<idno>ANL-93/23</idno>
		<imprint>
			<date type="published" when="1993" />
			<pubPlace>Argonne National Laboratory</pubPlace>
		</imprint>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Volume Visualization Tutorial</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Kreuger</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1993-11-19" />
			<biblScope unit="page" from="26" to="27" />
		</imprint>
	</monogr>
	<note>Supercomputer 93 conference</note>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
