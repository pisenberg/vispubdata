<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Strata-Various:* Multi-Layer Visualization of Dynamics in Software System Behavior</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Doug</forename><surname>Kimelman</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM Thomas J. Watson Research Center Yorktown Heights</orgName>
								<address>
									<postCode>10598</postCode>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Bryan</forename><surname>Rosenburg</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM Thomas J. Watson Research Center Yorktown Heights</orgName>
								<address>
									<postCode>10598</postCode>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Tova</forename><surname>Roth</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">IBM Thomas J. Watson Research Center Yorktown Heights</orgName>
								<address>
									<postCode>10598</postCode>
									<region>NY</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Strata-Various:* Multi-Layer Visualization of Dynamics in Software System Behavior</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>Current software visualization tools are inadequate f o r understanding, debugging, and tuning realistically complez applications. These tools often present only static structure, OT they present dynamics f r o m only a f e w of the m a n y layers of a program and its underlying system. T h i s paper introduces uPV&quot;, a prototype program visualization s y s t e m which provides concurrent visual presentation of behavior f r o m all layers, including: the program itself, user-level libraries, the operating system, and the hardware, as this behavior unfolds over time. PV juztaposes views f r o m d i e r e n t layers in order t o facilitate visual correlation, and allows these views t o be navigated in a coordinated fashion. T h i s results in a n extremely powerful mechanism f o r ezplohng application behavior. Ezperience i s presented f r o m actual use of PV in production settings with programmers facing real deadlines and serious performance problems.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Visualization of Software Behavior</head><p>To truly understand any realistically complex piece of software, for purposes of debugging or tuning, one must consider its execution-time behavior, not just its static structure. Actual behavior is often far different from expectations, and often results in poor performance and incorrect results. Further , the ultimate correctness and performance of an application (or lack thereof) arises not only from the behavior of the program itself, but also from activity carried out on its behalf by underlying system layers. These layers include user-level libraries, the operating system, and the hardware. Finally, problems often become apparent only when one considers the interleaving of various kinds of activity, rather than cumulative activity summaries at the end of a run. Thus, for debugging and tuning applications in a realistically complex environment , one must consider behavior at numerous layers of a system concurrently, as this behavior unfolds over time.</p><p>Clearly, any textual presentation of this amount of information would be overwhelming. A visual presentation of the information is far more likely to be meaningful. Information is assimilated far more rapidly when it is presented in a visual fashion, and trends and anomalies are recognized much more redily. Further, animations, and views which incorporate time as an explicit dimension, reveal the interplay among components over time.</p><p>With an appropriate visual presentation of information concerning software behavior over time, one can first survey a program execution broadly using a large-scale (high-level, coarse-resolution) view, then narrow the focus as regions of interest are identified, and descend into finer-grained (more detailed) views, until a point is identified for which full detail should be considered.</p><p>Further, displays which juxtapose views from different system layers in order to facilitate visual correlation, and which allow these views to be navigated in a coordinated fashion, constitute an extremely powerful mechanism for exploring application behavior.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">PV -A Program Visualization System</head><p>PV, a prototype program visualization system developed at IBM Research, embodies all of the visualization capabilities proposed above. Success with PV in production settings and complex large-scale environments has verified that these capabilities are indeed highly effective for understanding application behavior for purposes of debugging and tuning.</p><p>Users often turn to program visualization when performance is disappointingeither performance does not match predictions, or it deteriorates as changes are introduced into the system, or it does not scale up (and perhaps even worsens!) as processors are added in a multiprocessor system, or it is simply insufficient for the intended application. With PV, users watch for trends, anomalies, and interesting correlations, in order to track down pressing problems. Behavioral phenomena which one might never have suspected, or thought to pursue, are often dramatically revealed. A user continually replays the execution history, and rearranges the display to discard unnecessary information or to incorporate more of the relevant information. In this way, users examine and analyze execution at successively greater levels of detail, to isolate flaws in an application. Resolution of the problems thus discovered often leads to significant improvements in the performance of an application.</p><p>PV shows hardware-level performance information (such as instruction execution rates, cache utilization, processor element utilization, delays due to branches and interlocks) if it is available, operating-system-level activity (such as context switches, address-space activity, system calls and interrupts, kernel performance statistics) , communication-library-level activity (such as message-passing, inter-processor communication), ianguage-runtime activity (such as parallel-loop scheduling, dynamic memory allocation), and applicationlevel-activity (such as algorithm phase transitions, execution time profiles, data structure accesses).</p><p>PV has been targeted to shared-memory parallel machines (the RP3 <ref type="bibr" target="#b6">[7]</ref>), distributed memory machines (transputer clusters running Express), workstation clusters (RISC System/6000 workstations running Express), and superscalar uniprocessor workstations (RISC System/6000 with AIX).</p><p>PV is structured as an extensible system, with a framework and a number of plug-in components which perform analysis and display of event data generated by a running system. It includes a base set of components, and users are encouraged to add their own and configure them into networks with existing components. Novice users simply call up pre-established configurations of components in order to use established views of program behavior.</p><p>Figures 1 through 6 show some of the many views provided by PV. Section 4 describes some of these views in detail and discusses their use.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">AIX Trace</head><p>PV is trace-driven. It produces its displays by continually updating views of program behavior as it reads through a trace containing an execution history. A trace consists of a time-ordered sequence of event records, each describing an individual occurrence of some event of interest in the execution of the program. Typically, a n event record consists of an event type identifier, a timestamp, and some event-specific data. Events of interest might include: sampling of a cache miss counter, a page fault, scheduling of a process, allocation of a memory region, receipt of a message, or completion of some step of an algorithm. A trace can be delivered to the visualization system live (possibly over a network), as the event records are being generated, or it can be saved in a file for later analysis.</p><p>The standard AIX system (IBM's version of UNIX), as distributed for RS/6000s, includes an embedded trace facility. AIX Trace <ref type="bibr" target="#b5">[6]</ref>, a service provided by the operating system kernel, accepts event records generated a t any level within the system and collects them into a central buffer. As the event buffer becomes full, blocks of event records are dumped t o a trace file, or dumped through a pipe to a process, e.g. for transmission over a network. Alternatively, the system can be configured to simply maintain a large circular buffer of event records that must be explicitly emptied by a user process.</p><p>Comprehensive instrumentation within AIX itself provides information about activity within the kernel, and a system call is provided by which user processes can provide event records concerning activity within libraries or the application. On machines incorporating hardware performance monitors, a device driver can unload hardware performance data, periodically or at specific points during the execution of an application, and generate AIX event records containing the data,</p><p>The variant of PV that is targeted to AIX workstations is based on AIX Trace. Unless otherwise noted, all of the applications discussed in this paper were run on AIX RS/SOOO workstations with AIX Trace enabled. Traces were taken during a run of the application and saved in files for later analysis.</p><p>For the applications discussed here, tracing overhead was negligibleless than 5% in most cases. In no case was perturbation great enough to alter the behavior being investigated. Trace file sizes in all cases (See color plates, page CP-19.)</p><p>were less than 16 megabytes.</p><p>4 Views in Action -Experience with</p><formula xml:id="formula_0">P V</formula><p>This section describes some of the many views provided by PV, and explains their use, by way of examples of actual experience with PV.</p><p>PV has been applied to a number of different types of application across a number of domains, including: interactive graphics applications written in C++, systems programs such as compilers written in C, computation-intensive scientific applications written in Fortran, I/O-intensive applications written in C, and a large, complex, heavily-layered, distributed a p plication written in Ada.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Views of Process Scheduling and System Activity</head><p>In one example, the developers of "G", an interactive graphics application,l were concerned that it was taking 12 seconds from the time that the user entered the command to start the application, until the time that the main application window would respond to user input. They suspected that a lot of time was being lost in the Motif libraries.</p><p>End-of-run summaries showed that 5 1 seconds out of a 97 second run were spent idle, but these summaries provided no indication of how many of these idle seconds were in fact warranted, perhaps waiting for user input, and how many were somehow on the critical path for the application. Profiles of time spent in various functions, and perusal of thousands of lines of detail in textual reports, would not have been help ful.</p><p>PV views showing process scheduling alongside operating system activity immediately highlighted the nature of this performance problem. The scheduling view consists of a strip of color growing to the right over time, with color used to indicate which process was running at any instant in time. <ref type="figure">(Figure 2</ref> shows this view in a window titled "AixProcess I Colorstrip".) The activity view consists of a similar strip of color, in which color is used to indicate what activity was taking place a t any instant in time. <ref type="figure">(Figure 2</ref> shows this view in a window titled "AixSystemState 1</p><p>ColorStrip".) The two views can show the same time spans, and they can be aligned so that a point in one view corresponds to the same instant in time as the point immediately above or below it in the other view. Further, the two views aligned in this way can be navigated in a coordinated fashionwhen the user 500ms in on either view, expanding a region of interest in order to reveal greater detail, the other view expands the same region of time automatically.' (PV provides a number of other views which can be aligned and navigated in the same fashion, including views showing kernel performance statistics, hardware performance statistics, which loop of a function is currently active, or which user-defined phase of an algorithm is currently being executed.)</p><p>By viewing behavior as it unfolded over time, it was apparent that the two processes of application "G" (shown in <ref type="figure">Figure 2</ref> as light pink and salmon color) were not even running for much of the 12 seconds that they should have been rushing to establish the main application window Further, it wasn't even the X server process (light green) that was running instead of them. In fact the system was idle (dark purple) much of the time. Thus, 5 of the 51 idle seconds noted above were occurring during startup and hence were on the critical path. Finding the point on the scheduling view where a process of application "G" went idle, zooming in to show greater detail, and dropping down to the activity view, revealed the cause of the idle time: system calls to examine a number of files were causing large delays. Having narrowed the focus to a very small window in time using the graphic views, a view was opened showing the detailed textual trace report. As each event is displayed graphically in other views, this view highlights the corresponding line in the report. With this level of detail it was immediately obvious that startup information had inadvertently been scattered across a number of files which might well be remote-mounted and thereby incur significant access penalties.</p><p>Without the visual correlation facilitated by juxtaposition of views and coordinated navigation, it would have been much harder to make the connection between the various aspects of this performance problem. At the very least, it would have taken much longer by any less direct means.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Views of Memory Activity and Application Progress</head><p>In another example, PV views revealed a number of memory-related problems in "A" , a compiler. Each view in this case is rectangular, with each position along the horizontal axis corresponding to some region of a linear address space (the size of the region depends on scale of the display). In one view, color is used to represent the size of a block of memory on the user heap. ( <ref type="figure">Figure 5</ref> shows this view in the upper window titled "AixMalloc 1 OneSpace".) In another view, color is used to show the source file name or line number that allocated the block. ( <ref type="figure">Figure 5</ref> shows this view in the lower window titled "AixMalloc I One-Space".) In a third view, color is used to represent the state of a page of the data segment of the user address space. ( <ref type="figure">Figure 5</ref> shows this view in the window titled "AixDataSeg I OneSpace" .) For purposes of correlation, the views are configured to show the same range of addresses, and they are aligned so that a given address occurs at the same horizontal position in each view. As well, zooming in on a region in one view automatically causes the corresponding zoom operation in the other view.</p><p>Each of these views in <ref type="figure">Figure 5</ref> is split into an upper half and a lower half, each representing part of the data segment of the address space of compiler "A". The left edge of the upper half represents address 0x24200000; successive points to the right along this half represent successively higher addresses; and the right edge represents address 0x24600000. Thus, the upper half of these views represent 2MB of the data segment. Similarly, the lower half of these views represents an expanded view of the 248KB from Ox244CAE35 to Ox2448E571. The black guidelines show where the region represented by the lower half of a view fits into the region represented by the upper half.</p><p>These views showed a number of wastes of memory, none of which could technically be classed a "leak".</p><p>Rather, they were "balloons"still referred to, but largely full of empty space. In one case, the heap views showed that every second page of the heap was not being made available to the end user (shown in <ref type="figure">Figure   5</ref> "AixMalloc I OneSpace" as alternating green and white blocks in the lower half of the view), yet the corresponding positions on the data segment view showed clearly that every page was being faulted in (shown in the lower half of <ref type="figure">Figure 5</ref> "AixDataSeg 1 OneSpace" as all magenta). The heap views also showed that all of the blocks in question were of the same size. Having identified blocks of a particular size as being problematic, the source code for the allocator was quickly inspected, with particular attention to the treatment of blocks of the problematic size. It rapidly became apparent that, in certain situations, half of the heap was being left empty due to an unfortunate interaction between user code, the heap memory allocator, and the virtual memory system.</p><p>In another case, a static array was declared to be enormous. This was felt to be acceptable because real memory pages were never faulted in unless they were required for the size of the program being compiled. However, the data segment view emphasized that the array did occupy address space, and this became noteworthy when the compiler could not be loaded on smaller machine configurations, even though only moderate-sized programs needed to be compiled.</p><p>Finally, late in the run of this compiler, pages began flashing in and out of the data segment view. Glancing at the system activity view (described earlier), during the time that the page flashing was occurring, allowed this behavior to be correlated to periods of excessive disclaiming and subsequent reclaiming of pages by the compiler.</p><p>An application phase view, which provides a roadmap to the progress of an application, allowed this thrashing in the address space to be attributed directly to the offending phase of the compiler. The application phase view consists of a number of strips of color, as in the process scheduling and system activity views described earlier, ( <ref type="figure">Figure 5</ref> shows this view in the window titled "AixPhase I ColorStrip".) The strips are stacked one on top of the other, and they grow to the right together over time. The color of the top strip shows which user-defined phase of the application is in progress at any instant in time. The color of successively lower strips shows successively deeper sub-phases nested within the phases shown at the corresponding positions on the higher strips. (This view can be driven by instrumentation in the form of simple event generation statements inserted manually or automatically into the source, or by procedure entry and exit events generated using object code insertion techniques.)</p><p>In the case of compiler "A", correlation in time between the application phase view and the data segment view immediately made it clear that a backend code generation phase (shown in <ref type="figure">Figure 5</ref> as light green) was responsible for the excessive paging activity.</p><p>In another example, these memory-related views did in fact reveal a number of actual memory leaks in "F", a large Ada application. Due to the visual nature of these views, it was immediately apparent that particular leaks were flooding the address space (which was bleeding full of the color of the allocators in question) and hence required immediate attention. It was (See color plates, page  just as apparent that other leaks were inconsequential and could be ignored until after a rapidly approaching deadline. This is something which would not be readily apparent from the textual report of conventional special-purpose memory leak detectors.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Views of Hardware Activity and Source Progress</head><p>Finally, in an example involving "T", a computation-intensive scientific application, a view showing which loop of a program was active over time, in conjunction with a view of hardware performance statistics over time, highlighted opportunities for significant improvements in performance.</p><p>The program loop view is simply the application phase view described earlier, with color used to indicate which program loop is active at any instant in time (rather than which arbitrary user-defined phase is active). ( <ref type="figure">Figure 6</ref> shows this view in the window titled "AixPhase I ColorStrip".) The hardware performance view consists of a stack of linegraphs growing to the right over time. <ref type="figure">(Figure 6</ref> shows this view in the window titled "RS2Pmc 1 Scale I LineGraph".)</p><p>Hardware-level information, as discussed in Sections 2 and 3, is sampled a t loop boundaries and plotted on the various graphs. In this case, the two views showed the same time span and were aligned for purposes of correlation and navigation.</p><p>These views allowed programmers to easily identify the longer-running loops and to correlate execution of a particular loop with a dramatic decrease in MFLOPS. The hardware view showed that the loop was not cache-limited and was not a fixed point loop, yet one floating point unit was seldom busy, while the other was extremely busy but completing very few instructions. To understand the behavior of this particular loop, a number of additional views were opened to show the program source.</p><p>Each source view highlights a line of source at the beginning of the major loop currently being executed. One of the views is, in effect, a "very high altitude' view of the source (as in <ref type="bibr" target="#b1">[2]</ref>), in which the entire source of the program fits within the single window. Although the code is illegible due to the "very small font", the overall structure of the program is apparent, and the overall progress of the application can be tracked easily. The code in the second view of the source is legible, but the view can only show a page of source a t a time and must be scrolled in order to view different parts of the program. For application "T", glancing at the source views confirmed that, for the loop in question, a divide instruction was in fact causing one floating point unit to remain fully busy while not completing very many instructions. The assembly view showed that the reason for the second floating point unit not even keeping busy was an unnecessary dependence in the code. Using these views for feedback, the programmer was able to experiment rapidly with manual source transformations, and ultimately to achieve a 12% improvement in the performance of application "T".</p><p>Overall, through experience with PV in these situations and many others, the visualization capabilities proposed above have proven tremendously effective for debugging and tuning, often in cases where traditional methods have failed.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Future Research</head><p>The user interface is bound to be a severe limitation of any current software visualization system. Typical displays of software are crude approximations, a t best, to the elaborate mental images that most programmers have of the software systems they are developing. Opening, closing, and aligning windows on a relatively small 2-dimensional screen is a cumbersome means of manipulating a few small windows onto an elaborate conceptual world.</p><p>With the advent of sufficiently powerful virtual reality technology, a far more effective facility for software visualization could be achieved by m a p ping multiple-layer software systems onto expansive 3dimensional terrains, and providing more direct means for traversal. Traversal could involve high-level passes over the terrain to obtain an overview, and descent to lower-levels over regions of interest for more detailed views. The system could also provide the ability to maintain a number of distinct perspectives onto the terrain. The panorama could include both representations of the software entities themselves, as well as derived information such as performance measurements, and more abstract representations of the entities and the progress of their computation. first appeared in the literature more than ten years ago <ref type="bibr" target="#b3">[4]</ref>. Much of the initial work in program visualization, and many recent efforts, are concerned solely with the static structure of a program. They do not consider dynamics of program behavior at all. Algorithm animation work [l] <ref type="bibr" target="#b16">[17]</ref> has focused strictly on small algorithms, rather than on actual behavior of large applications or on all of the layers of large underlying systems. Further, algorithm animations often require large amounts of time to construct (days, weeks or even months). This is acceptable in a teaching environment, where the animations will be used repeatedly on successive generations of students, but is unacceptable in a production software develop ment environment where it is critical that a tool can be applied readily to problems as they arise.</p><p>Recently, there has been much work in the area of program visualization for parallel systems <ref type="bibr" target="#b8">[9]</ref> This work has in fact been concerned with dynamics, but much of it has been confined to communication or other aspects of parallelism. Little consideration has been given to displaying other aspects of system behavior. PIE <ref type="bibr">[ll]</ref> shows system-level activity over time, but its displays are limited primarily to context switching. Other system-level activity and activity from the application and other levels of the system are not displayed simultaneously for correlation. The IPS-2 performance measurement system for parallel and distributed programs [5] [14] does integrate both application and system based metrics. However, system metrics are dealt with strictly in the form of "external time histograms", each describing the value of a single performance metric over time, as opposed to more general event data. Thus, where non-application data are concerned, IPS-2 is limited to strictly numeric presentations, such as tables and linegraphs. Dynamic animated displays of behavior, such as those showing system activity over time, or memory state as it evolves, are not possible with IPS-2. Program hierarchy displays are used primarily only for showing the overall structure of an application, or for specifying the program components for which performance measurements are to be presented. Some vendors provide general facilities for tracing the system requests made by a given process. However, these facilities tend to apply to a single process rather than the system as a whole, and hence are not useful for showing the interaction between a process and its surrounding environment. Furthermore, these facilities tend to have very high overheads.</p><p>Profiling tools, such as the UNIX utilities "prof" and "gprof", have existed for some time, but these utilities simply show cumulative execution time, a t the end of B run, on a function by function basis.</p><p>A number of workstation vendors have recently extended basic profiling facilities or debuggers by adding views to show time consumption and other resource utilization graphically. Many of these tools now report utilization with granularity as fine as a source line, and many allow sampling during experiments which can cover some part of a run rather than just an entire run. None of these tools, however, supports the notion of general visual inspection of continuous behavior and system dynamics a t multiple levels within a system. Some debuggers are now including views of behavior in the memory arena, but none of these tools provides the power and generality of PV.</p><p>The power of PV, and its novelty, lie in its combination of a number of important properties. PV provides both quantitative and animated displays, and it presents information from multiple layers of a program and its underlying system. Further, PV facilitates correlation and coordinated navigation of the information displayed in its various views. Finally, PV presents views which address important concerns for software behavior on mainstream workstation systems, not just clusters or parallel machines. PV embodies all of these capabilities and it provides effective industrial-strength support of large-scale applications (even hundreds of megabytes of address space and hundreds of thousands of lines of code).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Conclusion</head><p>In production settings, over a wide range of complex applications, PV has proven invaluable in uncovering the nature and causes of program failures. Developers facing serious performance problems and imminent deadlines have found it worthwhile to invest time to connect PV to their application, and to run and inspect visualization displays.</p><p>Experience with PV indicates that concurrent visual presentation of behavior from many layers, including the program itself, user-level libraries, the o p erating system, and the hardware, as this behavior unfolds over time, is essential for understanding, debugging, and tuning realistically complex applications. Systems that facilitate visual correlation of such information, and that provide coordinated navigation of multi-layer displays, constitute an extremely powerful mechanism for exploring application behavior.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>'"</head><label></label><figDesc>The stories you are about to hear are true. Only the names have been changed to protect the innocent." 'Complete detail concerning the contents of these views can be found in a lengthy technical report [a]. (See color plates, page CP-19.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>(These two source views are shown side by side at the left of Figure 6, beneath the PV control panel.) The third view shows the assembly language source, as generated by the compiler, with the same form of highlighting as the other two source views. (In figure 6, this view is hidden behind the other windows.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>(</head><label></label><figDesc>See color plates, page CP-19.) 6 Related Work The notion of program visualization per se [15] [18]</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>Heartfelt thanks to Keith Shields, Barbara Walters, and Christina Meyerson for hard work in the trenches, and to Fran Allen and Emily Plachy for unwavering support.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Exploring Algorithms Using Balsa-11</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Brown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page">1436</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Seesoft-A Tool For Visualizing Line Oriented Software Statistics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">G</forename><surname>Eick</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Steffen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">E</forename><surname>Sumner</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jr</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Software Engineering</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">11</biblScope>
			<biblScope unit="page" from="957" to="968" />
			<date type="published" when="1992-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Visualizing the Performance of Parallel Programs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">T</forename><surname>Heath</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">A</forename><surname>Etheridge</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="29" to="39" />
			<date type="published" when="1991-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">An Integrated Environment for Program Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">F</forename><surname>Herot</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">P</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">T</forename><surname>Carling</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Friedell</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Kramlich</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Baecker</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Automated Tools for Information Systems Design</title>
		<editor>H.-J. Schneider and A. J. Wasserman eds.</editor>
		<imprint>
			<publisher>North-Holland Publishing Company</publisher>
			<date type="published" when="1982" />
			<biblScope unit="page" from="237" to="259" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">The Integration of Application and System Based Metrics in a Parallel Program Performance Tool</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">K</forename><surname>Hollingsworth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">B</forename><surname>Irvin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Third Symposium on Principles and Practice of Parallel Programming</title>
		<meeting>Third Symposium on Principles and Practice of Parallel Programming</meeting>
		<imprint>
			<date type="published" when="1991-07" />
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="189" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">AIX Version 3.1 for RISC System/6000 Performance Monitoring and Tuning Guide</title>
	</analytic>
	<monogr>
		<title level="m">IBM Corporation, order number</title>
		<imprint>
			<biblScope unit="page" from="23" to="2365" />
		</imprint>
	</monogr>
	<note>IBM Corporation</note>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">The RP3 Program Visualization Environment</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">N</forename><surname>Kimelman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Ngo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The IBM Journal of Research and Development</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">6</biblScope>
			<date type="published" when="1991-11" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Program Visualization for Implementation Performance Analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">N</forename><surname>Kimelman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">S</forename><surname>Rosenburg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IBM Research Technical Report, October</title>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">The Visualization of Parallel Systems: An Overview</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Kraemer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Stasko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Parallel and Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="105" to="117" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Analyzing Parallel Program Execution Using Multiple Views</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">J</forename><surname>Leblanc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">M</forename><surname>Mellor-Crummey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">J</forename><surname>Fowler</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Parallel and Distributed Computing</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="203" to="217" />
			<date type="published" when="1990-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Visualizing Performance Debugging</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Lehr</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Segall</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">F</forename><surname>Vrsalovic</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Caplan</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">L</forename><surname>Chung</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">E</forename><surname>Fineman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="page" from="38" to="51" />
			<date type="published" when="1989-10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">Traceview: A Trace Visualization Tool</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename><surname>Malony</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">H</forename><surname>Hammerslag</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">J</forename><surname>Jablonowski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Software</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="19" to="28" />
			<date type="published" when="1991-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Visualizing Parallel Computer System Performance</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">D</forename><surname>Malony</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Reed</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Center for Supercomputing Research and Development</title>
		<imprint>
			<date type="published" when="1988-05" />
			<biblScope unit="volume">812</biblScope>
		</imprint>
		<respStmt>
			<orgName>University of Illinois at Urbana-Champaign</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">IPS-2: The Second Generation of a Parallel Program Measurement System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">P</forename><surname>Miller</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Clark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Hollingsworth</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kierstead</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Lim</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Torzewski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Transactions on Parallel and Distributed Systems</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="206" to="217" />
			<date type="published" when="1990-04" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">A Principled Taxonomy of Software Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">A</forename><surname>Price</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">M</forename><surname>Baecker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">I</forename><forename type="middle">S</forename><surname>Small</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Visual Languages and Computing</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="211" to="266" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Scalable Performance Environments for Parallel Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Reed</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">R</forename><surname>Olson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Aydt</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">M</forename><surname>Madhyastha</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Birkett</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">W</forename><surname>Jensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">A A</forename><surname>Nazief</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">K</forename><surname>Totty</surname></persName>
		</author>
		<idno>UIUCDCS-R-9 1-1673</idno>
		<imprint>
			<date type="published" when="1991-03" />
		</imprint>
		<respStmt>
			<orgName>University of Illinois</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">TANGO: A Framework and System for Algorithm Animation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Stasko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer</title>
		<imprint>
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="issue">9</biblScope>
			<biblScope unit="page" from="27" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Understanding and Characterizing Software Visualization Systems</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Stasko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Patterson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. 1992 IEEE Workshop on Visual Languages</title>
		<meeting>1992 IEEE Workshop on Visual Languages</meeting>
		<imprint>
			<date type="published" when="1992-09" />
			<biblScope unit="page" from="3" to="10" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
