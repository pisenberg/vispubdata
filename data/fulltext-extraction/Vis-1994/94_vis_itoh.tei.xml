<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Isosurface Generation by Using Extrema Graphs</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Takayuki</forename><surname>Itoh</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Tokyo Research Laboratory</orgName>
								<address>
									<country>IBM Japan</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Koji</forename><surname>Koyamada</surname></persName>
							<affiliation key="aff0">
								<orgName type="laboratory">Tokyo Research Laboratory</orgName>
								<address>
									<country>IBM Japan</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Isosurface Generation by Using Extrema Graphs</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>A high-performance algorithm for generating isosurfaces is presented. In this algorithm, extrema points in a scalarfield are first extracted. A graph is then generated in which the extrema points are taken as nodes. Each arc of the graph has a list of IDS of the cells that are intersected by the arc. A boundarg cell list ordered according to cells&apos; values is also generated. The graph and the list generated in this pre-process are used as a guide in searching for seed cells. Isosurfaces are generated f m m seed cells that are found in ams of the graph. In this process isosurfaces appear to propagate themselves. The algorithm visits only cells that are intersected by an isosurface and cells whose IDS are included in cell lists. It 4s especially eficient when many isosurfaces are interactively generated in a huge volume. Some benchmark tests described in this paper show the eficiency of the algorithm.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Three-dimensional numerical simulations have become popular due to t h e increased computing power available in engineering and scientific applications. Three-dimensional measurement h a s also become widely used, as a result of new technologies in the medical field. Volume visualization has consequently become more important, because it allows users to understand the results of these simulations and measurements. So that the results can be understood easily through interactive operations, various methods for representing spatial numerical data are implemented in visualization tools. Isosurfaces are expected to be one of the most effective media for representing scalar fields.</p><p>An isosurface is defined as a set of points that satisfy the following equation: S(z, y, 2 ) -c = 0, the distribution of the scalar field, because of the long time taken to generate a surface from a huge volume of data. Interactive operation (e.g. through a probing</p><p>interface <ref type="bibr" target="#b2">[3]</ref>) may also be difficult because of the high cost. In some tools, geometric data on the generated surfaces are held in storage for prompt repetition of the continuous display. However, these tools require a large amount of storage for huge volumes of data, and therefore some tools may refuse to handle such data.</p><p>Various efficient algorithms that eliminate nonintersected cells have been proposed. These algorithms are particularly effective for huge volumes. Some efficient algorithms generate cell lists ordered by cell's values as a pre-process <ref type="bibr">[4,</ref> 51. These algorithms have been also applied to isosurfaces. However, the number of cells to be visited is regarded as O(n) in their algorithms. Other such algorithm has been proposed by Speray and Kennon <ref type="bibr" target="#b5">[6]</ref>. Their algorithm eliminate all non-intersected cells outside the process. However, their algorithm has been applied only to slice surfaces. Moreover, some intersected cells may not be visited in case of non-convex volumes.</p><p>2 Related work</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Triangulation algorithm</head><p>Suppose that the scalar values S(z, y, z ) are assigned a t each grid-point, and that the scalar field inside a cell is linear. Intersections between an isosurface and the edges of a cell are found by extracting edges for which the signs of the difference between the given scalar value and S(z,y,z) at their two ends are different. Several triangles are formed inside the cell by connecting these intersections. An isosurface is approximated as a set of triangles by the above process for all cells [l, 21 (see <ref type="figure">Figure 1</ref>).</p><p>where S(z, y, z ) is a spatial function such as temperature or pressure, and C is a constant value.</p><p>An isosurface is usually approximated as a set of triangle facets <ref type="bibr">[l,</ref> 21. It is displayed as a set of edges of triangles, or as a set of drawn triangles.</p><p>In conventional straightforward methods, the cost of generating an isosurface is estimated at O(n) when al! cells are visited in order to search for intersections with the surface. These methods may be wastely for huge volumes, since the number of intersected cells is regarded as O(n2I3). Here, n means the number of cells. The high cost may even prevent understanding of In the method proposed by Doi and Koide <ref type="bibr" target="#b1">[2]</ref>, a unique vertex identifier process is also proposed. This process avoids duplication of vertices, and thus reduces the required storage capacity and the cost of calculating vertex data.</p><p>Generally, cells that are intersected by an isosurface are only a part of a volume. These straightforward triagulation algorithms involve wasteful processes for visiting non-intersected cells.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">High-performance triangulation algorit hms</head><p>Recently, some efficient algorithms that eliminate nonintersected cells have been reported. <ref type="bibr">Giles</ref>  Their algorithms may be costly for huge volumes. Speray and Kennon have reported a propagation algorithm for generating slice surfaces <ref type="bibr" target="#b5">[6]</ref>. Their algorithm does not require any heavy pre-processes. On the other hand, it uses cell adjacency to propagate itself through the faces of cells. It requires a data structure in which the IDS of adjacent cells can be specified from each cell. For an unstructured volume, a data structure that has the IDS of adjacent cells for each cell <ref type="bibr" target="#b6">[7]</ref> is required. The a1 orithm requires manual operations to specify seed tils, and is therefore not useful for visualization tools that continuously display surfaces without any manual specification.</p><p>However, it has a great advantage in efficiency, since it eliminates all non-intersected cells outside the pro-cess. It is very useful with an intuitive interface that helps to specify the position or scalar value [3].</p><p>Speray and Kennon did not use their algorithm for generating isosurfaces. We guess that this is because isosurfaces have a higher possibility of separa.tion. Their algorithm requires many manual specifications if the surface is separated into several parts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Algorithm</head><p>The method proposed in this section is an expansion of Speray and Kennon's propagation algorit,hm. Their efficient algorithm for generating slice surfaces is used to generate isosurfaces without any manrial specification of seed cells.</p><p>Our algorithm is shown in <ref type="figure">Figure 5</ref>. Our algorithm is based on the following rule: Rule: Any given closed isosurface is intersected by at least one arc of a graph in which all extrema points are connected by arcs. (unless there is no interiovpoint in each uvea, OT the scalar field is flat in each area). Any given open isosurface is intersected by at least one boundary cell.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Extracting extrema points</head><p>The extrema points are held in the structure shown in <ref type="figure" target="#fig_3">Figure 6</ref> . To extract extrema points, t,he scalar values of all grid-points for each cell are compared. All grid-points except the maximum-valued grid-points are marked as "Not maximum." Similarly, all grid-points except the minimum-valued are marked as "Not minimum." Intermediate valued grid-points are marked as both. After values in all cells have been compared, only gridpoints that have either a "Not maximum" or "Not minimum" mark are extracted as extrema points.</p><p>The algorithm for extracting extrema points is shown in <ref type="figure">Figure 7</ref>. To generate an arc, an extrema point is first chosen as a "start" point. The other extrema point is then chosen as a ''goal'' point. Here, we assume that the group of arcs that minimize the total cost of a graph is generated when closer extrema points are connected by In this paper, extrema points are defined as grid-points whose scalar values are maximum or minimum in all cells that share them. One of the closer extrema points is selected as a "goal" point, and the vector of the arc between the start point and the goal point is then calculated. Starting from a cell that includes the start point, the arc is traversed and the adjacent cell that is intersected by the arc is then visited. This process is repeated until it arrives at the cell that includes the goal point. Here, the maximum and minimum values are updated by the scalar value of each grid-point during visits to cells. The IDS of the visited cells are iperted into the cell list of the traversed arc. If the line goes outside the volume, the traverse is terminated and a similar traverse is started after selection of the next-closest extrema point as a "goal" point (see <ref type="figure" target="#fig_6">Figure 9</ref>).  <ref type="figure" target="#fig_7">Figure 10</ref>). This distance-based process necessarily connects t h e chosen extrema points, but it is not always efficient, because of the cost of calculating the distance for each gridpoint. Therefore it should be the second process after traversal of straight arcs. The flag that has the lar er value is substituted with the smaller value. In ad&amp;ion, flags of other extrema points that have the larger value are substituted with the smaller value. When the start point is chosen, an extrema point whose flag has a n equal value to the flag of the start point is not chosen as a goal point (see <ref type="figure">Figure 11</ref>). </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>E l</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.3">Generating boundary cell lists</head><p>In this paper, boundary cells are defined as a group of cells that have faces not connected to a n adjacent cell. Next, seed cells are searched for by traversing arcs of the extrema graphs. The specified value and the maximum and minimum values of each arc are compared. If the specified value lies between the maximum and minimum values of an arc, all the cells in the list are visited in order.</p><p>When an extracted seed cell is unmarked, its ID is put into the FIFO queue and an isosurface is then generated (see <ref type="figure" target="#fig_2">Figure 15)</ref>.</p><p>This process is shown in <ref type="figure" target="#fig_3">Figure 16</ref>. Here, the function Propagatesurface0 is shown in <ref type="figure">Figure 4</ref>.</p><p>Here. the number of intersected cells is regarded ated by using minimum and maximium values zf the as o(n2j3). The number of cells in arcs of e&amp;ema cells based on a quick-sort algorithm. These lists have graphs is regarded as 0 (~i / 3 ) . The number of cells in pointers to each boundary cell data. cell lists is regarded as O(n2/3). Therefore, Here we analyze our algorithm and the straightforward algorithm [a] by comparing their performance. In benchmark tests, a series of 20 isosurfaces were generated for each volume. T h e results for example unstructured volumes are as follows. The size of the volumes are shown in <ref type="table" target="#tab_1">Table 1</ref>.  The above results show that the simple process for extracting extrema points is much more costly than other processes, since its cost is estimated as O(n).</p><p>The cost Tpc of dataset No.4 is much higher that those of other datasets. We suppose that this result is due to the cost for selecting close extrema points, since its cost is estimated as O(n2). If the scalar value is noisy and there are enoumous extrema points, the cost Tpc may be much higher than that of dataset No.4. </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :Figure 2 :</head><label>12</label><figDesc>Triangulation A set of triangular facets is held in the structure shown in Figure 2. typedef s t r u c t SURFACE { i n t numT; /*Number of Triangles */ TRIANGLE t g l n ; /* Triangle Data */ i n t n u d ; /* Number of Vertices */ VERTEX vtx[]; /* Vertex Data */ } SURFACE; typedef s t r u c t TRIANGLE { } TRIANGLE; typedef s t r u c t VERTEX { i n t vID[S]; /* VerteaIDs */ f l o a t posC31; /* PositionData(x,y,z) */ f l o a t nalC31 ; /* NormalVectorData(x,y,z) */ } VERTEX; Structure of a surface</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 3 :Figure 4 :</head><label>34</label><figDesc>PropagationAn edge of a triangle exists on the faces of a cell that have both lower-valued grid-points and highervalued grid-points. The adjacent cell that shares the face is obviously intersected by the slice surface. In Speray and Kennon's algorithm, the IDS of adjacent intersected cells are put into a FIFO queue. IDS are then dequeued and the cells are then visited in that order. A set of triangles is efficiently generated by repeating this process until the FIFO queue is empty. This algorithm visits only intersected cells (seeFigure Thepropagation algorithm is shown inFigure 4.3 ) -void PropagateSurface(int s e e d c e l l I D , f l o a t C ) { Enqueue the seedcellID; while( t h e queue is not empty ) { dequeue a c e l l I D ; Hake t r i a n g l e s i n the dequeued c e l l ; Enqueue the c e l l I D s of Hark the enqueued c e l l s ; unmarked adjacent i n t e r s e c t e d c e l l Propagation algorithm</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>1 Figure 5 :</head><label>15</label><figDesc>void main(){ /* Begtn Pre-process */ ExtractExtrena() ; GenerateGraphO ; GenerateBoundListO; /* End Pre-process */ /* Begtn Main-process */ while( 1 ) { Specify the s c a l a r value C ; GenerateSurface(C); /* End Muan-process */ 1 Outline of o u r algorithm Here, the function ExtractExtrema(), Generate-Graph(), GenerateBoundList(), and MainProcess() are shown inFigures 7, 12, 14, and 16.As a preprocess, extrema points in a scalar field are extracted, and then connected by a graph whose arcs have a cell list that contains the IDS of cells intersected by the graph. At the same time, a boundary cell list ordered according to scalar value is generated. Seed cells can be found in the cell list of arcs or boundary cell list, without any manual specification. Isosurfaces propagate themselves, starting from the seed cells.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 6 :</head><label>6</label><figDesc>extrm[] ; /* grid-pozntID of the extrema p o i n t */ /*flag f o r checking i t s connectzvity */ /* N u m b e r of e x t r f m a points */ /* Extrema poznt d a t a */ } EXTRR-LST; Structure of an extrema point</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 7 : 3 . 2</head><label>732</label><figDesc>h e r "Not maximum" o r "Not minimum"; Algorithm for extracting extrema points Generating an extrema graph In this paper, extrema graphs are defined as a group of arcs tha.t connects two extrema points.The graph is held in the structure shown i nFigure 8.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 8 :</head><label>8</label><figDesc>of cells inserted into the list.) In accordance with this a tzraDh. (Here the cost of a a&amp;h means the number IDS of two eztrema points */ /* The m a x i m u m value and m i n i m u m value */ / * N u m b e r of cells included i n the cell list */ /* Intersected cell list */ u m b e r of nodes (=extrema p o i n t s ) */ /* Grid-pointlD of nodes (=extrema points) */ /* arc data */ } GRAPH; Structure of a graph assumption, several closer extrema points are enqueued as a candidate of the "goal" point.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 9 :</head><label>9</label><figDesc>Traversing along an arc If no extrema points are connected with the start point, the closest extrema point among those whose flags' values are not equal is chosen as a goal point. Starting from a cell that includes the start point, the adjacent cells that share the face whose sum is minimum are visited in order. For each visited cell, the distance to the goal point from each grid-point is calculated. The sum of the distance values is then calculated for each face of the visited cell. This process is repeated until it arrives at a cell that includes the goal extrema point. The IDS of the visited cells are inserted into t h e cell list of the arc (see</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 10 :</head><label>10</label><figDesc>Traversing by calculating distanceIn our implementation, each extrema point h a s a flag to be checked for connectivity. A t first, the flag of each extrema point is substituted with its grid-pointID. When an extrema point is connected with another extrema point, the values of the two flags are compared.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 11 : 1 1IFigure 13 :1Figure 14 : 3 . 4 Figure 12 :</head><label>11113143412</label><figDesc>Checking connectivity of extrema pointsThe algorithm for generating an extrema graph is shown inFigure 12. Here, "adjcell" means an adjacent cell.void GenerateGraph(){ for(each extrema i) extrnCi1 .flag = extrnci] .gID; for(each extrema n) { for(each other extrema i) { if(extrmCn1 .flag != extmCi1 .flag) { if(eztrm[i] is HOT too far) Enqueue extrnci] 1 1 uhile(the arc has not been connected) { Dequeue an extrema extrmCn]; if (HakeGraphl(extrmCn] , extrmh~]) == SUCCESS) break ; if(the extrema-points-queue is empty){ HakeCraph2(extrnCn], extrn[n]) ; break; 1 for(each extrema i) if (extrmCi] .flag == extrnCn] .flag) extrmCi1 .flag = extrmCn1 .flag; 1 int nakeGraphl(extrmA, extrmB){ Visitcell = A cell that includes extrmA; uhile (1){ arc.cIDC(arc.numC++)] = Visitcell: typedef struct BCELL { float nin; /* minimum value */ float nax; /* m a x i m u m value */ } BCELL; typedef struct BLIST { int n u d ; /* N o . of boundary cells */ BCELL bcellC1; BCELL +bcell-nin[] ; /* Ordered by minimum values */ BCELL +bcell-naxC] ; /* Ordered by m a x i m u m values */ } BLIST; Structure of boundary cell lists void GenerateBoundList (){ for(each boundary cell clD[i]) { define clD[i].maz and clD[i].min; Generate a minimum value-based boundary cell list; Generate a maximum value-based boundary cell list; 1 Update arc. value CO1 and arc. value C11 ; Algorithm for generating boundary cell lists if(VisitCel1 includes extrmB) return(SUCCESS); Visitcell = the adjcell that intersects the arc; if (VieitCell = BULL) return(FA1LURE) ; Generating isosurfaces void HakeCraph2 (extrnA, extrmB) { Visitcell = A cell that includes extrnA; uhile (1){ arc. CID C (arc. nunc++) 1 = Visitcell ;Update arc .value CO1 and arc. value C11; if(VisitCel1 includes extrmB) return; Visitcell = the adjcell shares the nearest face; Algorithm for generating graphs</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head></head><label></label><figDesc>First, maximum and minimum values are defined for each boundary cell. Two ordered lists are then gener-Our algorithm qenerates an isosurface by traversing an adjacency cell list, starting from seed cells. The main point of our algorithm is to extract seed cells automatically and efficiently. An isosurface is generated when a scalar value is specified. Seed cells are searched for by traversing a boundary cell list and all arcs of the extrema graphs, in order to propagate an isosurface.First, boundary cells are visited in order of the minimum-value-based cell list until the minimum value becomes higher than the given value. If the maximum value of the visited cell is hi her, the cell is regarded as a seed cell. A. maximum-!due-based cell list can also be usede for visiting cells in order.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 13 .void</head><label>13</label><figDesc>the cost of generating an isosurface in our algorithm is estimated as O(n2/3). Our algorithm is thus especially shown in Figure 14. efficient for huge volumes. Boundary cells are held in the structure shown in The algorithm for generating boundary cell lists is &lt;e.g. lsosurface S(x,y,z) -Generatesurf a c e ( f l o a t c ) { for(each c e l l bcell[i] i n the boundary c e l l l i s t ) { i f ( bcell[i].min &lt; C &amp;&amp; b c e l l [ i ] . m a z &gt; C &amp;&amp; bcell[a] is unmarked ) { Propagatesurf ace ( bcell[i], C ) ; 1 for(each a r c ) { if(asc.value[l] &lt; C &lt; asc.value[O]) { i f ( c e l l c l D [ i ] i s i n t e r s e c t e d ) for(each unmarked c e l l i n t h e a r c ) { Propagatesurface( c I D [ i ] , C ) ; Our method has been implemented aiid tested on an IBM PowerStatioii RS/6000 (Model 560). An example of an extrema graph is shown in Figure 17, and 18, where white "+" marks show extrema points. An example of isosurfaces are shown in Figure 19, aiid 20.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head>0</head><label></label><figDesc>Tmg is the total time spent searching for seed cells in 0 T m b is the total time spent creating an active bound-arcs. ary cell list. (See color plates, page CP-7.)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>to the two ordered lists. Only cells in an active cell list are then visited in order to generate a surface. Gallagher has reported a filtering algorithm [5]. In his algorithm, cells whose IDS are consecutive and whose minimum values are also close are grouped. All groups are inserted into span lists that are classified according to the minimum values. Only cells in</head><label></label><figDesc></figDesc><table><row><cell>and Haimes have reported a sorting algorithm</cell></row><row><cell>[4], in which two ordered cell lists are formed in a pre-</cell></row><row><cell>process by sortin the cells' maximum values and min-</cell></row><row><cell>imum values. '&amp;e maximumevalue of the difference between the maximum and minimum values in a cell is also calculated. When a scalar value is specified, an</cell></row><row><cell>active list that purges all non-intersected cells is cre-</cell></row><row><cell>ated by referring the</cell></row><row><cell>specified span lists are visited in order to generate a n</cell></row><row><cell>isosurface. Generally, number of intersected cells is regarded</cell></row><row><cell>as O(n2I3). Therefore, algorithms that visits O( n 2 / 3 )</cell></row><row><cell>cells are required for high-performance generation. In</cell></row><row><cell>Giles's method, number of visited cells for creating a</cell></row></table><note>cell list is regarded as O(n). In Gallagher's method, number of cells in each span lists are regarded as O(n).</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 1</head><label>1</label><figDesc>NbC is the number of boundary tetrahedral cells. is the number of grid points. T h e cost of pre-processing is shown in Tables 2.</figDesc><table><row><cell cols="2">: Size of volumes</cell><cell></cell></row><row><cell cols="3">20736 61680 346644 557868</cell></row><row><cell></cell><cell>16908</cell><cell>97473</cell></row><row><cell>4002</cell><cell>11624 62107</cell><cell>17876</cell></row><row><cell>where</cell><cell></cell><cell></cell></row><row><cell cols="3">0 Nt, is the number of tetrahedral cells (including</cell></row><row><cell>boundary cells).</cell><cell></cell><cell></cell></row></table><note>00 N g p</note></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_2"><head>Table 2 :</head><label>2</label><figDesc>Tpe is the total time for extracting extrema points. Tpe is the total time for connecting extrema by a Tpb is the total time for creating ordered boundary 0 N , is the number of extrema points.</figDesc><table><row><cell></cell><cell cols="3">Performance in the preprocess</cell></row><row><cell></cell><cell cols="3">0.062 0.166 0.600 4.151</cell></row><row><cell></cell><cell cols="3">0.081 0.275 1.138 1.359</cell></row><row><cell>N ,</cell><cell></cell><cell>135</cell><cell>540</cell></row><row><cell>N</cell><cell>468</cell><cell cols="2">1048 3250 10210</cell></row><row><cell>where</cell><cell></cell><cell></cell></row><row><cell>0</cell><cell></cell><cell></cell></row></table><note>000 N g is the number of cells in the list of arcs.</note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We would like to thank K. Shimizu, manager of Advanced Graphics at the Tokyo Research Laboratory, IBM Japan, for his encouragement in this work. We would also like to thank M. Makino, assistant professor of Chuo university, for helpful discussion about scalar fields and extrema points.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>0 T,,,, is the total time spent forming triangles.</p><p>T,, is the total time spent calculating vertex data. 0 2 ' 1 is the total time of our method. 0 TZ is the total time of the conventional method.</p><p>0 Rlz is the ratio of Tz to T I . N,, is the number of cells visited in searching for seed N,; is the number of cells intersecting isosurfaces.</p><p>0 N,, is the number of cells visited in the conventional method.</p><p>0 N , is the number of vertices of surfaces. These results show that R12 is better for larger volumes than for smaller volumes, indicating that our method is especially efficient for large volumes.</p><p>The total cost of an extrema graph is not always minimum, and optimization of the graph remains as future work. However, we d o not expect such optimization to contribute significantly to reducing the cost, because the cost of searching for seed cells in the arcs T,, is so tiny.</p><p>Next, we will discuss the cost of each routine. In our method, the total time is estimated as cells.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Tl = t l ( N b c + Ng) + ( t 2 + t3)Ncp + t5Nv,</head><p>In the straightforward method,</p><p>T h e costs are shown in <ref type="table">Table 4</ref>. <ref type="table">Table 4</ref>: T h e costs of each variables where t l is the cost for searching for seed cells. t z is the cost of checking the sign of the difference between the given scalar value and the value of each grid-point .  To our surprise, t 3 is lower than t 4 , even though it includes the cost of enqueueing and marking cells in our method. We suppose that this result is due to the efficiency of the vertex identifier process. We implemented the process by referring to the vertex data in order of newness. We suppose that the vertex identifier process in the propagation algorithm is more efficient, since the newest triangle has the tendency to share a newer vertex. T h e sorting algorithm <ref type="bibr" target="#b3">[4]</ref> and the filtering algorithm <ref type="bibr" target="#b4">[5]</ref> do not use adjacency such as in the straightforward method, and therefore these vertex identifier processes are not seemed so efficient as those in the propagation method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>In this paper we have proposed a high-performance algorithm for generating isosurfaces, by using extrema graphs and ordered boundary cell lists as a guide to search for seed cells. Our algorithm especially efficient for huge volumes, since the number of visited cells is regarded as O (~Z ' /~) .</p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Marching Cubes: A High Resolution 3D Surface Construction Algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">An Efficient Method of Triangulating Equi-valued Surfaces by Using Tetrahedral Cells</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Doi</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Koide</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEICE Transactions</title>
		<imprint>
			<biblScope unit="volume">74</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="214" to="216" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A Measurement System for 3-D Numerical Simulation Results</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Koyamada</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Itoh</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IPSJ Technical Report</title>
		<imprint>
			<biblScope unit="page" from="93" to="141" />
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Advanced Interactive Visualization for CFD</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Giles</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Haimes</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Systems in Engineering</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="51" to="62" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Span Filtering: An Optimization Scheme for Volume Visualization of Large Finite Element Models</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">S</forename><surname>Gallagher</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;91</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Volume Probe: Interactive Data Exploration on Arbitrary Grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Speray</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Kennon</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="5" to="12" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Visualization of Simulated Airflow in a Clean Room</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Koyamada</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Visualization &apos;92, 4</title>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="page" from="156" to="163" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
