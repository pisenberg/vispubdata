<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Lattice Model for Data Display</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">L</forename><surname>Hibbardla2</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Space Science and Engineering Center 2Computer Sciences Department</orgName>
								<orgName type="institution">University of Wisconsin -Madison</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Charles</forename><forename type="middle">R</forename><surname>Dyer2</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Space Science and Engineering Center 2Computer Sciences Department</orgName>
								<orgName type="institution">University of Wisconsin -Madison</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><forename type="middle">E</forename><surname>Paul1</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Space Science and Engineering Center 2Computer Sciences Department</orgName>
								<orgName type="institution">University of Wisconsin -Madison</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">A Lattice Model for Data Display</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>In order to develop a foundation for visualization, we develop lattice models for data objects and displays that focus on the fact that data objects are approximations to mathematical objects and real displays are approximations to ideal displays. These lattice models give us a way to quantize the information content of data and displays and to define conditions on the visualization mappings from data to displays. Mappings satis&amp; these conditions i f and only if they are lattice isomorphisms. We show how to apply this result to scientific data and display models, and discuss how it might be applied to recursively defined data types appropriate for complex information processing.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>Robertson et.al. have described the need for formal models that can serve as a foundation for visualization techniques and systems <ref type="bibr">[13]</ref>. Models can be developed for data (e.g., the fiber bundle data model <ref type="bibr" target="#b3">[4]</ref> describes the data objects that computational scientists use to approximate functions between differentiable manifolds), lsplays (e.g., Bertin's detailed analysis of static 2-D displays <ref type="bibr">[l]</ref>), users (i.e., their tasks and capabilities), computations (i.e., how computations are expressed and executed), and hardware devices (i.e., their capabilities).</p><p>Here we focus on the process of transforming data into displays. We define a data model as a set U of data objects, a display model as a set V of displays, and a visualization process as a function D: U + V. The usual approach to visualization is synthetic, constmcting the function D from simpler functions. The function may be synthesized using rendering pipelines [5, 11, 121, defining different pipelines appropriate for different types of data objects within U. Object oriented programming may be used to synthesize a polymorphic function D <ref type="bibr">[9,</ref> 151 that applies to multiple data types within U.</p><p>We will try to address the need for a formal foundation for visualization by taking an analytic approach to defining D. Since an arbitrary function D: U + V will not produce displays D(u) that effectively communicate the information content of data objects U E U, we seek to define conditions on D to ensure that it does. For example, we may require that D be injective (i.e., one-to-one), so that no two data objects have the same display. However, th~s is clearly not enough. If we let U and V both be the set of images of 5 12 by 5 12 pixels with 24 bits of color per pixel, then any permutation of U can be interpreted as an injective function D from U to V. But an arbitrary permutation of images will not effectively communicate information. Thus we need to define stronger conditions on the function D. Our investigation depends on some complex mathematics, although we will only present the conclusions in this paper. The details are available in <ref type="bibr" target="#b6">[7]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Lattices as data and display models</head><p>The purpose of data visualization is to communicate the information content of data objects in displays. Thus if we can quantify the information content of data objects and lsplays this may give us a way to define conditions on the visualization function D. The issue of information content has already been addressed in the study of programming language semantics <ref type="bibr" target="#b13">[14]</ref>, which seeks to assign meanings to programs. This issue arises because there is no algorithmic way to separate non-terminating programs from terminating programs, so the set of meanings of programs must include an unde$ned value for non-terminating programs. This value contains less information (i.e., is less precise) than any of the values that a program might produce if it terminates, and thus introduces an order relation based on information content into the set of program meanings. In order to define a correspondence between the ways that programs are constructed, and the sets of meanings of programs, Scott developed an elegant lattice theory for the meanings of programs [ 161.</p><p>Scientists have data with undefined values, although their sources are numerical problems and failures of observing instruments rather than non-terminating computations. An undefined value for pixels in satellite images contains less information than valid pixel radiances and thus creates an order relation between data values. Data are often accompanied by metadata <ref type="bibr" target="#b17">[18]</ref> that describe their accuracy, for example as error bars, and these accuracy estimates also create order relations between data values based on information content (i.e., precision).</p><p>Finally, array data objects are often approximations to functions, as for example a satellite image is a finite approximation (i.e., a finite sampling in both space and radiance) to a continuous radiance field, and such arrays may be ordered based on the resolution with which they sample functions.</p><p>In general scientists use computer data objects as finite approximations to the objects of their mathematical models, which contain infinite precision numbers and functions with infinite ranges. Thus metadata for missing data indicators, numerical accuracy and function sampling are really central to the meaning of scientific data and should play an important role in a data model. We define a data model U as a lattice of data objects, ordered by how precisely they approximate mathematical objects. To say that U is a lattice <ref type="bibr" target="#b1">[2]</ref> means that there is a partial order on U (i.e., a binary relation such that, for and u1 5 u2 &amp; u2 I u3 u1 I ug) and that any pair u l , u2 E U have a least upper bound (denoted by u1 v u2) and a greatest lower bound (denoted by u1 A u2).</p><p>The notion of precision of approximation also applies to displays. They have finite resolutions in space, color and time (i.e., animation). 2-D images and 3-D volume renderings are composed of finite numbers of pixels and voxels and are finite approximations to idealized mathematical displays. Thus we will assume that our display model V is a lattice and that displays are ordered according to their information content (i.e., precision of approximation to ideal displays). In Sections 4 and 5 we will present examples of scienhfk data and display lattices.</p><p>We assume that U and V are complete lattices, so that they contain the mathematical objects and ideal displays that are limits of sets of data objects and real displays (a lattice is complete if any subset has a least upper bound and a greatest lower bound). Just as we study functions of rational numbers in the context of functions of real numbers (the completion of the rational numbers), we will study visualization functions between the complete lattices U and V, recognizing that data</p><formula xml:id="formula_0">all u l , u2, u3 E U, u1 I U1' u1 I u2 &amp; u2 I u1 3 u1 = u2</formula><p>objects and real displays are restricted to countable subsets of U and V.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Conditions on visualization functions</head><p>The lattice structures of U and V provide a way to quantize information content and thus to define conditions on functions of the form D: U + V. In order to define these conditions we draw on the work of Mackinlay [ 101. He studied the problem of automatically generating displays of relational information and defined expressiveness conditions on the mapping from relational data to displays. His conditions spec$ that a display expresses a set of facts (i.e., an instance of a set of relations) if the display encodes all the facts in the set, and encodes only those facts.</p><p>In order to interpret the expressiveness conditions we define a fact about data objects as a logical predicate applied to U (i.e., a function of the form P: U + valse, true}). However, since data objects are approximations to mathematical objects, we should avoid predicates such that providing more precise information about a mathematical object (i.e., going from u1 to u2 where u1 I u2) changes the truth value of the predicate (e.g., P(ul) = true but P(u2) = false). Thus we consider predicates that take values in {undefined, false, true} (where undefined &lt;false and undejned &lt; true), and we require predicates to preserve information ordering (that is, if u1 &lt; u2 then P(ul) 5 P(u2); functions that preserve order are called monotone). We also observe that a predicate of the form P: U + (undejned, false, true} can be expressed in terms of two predicates of the form P: U + {undejned, true}, so we will limit facts about data objects to monotone predicates of the form</p><formula xml:id="formula_1">P: U + {undejned, true}.</formula><p>The first part of the expressiveness conditions says that every fact about data objects is encoded by a fact about their displays. We interpret this as follows:</p><formula xml:id="formula_2">Condition 1.</formula><p>For every monotone predicate P: U + {unde$ned, true}, there is a monotone predicate Q: V + (unde$ned, true} such that</p><formula xml:id="formula_3">P(u) = Q(D(u)) for each U E U.</formula><p>This requires that D be injective (if u1 # u2 then there are P such that P(ul) # P(u2), but ifD(ul) = D(u2) then Q(D(u,)) = Q(D(u2)) for all Q, so we must have The second part of the expressiveness condltions says that every fact about displays encodes a fact about data objects. We interpret this as follows:</p><formula xml:id="formula_4">D ( q ) f W,)).</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Condition 2.</head><p>For every monotone predicate Q: V -+ {undefined, true}, there is a monotone prehcate P:</p><formula xml:id="formula_5">U -+ {undefined, true} such that Q(v) = P(D-I(v)) for each v E V.</formula><p>This requires that D-I be a function from V to U, and hence that D be bijective (i.e.. one-to-one and onto). However, it is too strong to require that a data model realize every possible display. Since U is a complete lattice it contains a maximal data object X (the least upper bound of all members of U). Then D(X) is the display of X and the notation &amp;D(X) represents the complete lattice of all displays less than D(X). We m o w Conltion 2 as follows:</p><formula xml:id="formula_6">Condition 2'.</formula><p>For every monotone predicate Q: &amp;D(X) -+ {undefined, true}, there is a monotone predicate P:</p><formula xml:id="formula_7">U -+ {undefined, true} such that Q(v) = P(D-'(v)) for each v E &amp;D(X).</formula><p>These conditions quant@ the relation between the information content of data objects and the information content of their displays. We use them to define a class of functions:</p><formula xml:id="formula_8">Definition. A function D: U -+ V is a display function if it satisfies Conditions 1 and 2'.</formula><p>In <ref type="bibr" target="#b6">[7]</ref> we prove the following result about display functions: This result may be applied to any complete lattice models of data and displays. In the next three sections we will explore its consequences in one setting.</p><formula xml:id="formula_9">Proposition 1. A function D: U -+ V</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">A Scientific data model</head><p>We will develop a scientific data model that integrates metadata for missing data indicators, numerical accuracy and function sampling. We will develop this data model in terms of a set of data types, starting with scalar types used to represent the primitive variables of mathematical models. Given a scalar type s, let I, denote the set of possible values of a data object of the type s. First we define continuous scalars to represent real variables, such as time, temperature and latitude. If s is continuous then I, includes the undefined value, which we denote by the symbol I (usually used to denote the least element of a lattice), and also includes all closed real intervals. We interpret the closed real interval [x, y ] as an approximation to an actual value that lies between x and y. In our lattice structure, these intervals are ordered by the inverse of set containment, since a smaller interval provides more precise information than a containing interval. <ref type="figure" target="#fig_1">Figure 1</ref> illustrates the order relation on a continuous scalar type. Of course, an actual implementation can only include a countable number of closed real intervals (such as the set of rational intervals). We also define discrete scalars to represent integer and string variables, such as year, frequency-count and satellitename. If s is discrete then I, includes I and a countable set of incomparable values (no integer is more precise than any other integer). <ref type="figure" target="#fig_2">Figure 2</ref> illustrates the order relation on a discrete scalar type.</p><p>. . .    <ref type="figure" target="#fig_1">I .A, 1 .el, [3.1, 3.41</ref>  We say that temperature and pressure are element types of the tuple. The elements of a tuple type may be any complex types (they must be defined from disjoint sets of scalars). A tuple data object</p><p>x is less than or equal to a tuple data object y if every element of x is less than or equal to the corresponding element of y, as illustrated in <ref type="figure" target="#fig_7">Figure 5</ref>. <ref type="bibr">(</ref> \ / This data model is applied to a particular application by defining a finite set S of scalar types (these would represent the primitive variables of the application), and defining T as the set of all types that can be constructed as arrays and tuples from the scalar types in S. For each type t E T we can define a countable set Ht of data objects of type t (these correspond to the data objects that are realized by an implementation).</p><p>In order to apply our lattice theory to this data model, we must define a single lattice U and embed each Ht in U. First define X = X { I , I s E S} as the cross product of the value sets of the scalars in S. Its members are tuples with one value from each scalar in S, ordered as illustrated in <ref type="figure" target="#fig_7">Figure 5</ref> . Now we would like to define U as the power set of X (i.e., the set of all subsets of a.</p><p>However, power sets have been studied for the semantics of parallel languages and there is a well known problem with constructing order relations on power sets [ 141. We expect this order relation to be consistent with the order relation on X and also consistent with set containment.</p><p>For example, if a, b E X and a &lt; b, we would expect that { a } &lt; { b } . Thus we might define an order relation between subsets of X by: However, given a &lt; 6, (1) implies that { b } &lt; { a , b } and { a , b } &lt; { b } are both true, which contradicts { b } f { a , b }. This problem can be resolved by restricting the lattice U to sets of tuples such every tuple is maximal in the set. That is, a set A c X belongs to the lattice U if a &lt; b is not true for any pair a, b E A . The members of U are ordered by (I), as illustrated in <ref type="figure" target="#fig_8">Fig. 6</ref>, and form a complete lattice (see <ref type="bibr" target="#b6">[7]</ref> for more details).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I \ \ /</head><p>6 (the empty set)   in U with the form {(I, temp, pres)}. This embeds the tuple data type in the lattice U, as illustrated in <ref type="figure" target="#fig_9">Figure 7</ref>.</p><p>Similarly, we can embed array data types in the data lattice. For example, consider an array data type (array [time] of temperature;). A data object of th~s type consists of a set of pairs of (time, temp). This array data object can be embedded in U as a set of tuples of the form <ref type="figure">(time, temp, I</ref>). <ref type="figure" target="#fig_10">Figure 8</ref> illustrates this embedding. The basic ideas presented in Figs. 7 and 8 can be combined to embed complex data types, defined as hierarches of tuples and arrays, in data lattices (see <ref type="bibr" target="#b6">[7]</ref> for details).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">A scientific display model</head><p>For our scienhfk display model, we start with Bertin's analysis of static 2-D displays [ 1 J. He modeled displays as sets of graphical marks, where each mark was described by an 8-tuple of graphical primitive values (i.e., two screen coordinates, size, value, texture, color, orientation and shape). The idea of a display as a set of tuple values is quite similar to the way we constructed the data lattice U. Thus we define a finite set DS of display scalars to represent graphical primitives, we define Y = X{ld I d E OS} as the cross product of the value sets of the display scalars in OS, and we define V as the complete lattice of all subsets A of Y such that every tuple is maximal in A.  We can define a specific lattice V to model animated 3-D displays in terms of a set of seven continuous display scalars: <ref type="figure">(x, y, z, red, green, blue, time}.</ref> A tuple of values of these display scalars represents a graphical mark. The interval values of x, y and z represent the locations and sizes of graphical marks in the volume, the interval values of red, green and blue represent the ranges of colors of marks, and the interval values of time represent the place and duration of persistence of marks in an animation sequence. This is illustrated in <ref type="figure" target="#fig_12">Figure 9</ref>. A display in V is a set of tuples, representing a set of graphical marks.</p><p>Display scalars can be defined for a wide variety of attributes of graphical marks, and need not be limited to simple values. For example, a discrete display scalar may be an index into a set of complex shapes (i.e., icons).</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Scalar mapping functions</head><p>Proposition 1 said that a function of the form D: U -+ V satisfies the expressiveness conditions (i.e., is a display function) if and only if D is a lattice isomorphism from U onto &amp;D(X), a sublattice of V. We can now apply this to the scientific data and display lattices described in Section 4 and 5.</p><p>The scalar and display scalar types play a special role in characterizing display functions in the context of our scientific models. Given a scalar type s E S, define U, E U as the set of embeddings of objects of type s in U. T h s tells us that display functions map scalars, which represent primitive variables like time and temperature, to display scalars, which represent graphical primitives like screen axes and color components. Most displays are already designed in this way, as, for example, a time series of temperatures may be displayed by mapping time to one axis and temperature to another. The remarkable thing is that Proposition 2 tells us that we don't have to take this way of designing displays as an assumption, but that it is a consequence of a more fundamental set of expressiveness conditions. <ref type="figure" target="#fig_1">Figure 10</ref> provides examples of mappings from scalars to display scalars (lat-lon is a reaf2d scalar, as described in Section 7). In <ref type="bibr" target="#b6">[7]</ref> we present a precise definition <ref type="bibr">(</ref> Then the functions gs and h, can be defined in terms of g &gt; and h&gt; as follows: These functions must satisfy the conditions illustrated in <ref type="figure" target="#fig_1">Figure 11</ref>. Although the complete lattices U and V include members containing infinite numbers of tuples (these are mathematical objects and ideal displays) in <ref type="bibr" target="#b6">[7]</ref> we prove the following: user selects a set of values and only those graphical marks whose selector values that overlap this set are displayed. Contour is a real display scalar and selector display scalars take the type of the scalar mapped to them.</p><p>We plan to add real display scalars for transparency and reflectivity to the system (to be interpreted by complex volume rendering of graphical marks), as well as a real3d display scalar for vector (to be interpreted by flow rendering techniques).</p><p>VIS-AD is available by anonymous ftp from iris.ssec.wisc.edu (144.92.108.63) in the pubhisad directory.</p><p>Get the README file for complete installation instructions.  </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Implementation</head><p>The data and display models described in Sections 4 and 5, and the scalar mapping functions described in Section 6, are implemented in our VIS-AD system <ref type="bibr">[6, 81.</ref> This system is intended to help scientists experiment with their algorithms and steer their computations. It includes a programming language that allows users to define scalar and complex data types and to express scientific algorithms. The scalars in this language are classified as real (i.e., continuous), integer (discrete), string (discrete), real2d and real3d. The real2d and real3d scalars have no analog in the data model presented in Section 4, but are very useful as the domains of arrays that have non-Cartesian sampling in two and three dimensions. Users control how data are displayed by defining a set of mappings from scalar types (that they declare in their programs) to display scalar types. By defining a set of mappings a user defines a display function D : U += V that may be applied to display data objects of any type.</p><p>The VIS-AD display model includes the seven display scalars described for animated 3-D displays in Section 5. and also includes display scalars named contour and selector. Multiple copies of each of these may exist in a display lattice (the numbers of copies are determined by the user's mappings). Scalars mapped to contour are depicted by drawing isolevel curves and surfaces through the field defined by the contour values in graphical marks. For each selector display scalar, the</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="8">Recursively defined data types</head><p>The data model in Section 4 is adequate for scientific data, but is inadequate for complex information processing which involves recursively dejined data types <ref type="bibr" target="#b13">[14]</ref>. For example, binary trees may be defined by the type bintree = struct{bintree; bintree; value;} (a leaf node is indicated when both bintree elements of the tuple are undefined). Several techniques have been developed to model such data using lattices. In the current context, the most promising is called universal domains [3, 171. Just as we embedded data objects of many different types in the domain U in Section 4, data objects of many different recursively defined data types are embedded in a universal domain (which we also denote by U). However, these embeddings have been defined in order to study programming language semantics, and have a serious problem in the visualization context. Data objects of many different types are mapped to the same member of U. For example, an integer and a function from the integers to the integers may be mapped to the same member of U, and thus any display function of the form D : U -+ V will generate the same display for these two data objects. Thus, in order to extend our lattice theory of visualization to recursively defined data types, other embeddings into universal domains must be developed.</p><p>A suitable display lattice V must also be developed such that there exist lattice isomorphisms from a universal domain U into V. Displays involving diagrams and hypertext links are analogous to the pointers usually used to implement recursively defined data types. Thus the interpretation of V as a set of actual displays may involve these graphical techniques. However, since a large class of recursively defined data types can be embedded in U, and since V is isomorphic to IJ, these graphical techniques must be applied in a very abstract manner to define a suitable lattice V.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="9">Conclusions</head><p>It is easy to think of metadata as secondary when we are focused on the task of making visualizations of data.</p><p>However, it is central to the meaning of scientific data that they are approximations to mathematical objects, and lattices provide a way to integrate metadata about precision of approximation into a data model. By bringing the approximate nature of data and displays into central focus, lattices provide a foundation for understanding the visualization process and an analytic approach to defining the mapping from data to displays. While Proposition 2 just confirms standard practice in designing displays, it is remarkable that this practice can be deduced from the expressiveness conditions.</p><p>Although we have not derived any new rendering techtuques by using lattices, the high level of abstraction of scalar mapping functions do provide a very flexible user interface for controlling how data are displayed.</p><p>There will be considerable technical dBculties in extending this work to recursively defined data types, but we are confident that the results will be interesting.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>is a display function if and only if it is a lattice isomorphism from U onto &amp;D(X) [i.e., for all u1, u2 E U, D(ul v u2) = D(ul) v D(u2) and D(ul A u2) = D(ul) A D(u,)J.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 .</head><label>1</label><figDesc>The order relations among a few values of a continuous scalar.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 .</head><label>2</label><figDesc>The order relations among a few values of a discrete scalar. Complex data types are constructed from scalar data types as arrays and tuples. An array data type represents a function between mathematical variables. For example, a h c t i o n from time to temperature is approximated by data objects of the type (array [time] of temperature;). We say that time is the domain type of this array, and temperafure is its range type. Values of an array type are sets of 2-tuples that are (domain, range) pairs. The set {([l.l, 1.61, [3.1, 3.4]), ([3.6, 4.11, [5.0, 5.2]), ([6.1, 6.41, [6.2, 6.51)) is an array data object that contains three samples of a function from time to temperatwe. The domain value of a sample lies in the first interval of a pair and the range value lies in the second interval of a pair, as illustrated inFigure 3. Adding more samples, or increasing the precision of samples, will create a more precise approximation to the function.Figure 4illustrates the order relation on an array data type. The domain of an array must be a scalar type, but its range may be any scalar or complex type (its definition may not include the array's domain type).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 .</head><label>3</label><figDesc>An array samples a real function as a set of pairs of intervals.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 .</head><label>4</label><figDesc>The order relations among a few arrays. Tuple data types represent tuples of mathematical objects. For example, a 2-tuple of values for temperature and pressure is represented by data objects of the type struct{ temperature; pressure;}. Data objects of th~s type are 2-tuples (temp, pres) where temp E Itemperature and pres E Ipre,,,,.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 5 .</head><label>5</label><figDesc>The order relations among a few tuples.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 6 .</head><label>6</label><figDesc>The order relations among a few members of a data lattice U defined by three scalars. (templ, presl) -&gt; {(I, templ, pres1 object of a tuple type time value =I set of one tuple with</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 7 .</head><label>7</label><figDesc>An embedding of a tuple type into a lattice.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 8 .</head><label>8</label><figDesc>An embedding of an array type into a lattice.To see how the data objects in Ht are embedded in U, consider a data lattice U defined from the three scalars time, temperature and pressure. Objects in the lattice U are sets of tuple of the form(time, temperature, pressure).We can define a tuple data type sfruct{temperature; pressure;}. A data object of this type is a tuple of the form (temp, pres) and can be mapped to a set of tuples (actually, it is a set consisting of one tuple)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head>Figure 9 .</head><label>9</label><figDesc>The roles of display scalars in an animated 3-D display model.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>That is, U, consists of sets of tuples of the form {(I ,..., b ,..., I)} (this notation indicates that all components of the tuple are I except the s component, which is b). Similarly, given a display scalar type d E OS, define Vd E Vas the set of embeddings of objects of type d in V. In [7] we prove the following result: Proposition 2. If D: U -+ V is a display function, then we can define a mapping M P D : S -+ POWER(DS) (thls is the power set of OS) such that for all scalars s E S and all for a E U, , there is d E M P &amp; ) such that D(a) E V&amp; The values of D on all of U are determined by its values on the scalar embeddings U, . Furthermore, (a) If s is discrete and d E M P g ( s ) then d is discrete, (b) If s is continuous then M p~( s ) contains a single continuous display scalar. (c) Ifs z SI then M P&amp;) n M P D ( s ' ) = 4.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_14"><head></head><label></label><figDesc>type image-sequence = array [time] of array [lat-Ion] of structure (ir; vis;) red green blue Figure 10. Mappings from scalars to display scalars.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_15"><head></head><label></label><figDesc>the details are complex) of scalar mapping functions and show that D: U -+ Vis a display function if and only if it is a scalar mapping function. Here we will just describe the behavior of display functions on continuous scalars. If s is a continuous scalar and M P D ( s ) = d, then D maps U, to V&amp; This can be interpreted by a pair of functions gs:R x R -+ R and hs:R x R -+ R (where R denotes the real numbers) such that for all {(I ,..., [x. y ] ,..., I)} in Us, D({ (J-,...k Y I ,... , I ) } ) = { ( I ,..., ks(x, y ) , As@, Y)I ,...,U}, which is a member of Vd. Define functions g &gt; : R + R and h&gt;:R -+ R by g&gt;(z) = gs(z, z ) and h&gt;(z) = h,(z, z).</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_16"><head></head><label></label><figDesc>y ) = min{g&gt;(z) I x I z I y } and hs(x, y) = max{h&gt;(z) I x I z I y } .</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_17"><head>Proposition 3 .</head><label>3</label><figDesc>Given a display function D :U += V,a data type t E T and an embedding of a data object from Ht to a E U, then a contains a finite number of tuples and D(a) E V contains a finite number of tuples.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_19"><head>Figure 11 .</head><label>11</label><figDesc>The behavior of a display function D on a continuous scalar interpreted in terms of the behavior of functions h; and 9;.</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was support by NASA grant NAGS-828, and by the National Science Foundation and the Defense Advanced Research Projects Agency under Cooperative Agreement NCR-8919038 with the Corporation for National Research Initiatives.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<monogr>
		<title level="m" type="main">Semiology of Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Bertin</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1983" />
			<publisher>W. J. Berg, Tr. University of Wisconsin Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<monogr>
		<title level="m" type="main">Introduction to Lattices and Order</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">A</forename><surname>Davey</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">A</forename><surname>Priestly</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<publisher>Cambridge University Press</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Semantic domains</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">A</forename><surname>Gunter</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">The MIT PressElsevier</title>
		<editor>B., J. van Leeuwen</editor>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="page" from="633" to="674" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">A data model for scientific visualization with provisions for regular and irregular grids</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">B</forename><surname>Haber</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lucas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Collins</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Visualization 91. IEEE</title>
		<meeting>Visualization 91. IEEE</meeting>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="page" from="298" to="305" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">ConMan: A visual programming language for interactive graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">[</forename><surname>Si Haberli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<date type="published" when="1988" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<monogr>
		<title level="m" type="main">Display of scientific data structures for algorithm visualization. Visualization &apos;92</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Hibbard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Dyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Paul</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="139" to="146" />
			<pubPlace>Boston, IEEE</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<monogr>
		<title level="m" type="main">A lattice theory of data display</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">L</forename><surname>Hibbard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Dyer</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page">11</biblScope>
		</imprint>
		<respStmt>
			<orgName>Computer Sciences Department, University of Wisconsin-Madison</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Tech. Rep. # 1226</note>
	<note>Also available as compressed postscript files by anonymous ftp from iris.ssec.wisc.edu (144.92.108.63) in the pub/lattice directory</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Interactive visualization of Earth and space science computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">L</forename><surname>Hibbard</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><forename type="middle">E</forename><surname>Paul</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Santek</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Dyer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><forename type="middle">L</forename><surname>Battaiola</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M-F</forename><surname>Voidrot-Martinez</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer special July issue on visualization</title>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">SuperGlue: A programming environment for scientific visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">P M</forename><surname>Hultquist</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">L</forename><surname>Raible</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Visualization &apos;92</title>
		<meeting>Visualization &apos;92</meeting>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="243" to="250" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Automating the design of graphical presentations of relational information</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Io] Mackinlay</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Graphics</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="110" to="141" />
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">GRAPE: An environment to build display processes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Nadas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Fournier</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="103" to="111" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">FRAMES: Software tools for modeling, animation and rendering of 3D scenes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Potmesil</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><surname>Hoffert</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="75" to="84" />
			<date type="published" when="1987" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Research issues in the foundations of visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">K</forename><surname>Robertson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Earnshaw</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Thalman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Grave</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Gallup</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">M</forename><surname>Jong</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">14</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="73" to="76" />
			<date type="published" when="1994" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Schmidt</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1986" />
			<publisher>Denotational Semantics. Wm.C .Brown</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">VISAGE: An object-oriented scientific visualization system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">J</forename><surname>Schroeder</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><forename type="middle">E</forename><surname>Lorenson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><forename type="middle">D</forename><surname>Montanaro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Volpe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. Visualization &apos;92</title>
		<meeting>Visualization &apos;92</meeting>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="19" to="226" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<analytic>
		<title level="a" type="main">The lattice of flow diagrams</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Symposium on Semantics of Algorithmic Languages</title>
		<editor>E. Engler</editor>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1971" />
			<biblScope unit="volume">31</biblScope>
			<biblScope unit="page" from="1" to="366" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Data types as lattices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Scott</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Siam J. Comput</title>
		<imprint>
			<biblScope unit="volume">5</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="522" to="587" />
			<date type="published" when="1976" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">SIGGRAPH &apos;90 workshop report: data structure and access software for scientific visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><forename type="middle">A</forename><surname>Treinish</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="104" to="105" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
