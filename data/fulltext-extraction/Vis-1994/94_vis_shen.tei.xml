<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Differential Volume Rendering: A Fast Volume Visualization Technique for Flow Animation</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Han-Wei</forename><surname>Shen</surname></persName>
							<email>hwshen@cs.utah.edu</email>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Utah Salt Lake City</orgName>
								<address>
									<postCode>84112</postCode>
									<region>UT</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Christopher</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Department of Computer Science</orgName>
								<orgName type="institution">University of Utah Salt Lake City</orgName>
								<address>
									<postCode>84112</postCode>
									<region>UT</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Differential Volume Rendering: A Fast Volume Visualization Technique for Flow Animation</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:31+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>We present a direct volume rendering algorithm to speed up volume animation for flow visualizations. Data coherency between consecutive simulation time steps is used to avoid casting rays from those pixels retaining color values assigned to the previous image. The algorithm calculates the differential information among a sequence of 3D volumetric simulation data. At each time step the differential information is used to compute the locations of pixels that need updating and a my-casting method is utilized to produce the updated image. We illustmte the utility and speed of the differential volume rendering algorithm with simulation data from computational bioelectric and fluid dynamics applications. We can achieve considemble disk-space savings and nearly real-time rendering of 30 flows using low-cost, single processor workstations&apos; for models which contain hundreds of thousands of data points.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Introduction</head><p>While there is a rich history of numerical techniques for computing the dynamics of wave propagation, only recently have researchers been able to visualize the complex dynamics of large 3D flow simulations [l, 2, 31. Visualizations of flow dynamics t y p ically involve characterizing relevant features of vector and scalar fields. While visualizing vector fields is particularly important in many applications, it is also important to quantify and visually characterize scalar features of the flow field such as, temperature, voltage, and magnitudes of vector quantities. Direct volume-rendering techniques, effective tools for exploring 3D scalar data, have been proposed as a methodology to visualize scalar features in the flow 'Such as the SGI Indy or other comparable workstations field [4,5,6]. Unlike surface-rendering methods, direct volume-rendering methods can be used to visualize 3D scalar data without converting intermediate geometric primitives. By assigning appropriate colors and opacities to the scalar data, one can render objects semitransparently to expand the amount of 3D information available at a fixed position. Volume-rendered images can also be superimposed upon surface-oriented icons or textures, thus allowing for simultaneous scalar and vector field composite visualizations.</p><p>A wide range of volume rendering techniques have been applied to the problem of flow visualization. <ref type="bibr">Ma and Smith i3]</ref> introduced a virtual smoke technique to enhance visualization of gaseous fluid flows. This technique allows users to interactively insert a seed into an interesting location and only the region immediately surrounding the seed is rendered. <ref type="bibr">Max et al. [5]</ref> introduced 3D textures advected by wind flow upon volume rendered climate images to visualize both the scalar and vector fields of the images. <ref type="bibr">Crawfis and Max [7]</ref> make use of textured splats which utilize volume splatting and 3D texture mapping techniques to reveal scalar and vector information simultaneously. Additionally, Max et al.</p><p>[SI developed the concept of flow volumes, volumetric equivalents of stream lines, to represent additional information about the vector field.</p><p>We are motivated to develop a more efficient way to visualize scalar fields by our attempts to visualize simulation data from a model of electrical wave p r o p agation within the complex geometry of the heart and in large scale models of unsteady compressible fluid flow [9, lo]. Because of the regular structures used to characterize the simulation data, we can use direct volume-rendering techniques to visualize the states at each time step. We characterize states within the model by assigning different colors and opacities. By animating the volume-rendered images at each time step, we can effectively investigate the propagation of waves throughout the volume.</p><p>Direct volume-rendering methods employing ray casting algorithms have become the standard methods to visualize 3D scalar data. To characterize the dynamic behavior of the flow field, one generates a series of volume rendered images at different time steps and then records, stores, and animates the sequence. Because direct volume rendering is very time consuming to realize such animations for models of any significant size (i.e. realistic problems in science and engineering), standard volume-rendering techniques are prohibitive for animating hundreds of time steps interactively. Moreover, the disk space required for storing hundreds or thousands of sets of volumetric simulation data could be overwhelming.</p><p>The main contribution of this paper is the development of an algorithm which significantly reduces the time to create volume-rendered flow animations of scalar fields. Furthermore, our algorithm reduces the amount of disk space needed for storing volume data. We achieve these reductions by implementing a differential volume-rendering method. The method utilizes data coherency between consecutive time steps of simulation data to accelerate the volume animation and to compress the volume data. The method is independent of specific volume-rendering techniques and can be adapted into a variety of ray casting paradigms which can be used to further accelerate the visualization process [ll, 12, 131.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Differential Volume Rendering</head><p>E+om preliminary studies of our wave propagation simulations, we noticed that the only elements which changed values between consecutive time steps, when the time steps were small, were the activated cells and their neighbors. We hypothesized that only a fraction of elements in the volume change from any given time step to the next in simulations of physical flow phenomena. In addition, when a sequence of propagating images is animated, the viewing parameters usually don't change. In our ray casting method, we are able to cast rays along a path corresponding only to changed data elements. Therefore, the pixels in the new image keep the same colors that they had previously unless they correspond to changed data elements. Retaining the color values from the nonchanging pixels results in a significant time savings. The differential volume-rendering algorithm thus exploits the temporal coherence between sets of volume data from different time steps in order to speed up volume animation of the 3D flow.  The differential volume rendering method separates the data generation and data visualization processes. Scientists perform simulations to obtain sequences of data at different time steps. The differential volumerendering algorithm extracts the differential information which contains the differences between the data files at each consecutive time step. According to the specified viewing direction, the pixel positions where new rays need to be cast can be computed from the differential information and then the ray casting process is invoked to produce the updated image. Because the variation between consecutive time steps is small, the differential information file, which replaces the whole sequence of volume data, can yield tremendous savings in terms of disk space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Visualization Pipeline</head><p>The visualization pipeline of the differential volume-rendering method can be divided into two phases, static and dynamic.</p><p>First, data is generated from a simulation which might typically consist of hundreds or thousands of time steps worth of information. Second, the difference extractor is invoked to compare the simulation data of consecutive time steps to obtain the positions of changed data elements between simulation steps. The positions of those changed elements and their corresponding time step values are output into a single diferential file. Because the differential file contains the state histories of all the data elements through the whole course of the simulation, the only information needed for the rendering process, the volume data at each time step can be then discarded, yielding a considerable savings in terms of disk space. These operations are classified as the static phase because they need to be performed only once for a simulation. The differential information obtained over the duration of the simulations contains the 3D positions and values of changed data elements. Those positions are independent of the viewing direction of the rendering. By pre-processing the simulation data and producing the differential file in advance, we can avoid the delay of calculating the differential information while performing ray casting.</p><p>At each time step, the positions of changed elements are extracted from the differential file and the pixels where new rays need to be cast can be computed according to the viewing direction and the sampling method. The resultant pixel positions are placed into a ray casting list to which the ray casting process refers before firing new rays to produce the updated image. We classified these operations as the dynamic phase because the pixels corresponding to those changed elements are dependent on the viewing direction. The pixel positions remain undetermined until the user specifies the viewing parameters. The operations in the dynamic phase of the pipeline are illustrated in <ref type="figure" target="#fig_2">Figure 2</ref> and are outlined algorithmically below. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Pixel Positions Calculation</head><p>There are many interpolation and ray sampling methods which can be used in the ray casting algorithm. For interactive rendering rates, but coarse image quality, we can use a discrete ray which avoids the use of interpolation. To obtain higher quality images, one can increase the sampling rate along the ray and use, for example, a trilinear interpolation scheme.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Continuous Rays and Trilinear Interpolation:</head><p>When using continuous ray sampling along with a trilinear interpolation scheme, we compute the value of any point in the volume by interpolating the values of the data element's encompassing eight vertices. If any of these eight data elements changes its value, the interpolated value of the point inside that cube needs to be re-computed. We define the interpolation space of a data element as the space where the values of all the points located inside are influenced by that data element while the interpolation is performed. In the case of a 3D regularly structured grid, a vertex is shared by its eight adjacent cubes. Therefore, for any data element, its interpolation space is the volume of its eight adjacent cubes.</p><p>To locate those pixels which will cast a ray through a data element's interpolation space, we project the eight vertices of that cubic volume back to the image plane according to the viewing parameters (parallel or perspective). The pixels bound by the projected region then need to be updated.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Discrete Rays and Zero-Order Interpolation:</head><p>Discrete rays can be obtained by extending the digital differential analyzer (DDA) scan converting line algorithm <ref type="bibr">[14]</ref> into three dimensions. In a zero-order interpolation scheme, at each forwarding step only the nearest voxel is sampled. No actual interpolation o p eration is performed. Suppose the 3D line equations are y = m l * x + b and z = m2 * x + c, and both m l and m2 are less than 1 and greater than -1. According to the discrete ray algorithm, the ray in position x would be increased by 1 at each forwarding step. After i times of forwarding, the ray's discrete position</p><formula xml:id="formula_0">is [i, Round(m1 * a' + b ) , Round(m2 * i + c ) ]</formula><p>, and the voxel located at that position is sampled.</p><p>To calculate pixels corresponding to the changed voxel element, one projects the voxel position back to the image plane according to the viewing direction. Most of the time the projected position won't be located exactly at the image plane's grid point. The four surrounding pixels of that projected point thus need to be selected to cast new rays. We cast rays from the four surrounding pixels instead of choosing only the nearest pixel to assure that the changed voxel will be hit and sampled. Template Based Rays: When parallel projection is used, all rays fired from the image plane have the same slope and thus the same incremental form of forwarding path. Therefore, one can calculate the incremental form once and store it as a template [la, 41. During the ray casting procedure, instead of computing the ray's new position at each time step, which increases computational complexity, we can use ray templates. Suppose we have the forwarding templates in U, v and w directions which have the forms of ray-template <ref type="bibr">[i]</ref> .U, ray-template <ref type="bibr">[i]</ref>.v, and ray-template <ref type="bibr">[i]</ref>.w. The ray-template <ref type="bibr">[i]</ref>.u stores, for instance, the distance the ray should march at the next step in U direction after the ray has taken i steps of forwarding. Suppose the current position of a ray is <ref type="bibr">[U, v, w]</ref>, then the next position <ref type="bibr">[U', v', w']</ref> of the ray is calculated as:</p><formula xml:id="formula_1">U ' = U + ray-templatecil .U; v ' = v + ray-templatecil .v; U ' = w + ray-templatecil .U;</formula><p>To guarantee a complete and uniform tessellation of the volume by 26-connected rays' sampling, we cast rays from the base-plane, which is parallel to one of the volume faces. After having obtained the projected image on the base-plane, one performs a 2D mapping from the base-plane to the image plane to obtain the final image.</p><p>The templates described above give us the information about how far a ray will forward at each step in each axis direction. From those templates, one computes the displacement a ray has forwarded in each direction after a particular time step. Inversely, we can also obtain the number of forwarding steps corresponding to a particular displacement. This information gives us two more templates in each axis direction which can be described as two functions, displacement-tostep() and step-to-displacement0 . Given a displacement from a volume point to the base plane, the displacement-tostep() function will return the steps taken by a ray to reach that point. Given a forwarding step number for a ray, the step-to-displacement () will return the displacement from the base plane.</p><p>With these extra templates, the pixel position calculation becomes simple. Given a point in volume space, we can find the distance from that point to the base plane. By using the displacement-tostep template, we are able to calculate the steps taken by a ray from the base plane to that point. Thus we can look up the step-to-displacement templates to get the displacement in each direction, and the starting position of the ray can be calculated. By adopting the template-based ray casting method and utilizing precomputed displacement and step templates, we can accurately and efficiently calculate the pixel positions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acceleration of Ray Casting</head><p>Coordinate Buffer: Yagel and Shi <ref type="bibr">[ll]</ref> proposed a coordinate buffer to store the first-and last-hit voxel positions for every pixel on the image plane allowing one to rapidly skip empty space for subsequent renderings. The differential volume rendering algorithm further utilizes this idea for volume animations to speed up the ray casting process.</p><p>If the viewing direction is fixed during the rendering of a sequence of volume data, each ray from the image plane follows exactly the same forwarding path during the whole course of renderings with different sets of volume data. If only a small fraction of data elements change between consecutive simulation steps, then most of the information stored in the coordinate buffer from the previous rendering can be retained.</p><p>Initially, the sampling range for each pixel constitutes the full depth of the volume. After the first rendering, the effective sampling range for each pixel can be obtained and stored. At each subsequent time step, when the differential volume rendering algorithm extracts a changed data element from the differential file to compute the corresponding pixels, the 3D position of that data element can be compared with those computed pixels' effective sampling ranges stored in the coordinate buffer to decide if those ranges, i.e., the first-and last-hit voxel positions, need to be changed. If the changed element is located outside the specified ranges, then the stored information needs updating. The new sampling ranges can then be used to skip empty space while performing the ray castings and thus the rendering can be further accelerated. Sample Caching: During the ray casting, the local lighting calculation, which includes the trilinear interpolation and shading computation, constitutes the most expensive part of the process. <ref type="bibr">Ma et al. [13]</ref> proposed a sample caching technique which stores the interpolated data value and local shading information at each sample point along a ray. This allows users to interactively change mapping parameters, such as color and opacity, so that one only need to composite the cached information to update the image.</p><p>To apply the sample caching technique, initially the sampled value and lighting information at each sample point of a ray is saved. For a changed data element in the subsequent time step, only the sample points inside the surrounding regions of that new data element need to be resampled. The new sampled values are then used to update the sample cache. The correct position to insert or replace the new sampled result can be found from the corresponding pixel and the distance between the new data element and the image plane. After resampling the changed data elements and updating the sample cache, one needs to composite the new sample cache of the changed pixels to update the image. By combining this technique with our differential volume rendering algorithm, we can reduce the complexity of the sampling process and thus further accelerate the ray casting process.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Results and Discussion</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Regular Ray</head><p>Casting 100% 100% 100% 100% 100%</p><p>We have implemented our differential volume rendering on two sets of simulation data, one from a biomedical application and the other from a computational fluid dynamics application. All the comparisons below consist of the performances of our ray casting software with and without the differential rendering capability. The performance measurements were evaluated on a single 100 MHz MIPS R4000 processor. Note that the focus should be on the relative performances of the ray casting algorithms with and without differential capability instead of on any one technique's efficiency.</p><p>In the electrical wave propagation simulation, we attempted to simulate the electrical impulse conduction in the heart using an anatomically accurate cellular automation model. Simulation data consisted of the state histories of all the elements in the model over the duration of the simulation. Scientists were interested in following the activation wavefront and studying phenomena that facilitate, promote and/or terminate abnormal propagation. Appropriate colors and opacities were assigned to the different states when volume rendering was performed. Data is computed at each time step within 128 x 128 x 128 cubic elements. To test the differential rendering algorithms, we computed data at 100 time steps. For display we used a 256 x 256 image plane. <ref type="figure" target="#fig_4">Figure 3</ref> depicts the volume rendered images of the propagation of electrical activity within the heart.</p><p>In the computational fluid dynamics simulation  <ref type="figure" target="#fig_5">Figure 4</ref> shows the volume rendered images of the laminar flow propagation.</p><p>On the analysis of our simulation data, we noticed that a maximum of 4.77% of the elements in the electrical wave propagation simulation, and a maximumof 2.57% in the laminar flow simulation, changed states between time steps. Therefore, we could exploit the data coherency.</p><p>The disk space used by the 100 time steps of 128 x 128 x 128 volume data in the electrical wave propagation simulation was 2.10 M Bytes x 100 = 210 MB. Using the differential volume rendering algorithm, which only requires 2.08 MB for a differential file and 2.1 MB for the first time step of volume, we were able to save more than 95% in storage costs. In the laminar flow simulation, the disk space requirement was 4.09 MB for a differential file and 0.262 MB for the first 64 x 64 x 64 volume. The regular rendering algorithm for 130 time steps needed 0.262 MB x 130 = 34.06 MB. This amounts to a savings of 88%. <ref type="table">Table 1</ref> lists the average percentages of rays being cast both with and without use of the differential capability at different time steps of electrical wave propagation data. The algorithm without the differential capability always shot 100% of rays at any time step. That is, the alogirithm requires every pixel to fire a ray t o sample the volume data. In the differential ray casting method, after the first rendering which needs to cast 100% of rays to obtain the initial image, the subsequent 99 renderings cast rays only when necessary. This significantly reduced the number of rays cast. <ref type="table">Table 2</ref> shows the results for rendering the laminar flow propagation data.  <ref type="table">Table 2</ref>: Percentage of rays being cast at selected time steps for both regular and differential ray casting <ref type="table">Table 4</ref>: Rendering time(in seconds) at selected time steps using both the regular and the differential ray methods: laminar flow simulation.</p><p>casting algorithms: laminar flow simulation data <ref type="table" target="#tab_1">Table 3</ref>: Rendering time (in seconds) at selected time steps using both the regular and differential ray casting algorithms: electrical propagation simulationdata <ref type="table">Table 5</ref>: Rendering time (in seconds) for different amount of changed elements in a 64 x 64 x 64 volume lected time steps using our ray casting software both with and without adopting the differential capability.</p><p>The rendering time for the first image (time step 0) in the differential volume rendering was the same as that in the regular ray casting algorithm. However, for subsequent renderings, there was a significant reduction in rendering time. For the electrical wave propagation data, the average time to render 100 images without adopting the differential method was approximately 13.39 x 100 = 1339 seconds. Differential volume rendering achieved the same amount of rendering and same image quality in only 13.5 + 52 = 65.5 seconds. For the laminar flow simulation, the differential volume rendering method took 17.98 seconds to render 130 time steps. The rendering algotithm without the differential algorithm needed approximately 2.45 x 130 = 318.5 seconds. Our algorithm for rendering both sets of data achieved a savings of more than 90%.</p><p>To understand the limitations and robustness of the differential volume rendering algorithm, we used a 64 x 64 x 64 volume, 128 x 128 image plane and increased the number of changed elements at each time step. <ref type="table">Table 5</ref> lists the rendering times of our algorithm for different percentages of changed data elements. The experiment was designed such that the flow started propagating from one corner of the volume and eventually occupied 95% of the whole volume in 20 time steps. The number of changed elements increased as the propagation proceeded.</p><p>Except for the first rendering time, which was the same as that in the regular ray casting, the differential ray casting time at each time step was shorter than the regular ray casting time. Although our ray casting time remained smaller than the regular ray casting time, the pixel calculation time increased with the increasing number of changed elements. When the number of changed elements increased, the time of pixel calculation increased to the point of diminishing returns. From our experiments, when the percentage of changed elements was over 50%, the performance of the differential volume rendering method became worse than the regular ray casting method.</p><p>Although our algorithm has limitations when the number of changed elements exceeds 50%, for most flow visualization applications the number of changed elements during the propagation at each time step constitutes only a small fraction of the whole volume. Furthermore, these changed elements tend to cluster together. Therefore, differential volume rendering represents an attractive technique for scalar field flow visualization.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Summary</head><p>We have presented a differential volume rendering algorithm which exploits data coherency between consecutive time steps of data to achieve fast volume animation. This method can potentially save tremendous amounts of disk space and CPU time over existing methods. The algorithm begins by preprocessing the simulation data over time and extracting the differential information between sequential time steps. At each time step, the pixel locations from which new rays need to be cast can be calculated and the ray casting process is invoked to update the image. Our algorithm has been successfully applied to both biomedical and computation fluid dynamics applications. We are currently working on a parallel version of the algorithm.    </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Visualization Pipeline: Static Phase</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Figure1 illustrates the operations in the static phase. Visualization Pipeline: Dynamic Phase</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Animntioii of electrical wave propagation within the heart</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>tlriiination of laminar flow propagation (See color plates, page</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_1"><head>Table 3 and</head><label>3</label><figDesc>Table 4 list the average rendering time required for both simulations for a single image at se-[ Time I Changed I Regular Ray I Differential 1 Time Changed Regular Ray Diff. Ray Casting -</figDesc><table><row><cell></cell><cell></cell><cell>Casting</cell><cell cols="2">Step Elements</cell><cell>Casting</cell><cell cols="2">Time I Pct.</cell></row><row><cell></cell><cell>100%</cell><cell></cell><cell>0</cell><cell>100%</cell><cell>2.245</cell><cell cols="2">2.245 I 100%</cell></row><row><cell>1.82%</cell><cell>100%</cell><cell>3.48%</cell><cell>20</cell><cell>1.82%</cell><cell>2.245</cell><cell>0.23</cell><cell>10.24%</cell></row><row><cell cols="3">100% 120 I 0.005% I 100% I 0.15% 4.65% 100 I 0.04% I 100% I 0.32% 60 80 1.46% I 100% I 2.79% 0.20% I 100% I 1.44% '</cell><cell>40 60 80 100 120</cell><cell>2.45% 0.20% 0.04% 0.005% 1.46%</cell><cell>2.248 2.241 2.241 2.246 2.239</cell><cell>0.28 0.08 0.04 0.02 0.19</cell><cell>16.27% 3.56% 1.78% 0.89% 8.48%</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgments</head><p>This work was supported in part by the Whitaker Foundation. The authors would like to thank P. Gharpure for the heart wave propagation data, and K. Ma for his CFD simulation software. We would also like to thank Professors R. Yagel, J. Painter and K. Coles for their helpful comments and suggestions.</p><p>Furthermore, we appreciate access to facilities which are part of the NSF STC for Computer Graphics and Scientific Visualization.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A tool for visualizing the topology of three dimensional vector fields</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Globus</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Levit</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Lasinski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of VEs. &apos;91</title>
		<meeting>of VEs. &apos;91</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="1991" />
			<biblScope unit="page" from="33" to="40" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Virtual smoke: An interactive 3d flow visualization technique</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">J</forename><surname>Smith</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Vis. &apos;92</title>
		<meeting>of Vis. &apos;92</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="1992" />
			<biblScope unit="page" from="46" to="53" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<monogr>
		<title level="m" type="main">Volume Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<publisher>IEEE CS Press</publisher>
			<pubPlace>Los Alamitos, CA</pubPlace>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Visualizing wind velocities by advecting cloud textures</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Williams</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Vis. &apos;92</title>
		<meeting>of Vis. &apos;92</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="1992" />
			<biblScope unit="page" from="171" to="178" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Volume rendering of flow-visualization point data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><forename type="middle">G</forename><surname>Swann</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><forename type="middle">K</forename><surname>Semwal</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Vis. &apos;91</title>
		<meeting>of Vis. &apos;91</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="1991" />
			<biblScope unit="page" from="25" to="32" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Texture splats for 3d scalar and vector field visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Vis. &apos;93</title>
		<meeting>of Vis. &apos;93</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="261" to="265" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Flow volume for interactive vector field visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Max</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Becker</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Crawfis</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Vis. &apos;93</title>
		<meeting>of Vis. &apos;93</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="19" to="23" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">A 3d cellular automata model of the heart</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">P</forename><surname>Ghapure</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">R</forename><surname>Johnson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of 15th Annual IEEE EMBS Int. Conf. IEEE Press</title>
		<meeting>of 15th Annual IEEE EMBS Int. Conf. IEEE Press</meeting>
		<imprint>
			<date type="published" when="1993" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">A distributed algorithm for the three-dimensional compressible navier-stokes equations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K.-L</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Sikorski</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Transputer Res. and App</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Accelerating volume animation by space-leaping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Z</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. of Vis. &apos;93</title>
		<meeting>of Vis. &apos;93</meeting>
		<imprint>
			<publisher>IEEE CS Press</publisher>
			<date type="published" when="1993-10" />
			<biblScope unit="page" from="62" to="69" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Template-based volume viewing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of EUROGRAPH</title>
		<meeting>EUROGRAPH</meeting>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m">ICs &apos;92</title>
		<meeting><address><addrLine>Blackwell, Cambridge, England</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992-09" />
			<biblScope unit="page" from="153" to="157" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Volume seeds: A volume exploration technique</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><forename type="middle">L</forename><surname>Ma</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><forename type="middle">F</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">S</forename><surname>Painter</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">J. of Vis. and Comp. Anamation</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="page" from="135" to="140" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<monogr>
		<title level="m" type="main">Computer Gmphics: Principles and Pmctices</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Foley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">A</forename><surname>Van Dam</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1990" />
			<publisher>Addison-Wesley</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">Visualizing vector field topology in fluid flows</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><forename type="middle">L</forename><surname>Helman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">L</forename><surname>Hesselink</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Gmphics and Applications</title>
		<imprint>
			<biblScope unit="volume">11</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="36" to="46" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
