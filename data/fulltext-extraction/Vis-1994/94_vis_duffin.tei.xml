<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Spiders: A New User Interface for Rotation and Visualization of N-dimensional Point Sets</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kirk</forename><forename type="middle">L</forename><surname>Duffin</surname></persName>
							<affiliation key="aff0">
								<orgName type="institution">Brigham Young University</orgName>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">William</forename><forename type="middle">A</forename><surname>Barrett</surname></persName>
							<affiliation key="aff1">
								<orgName type="department">Brigham Young University</orgName>
							</affiliation>
						</author>
						<title level="a" type="main">Spiders: A New User Interface for Rotation and Visualization of N-dimensional Point Sets</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:30+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>discuss some of the implementation aspects of the al-W e present a new method f o r creating n-gorithm and present an implementation of an interacdimensional rotation matrices from manipulating the tive n-dimensional rotation interface that is free from projections of n-dimensional data coordinate azes hysteresis effects. Section 5 will demonstrate the maonto a viewing plane. A user interface f o r n-nipulation of two 5-dimensional data sets using the dimensional rotation is implemented, interface, and section 6 will point out some possible is shown to have no rotational hysteresis.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction 2 Background</head><p>Many techniques for visualizing n-dimensional data setiseparatethe data into its cokponent dimen-</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Notation</head><p>sions, allowing the user to look at various coordinate combinations in a way that hopefully brings understanding. These methods do well at avoiding the traditional projection to two dimensions that hides data. However the data relationships are not immediately intuitive to our brains, which are used to transforming large amounts of information from three dimensional In this paper we will hold to an extension of the notation used in most of the computer graphics literature: a ,,-dimensional point is represented by a ,,dimensional row vector and is post-multiplied by any transformation matrices. The vector composed of all except for a 1 in position i will be denoted projections down to two.</p><p>On the other hand, projection of n-dimensional information down to two may be slightly more intuitive, but suffers from the curse of data hiding due to projection. Moving the data in n-space, by predetermined motion or direct manipulation can help solve this problem.</p><p>Asimov's "grand tour" <ref type="bibr" target="#b0">[Asi85]</ref> made it possible to step through all possible projections of an ndimensional data set onto two dimensions in a useful manner. Hurley and Buja introduced a means of creating "guided tours" of the data by allowing the user to create two disparate projection plane orientations and interpolate between them[Hur88]. A good method of interpolation is to create a n-dimensional rotation between the two orientations and sample along the rotation angle <ref type="bibr">[BA86]</ref>. Subsequent data rotation tools, while similar, have retained this interpolation approach for creating smooth motion in the projected dataPR91, SC901.</p><p>Here we present a new technique for creating n-dimensional rotations from information projected onto the viewing plane. From this technique we develop an interface for interactively rotating ndimensional point sets. User control over the rotation sequence is fine enough that no direct interpolation between projections is needed. Section 2 will review some of the important principles from matrix algebra. Section 3 will develop the main algorithm for creating n-dimensional rotation matrices from manipulation of data projections in the viewing plane. Section 4 will</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Coordinate Frames</head><p>We represent a n-dimensional data set as a set of points in an n-dimensional Euclidian space R".</p><p>There are two ways of investigating the projection of a set of n-dimensional points onto a 2-dimensional viewing plane. In the first, the coordinate system of the data and the coordinate system of the viewing space coincide. A viewing plane is arbitrarily placed in the viewing space and the data is projected onto the plane. The second approach to projecting n-dimensional data onto a viewing plane moves the coordinate system of the data with respect to the coordinate system of the viewing space. In this latter approach the viewing plane remains fixed.</p><p>Because a rotation leaves the coordinate system origin invariant, it is possible to focus on the rotation as a transformation of a vector from the origin to the data point. This allows the creation of coordinate frames, a cluster of unit vectors that point down the positive principal axes of the underlying coordinate system.</p><p>Using coordinate frames gives us some powerful tools[Piq90]. If we start with an untransformed data coordinate frame, multiplying each axis vector e; in turn by the rotation matrix, it can be seen that the new position in view space of the axis is given by row i of the rotation matrix.</p><p>A corollary to this fact is that if we specify the new position of the axis vectors such that they remain orthonormal then the new positions define the rows of the rotation matrix' R.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.3">Orthogonal Projections in n Dimensions</head><p>We define the orthogonal projection of an n dimensional point onto a subspace of lower dimension xPr0j =</p><p>x . bi.</p><p>lActually, this is not quite true. The negation of a data axis is also allowed in this definition which corresponds to a reflection of the data about that axis. However, the algorithm presented here will not produce reflections.</p><p>occur. Moreover, by manipulating the projection of an axis, it is possible to rotate the axis in the rotation plane such that the axis remains consistent with its projection. <ref type="figure">Figure 1</ref> illustrates this observation for n = 3. <ref type="figure">Figure 1</ref>: A 3-dimensional coordinate frame before rotation (1) and after rotation (r). The rotation plane is defined by the rightmost data axis in each diagram and its projection. The circle at the bottom of each diagram shows the projection of the data coordinate axes onto the viewing plane.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Rotation in the Plane</head><p>The problem here is to rotate the selected axis xi by an unknown angle 0 to its new position xi. All that is known are the magnitudes of the projections of the axis.</p><p>Let xi be a unit vector representing the positive direction of the i-th axis of the data coordinate system embedded in the n-dimensional viewing coordinate system. The projection of xi onto the viewing plane is denoted xiproj. The position and projection of the axis after rotation are denoted xi and xipvoj respectively. See figure 2.</p><p>In the rotation plane, x; can be decomposed into two vectors, xippoj, and a component orthogonal to the viewing plane, xil such that xil =</p><p>xi -xipToj. These two vectors set up an orthogonal coordinate system in the rotation plane. Now xi can be represented by the coordinates (miproi, mi,) where miproj = ~lxiprojll and m i l = l l~i~l l .</p><p>Since Xi and xi are unit vectors, given m:proj, the magnitude of the new projected component can quently, the parameters for rotation in the plane are</p><formula xml:id="formula_0">be determined, namely mi, = J T 1 -mi . . Conse- T X.</formula><p>(3) (4) Thus any vector v in the plane can be rotated using the standard rotation equations</p><formula xml:id="formula_1">= x; . x i = mip,ojmiP70j + m;,mi, sine = llxi x xi11 = mjprOjm$, -mi,miproj.</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>More importantly,</head><p>To determine the n-dimensional rotation matrix RI all that remains is to find the new positions of each axis vector. This is accomplished by decomposing each data space coordinate axis vector into three components: a vector orthogonal to the rotation plane, and two vector components in the rotation plane. These last two vectors are the projection of the data axis vector onto Xipvoj and xi, respectively. The rotation is calculated for the rotation plane components and the results added to the orthogonal vector component. This gives the rotated position of the axis vector.</p><p>Let a and b be the coordinates of data axis xj projected onto the rotation plane, i.e.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>(7)</head><p>xj . xi,</p><formula xml:id="formula_2">b = xjprojxi, = - llxi, II '</formula><p>Let xjorih be the orthogonal component of xj with respect to the rotation plane. Then After rotation, the new position of the data axis vector x; can be expressed Substituting (9) into (10) and simplifying results in</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.2">Algorithm</head><p>The foregoing development gives us the following algorithm for creating an n-dimensional rotation matrix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Input:</head><p>Rthe current rotation matrix. The rows of this matrix are the axis vectors of the data coordinate system.  for (1 5 j 5 n)</p><formula xml:id="formula_3">sum t 0 for (1 5 t 5 2) a t sum/mproj sum t 0 for (1 5 t 5 n) b t s u m l m l sum + sum + rj azisc * vi aziat if (t # azisl and t # azisz) sum t sum + ric * rjl a * (cos -1) -b * sin b * (cos -1) + a * sin for (1 5 t 5 n) if (t = azisl or t = azis2) else r(il +-r j l + k l * ril r(il +-r j l + k2 * ric</formula><p>The simplified formulation of the main inner loop from (11) is justified by noting that if we limit the viewing plane to be one of the principal planes in the viewing coordinate system, then xiproj has nonzero components only along the axes specified by the viewing plane. Likewise, xi4 will always have 0 coordinates in those two dimensions.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Implementation</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Interface</head><p>We have used two approaches in applying the above formulas to the development of user interfaces for n-dimensional rotation. Each approach allows the user to select a data coordinate axis and drag the projected end of the axis in the viewing plane. From the path traversed in the viewing plane, a sequence of n-dimensional rotation matrices is created. The difference in the two approaches is in how the change in position of a selected projected axis is turned into a rotation matrix.</p><p>In the first approach R is composed of two rotations, the first occurs in the plane formed by axis xi and its projection</p><p>The amount of rotation is determined by the change in length of the projected axis. The second rotation occurs in the viewing plane and accounts for the change in projected orientation of xiproj. <ref type="figure" target="#fig_6">Figure 3</ref> illustrates for n = 3.</p><p>However, rotation in the projection plane provides no new visual information. In practice, the set of projected axes tends to spin wildly in the viewing plane. This in turn makes it difficult to adjust the relative positions of the projected axes.</p><p>The second approach to the creation of ndimensional rotation matrices also decomposes R into two rotations. The first rotation rotates the selected axis xi in the plane formed by itself and its original projection so that xi is perpendicular to the viewing plane. The second rotation rotates xi from its position perpendicular to the viewing plane to a position consistent with the projected position. <ref type="figure" target="#fig_7">(Figure 4)</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">Lack of Hysteresis</head><p>This latter approach to rotation possesses a nice theoretical quality. Now if a user selects an axis Xi at position (uo, vo) on the viewing plane and drags the projected axis around the viewing plane, then the rotation matrix of this transformation is the composition of the rotation matrices of every point on the path of the dragged projected axis in the viewing plane, i.e.  <ref type="figure">= (um, Vm)</ref> is the same, regardless of the path taken from (UO, uo) to (um, 0 , erty for interactive rotational interfaces for at least two reasons: First, the user can follow any path in the viewing plane when dragging a projected axis and be guaranteed of receiving the same rotation matrix, given the same start and end points of the drag. If . This lack of hysteresis is a high r y desirable prop-   the desired projected target is overshot or missed, the axis can be dragged back to the desired position. Secondly, the interface need not process every point in the path of the dragged projected axis in order to maintain consistent interface operation. If the data is being replotted as the axis is dragged, then a rotation matrix need be created only from the current viewing plane position. Any other positions traversed since the last plotting step can be discarded, giving a great computational savings if the data set is large.</p><p>The unit quaternions also share this lack of hysteresis, which has generated significant interest in their use in 3-dimensional rotation interfaces <ref type="bibr">[Sho92]</ref>. Now this property can be extended to n-dimensional rotations as well.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Orthonormality</head><p>As presented, this algorithm is highly dependent on the fact that the axis vectors are orthonormal. In practice, as numerical error creeps in, the rotation matrix R ceases to be orthogonal. This is a standard problem in 3-d interfaces where the rotation matrix is occasionally re-orthogonalized. Our experience has been that renormalizing the rows of the rotation matrix is sufficient to maintain orthogonality. Without renormalization, numerical error quickly dominates, making R useless.</p><p>Actually, nothing in the derivation of the algorithm depends on the mutual orthogonality of the coordinate axis vectors. Therefore, the algorithm given above will properly transform any set of vectors through a rotation specified by a n-dimensional vector and its projection. But in such a case, the resulting vectors can not be used to form the new ro-tation matrix.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Boundary Conditions</head><p>Because the algorithm decomposes every n-space vector into two rotation plane components, it is necessary that the axis xi that determines the rotation plane be distinct from its projection onto the viewing plane. Consequently, special measures must be taken when xi lies in the viewing plane or is perpendicular to the viewing plane. In practice, due to discretization error in the interface, conditions when xi is close to the viewing plane or close to the perpendicular must also be considered.</p><p>In our implementation, when an axis projection is dragged within a small distance of the center of the viewing plane, the axis snaps perpendicular to the viewing plane and stays there. When a user wishes to drag one axis (of possibly several) out of the space perpendicular to the viewing plane, she clicks the mouse on the center of the projected coordinate frame. A text menu offers a selection of the available perpendicular axes. After a selection is made, a point on the viewing plane is selected, and the axis is rotated out to this position. From there the axis can be dragged like any others visible on the viewing plane.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Application</head><p>In our work. in the Brigham Young University Computer Vision Laboratory we have implemented this interface to help visualize images and color gamuts as 5-dimensional point sets. Each pixel in a full color image is given five spatial coordinates: x, y, red, green, and blue. Each of these data points is also given a color corresponding to its red, green, and blue components. This is done for convenience only and is not necessary for the functioning of the interface. The mean of the data set is subtracted from all points so that rotation will occur about the center of the data set.</p><p>The orthogonal projection of the data set is kept separate from the rotational interface, which has acquired the appellation of a"spider." This is due to the appearance of many moving "legs" on the viewing plane when many coordinate axes are simultaneously visible.</p><p>Our combining the projected axes into one figure is in direct contrast to Hurley's data vtewer[HBSO], which assigns each axis its own interface item. Our experience seems to indicate that combining the axes into a single figure is acceptable when using relatively low dimension data sets. However, we have implemented the spiders with the facility to display an arbitrary subset of the full data axis complement. We have also used the powerful concept of linkin demonstrated by <ref type="bibr">Buja, McDonald, et al[BMMSSfi to</ref> link several spiders simultaneously to a single data set. <ref type="figure">Figure 5</ref> shows an image undergoing 5D rotation. At first only the x and y components are visible. Then the red axis is dragged out of the space perpendicular to the viewing plane. Because of the correspondence between the color attributes and the spatial coordinates, all of the points with high red values appear to move in the direction of the projected red axis. Note that as the red axis is brought out slightly, a pseudo 3D effect occurs. Next the green axis is dragged out and the x axis pushed back into the perpendicular space. Finally, the blue axis is brought out, the y axis pushed in, and the three remaining color axes arranged evenly in the projection plane. The points in the data set realign themselves into a pattern reminiscent of a color wheel.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>We have demonstrated a new method called "spiders" for interactively rotating n-dimensional point sets. The technique provides n-dimensional rotation matrices solely from information about the current data coordinate system and its projection onto the viewing plane. The interface has no rotational hysteresis, similar to the more robust 3D interfaces used today.</p><p>The spiders are not without problems. They do suffer from the "curse of projection" and data hiding with dense sets associated with all projective techniques. And like other visualization methods, as more dimensions are added to the system, the incremental return in understanding decreases. Nevertheless, we feel that the interactive nature of this technique provides a powerful tool to help understand the universe of data around us. <ref type="figure">Figure 6</ref>. An example of rotation of a 5D point set. Each point has spatial x, y, red, green, and blue components. Each point also has color assigned according to its red, green, and blue spatial components. In a) only the x and y components are manifest. In b) the red axis has been dragged down out of the space perpendicular to the viewing plane. Data points with high red components follow the motion of the projected red axis. In c) the green axis has been dragged out and the x axis pushed in. In d) both x and y axes are perpendicular to the viewing plane and the color axes are arranged symmetrically. The color wheel distribution of the data points mirrors the expectation of this projection. <ref type="figure" target="#fig_1">(See color plates, page CP-22.)</ref> </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>(the viewing subspace) as the point in the subspace closest to the data point. If b l . . . b,, m 5 n are basis vectors of the viewing subspace, then the projection xpr0j of a data point x is defined by</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 2 :</head><label>2</label><figDesc>Rotation in the plane defined by xi and its projection on the viewing plane. The data coordinate axis vector xi is rotated to xi.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head></head><label></label><figDesc>mprojthe current magnitude of the projected component of the selected data axis. m lthe current magnitude of the orthogonal component of the selected data axis. m : -the orthogonal component magnitude of the rotated data axis. cos, sinthe rotation parameters of the k.1 , k2, sum -# azisl and t # azisz) sum c sum + r;l m l = Jsvm my = 41miroj 2 Calculate projection plane parameters. cos t mproj * miroj + m l * my sin + mproj * mL -m l * mbroj Rotate each data space axis.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head></head><label></label><figDesc>Let the rotation of xi from its position on the viewing plane, xippoi = (uj, vj) to its new position xiproj = ( U j + l , v j + l ) be denoted jRj+l for any j. But this is the composition of two other matrices, j R j +~ = jPQj+l where jP is the rotation of xi to a position perpendicular to the viewing plane and Qj+l is the rotation of xi from the perpendicular space to its new position corresponding to xiproj.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>0%=</head><label></label><figDesc>OPQI 1 P Q 2 . . * j P Q j + l . * . m -l P Q m (12) for the path in the viewing plane of (uo,vo), ..., But rotating an axis perpendicular to the viewing plane and then rotating it back to the same position is an identity operation. This means that Qj jP = I. Thus dragging a projected axis with this method is a conservative operation. The rotation matrix resulting from dragging xiproj = (UO, v~) to its new position xiproj</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>2As</head><label></label><figDesc>long as the path does not pass through the projection of the origin of the data coordinate viewing system onto the viewing plane.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 3 :</head><label>3</label><figDesc>Repositioning a projected coordinate axis by 1) rotating for new projected coordinate axis length, and 2) rotating in the viewing plane for new projected coordinate axis orientation.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>Figure 4 :</head><label>4</label><figDesc>Repositioning a projected coordinate axis by 1) rotating axis perpendicular to viewing plane, and 2) rotating out of perpendicular space to new projected axis position.</figDesc></figure>
			<note xmlns="http://www.tei-c.org/ns/1.0" place="foot" n="1070">-2385194 $04.00 0 1994 IEEE</note>
		</body>
		<back>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">The grand tour: A tool for viewing multidimensional data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Asimov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">SIAM Journal on Scientific and Statistical Computing</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page">861</biblScope>
			<date type="published" when="1985-01" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Interactive data visualization using focusing and linking</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Buja</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Asimov</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 18th Symposium on the Interface</title>
		<editor>Andreas Buja, John Alan McDonald, John Michalak, and Werner Stuetzle</editor>
		<meeting>the 18th Symposium on the Interface</meeting>
		<imprint>
			<publisher>American Statistical Association</publisher>
			<date type="published" when="1986" />
			<biblScope unit="page" from="63" to="67" />
		</imprint>
	</monogr>
	<note>IEEE Conference on Visualization</note>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">American Statistical Association, 1988. A. Michael Noll. A computer technique for displaying n-dimensional hyperobjects</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Catherine</forename><surname>Hurley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Buja</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the 20th Symposium on the Interface</title>
		<meeting>the 20th Symposium on the Interface</meeting>
		<imprint>
			<publisher>AUgust</publisher>
			<date type="published" when="1967" />
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page">469473</biblScope>
		</imprint>
	</monogr>
	<note>Communications of the ACM</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Xgobi: A dynamic graphics program implemented in x with a link to s</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><forename type="middle">E</forename><surname>Pique</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the ZZnd Symposium on the Interface</title>
		<editor>Andrew S. Glassner</editor>
		<meeting>the ZZnd Symposium on the Interface</meeting>
		<imprint>
			<publisher>Academic Press</publisher>
			<date type="published" when="1990" />
			<biblScope unit="page" from="544" to="547" />
		</imprint>
	</monogr>
	<note>Graphics Gems</note>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Arcball: A user interface for specifying three-dimensional orientation using a mouse</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ken</forename><surname>Shoemake</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of Graphics Interface &apos;92</title>
		<meeting>Graphics Interface &apos;92</meeting>
		<imprint>
			<publisher>Morgan Kaufmann</publisher>
			<date type="published" when="1992" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">Visualizing structure in high-dimensional multivariate data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">W</forename><surname>Forrest</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Penny</forename><surname>Young</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Rheingans</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IBM Journal of Research and Development</title>
		<imprint>
			<biblScope unit="volume">35</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="156" to="163" />
			<date type="published" when="1991" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
