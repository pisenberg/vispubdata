<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Mix&amp;Match: A Construction Kit for Visualization</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Alex</forename><surname>Pang</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Baskin Center for Computer Engineering &amp; Information Sciences</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>95064</postCode>
									<settlement>Santa Cruz Santa Cruz</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Naim</forename><surname>Alper</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">Baskin Center for Computer Engineering &amp; Information Sciences</orgName>
								<orgName type="institution">University of California</orgName>
								<address>
									<postCode>95064</postCode>
									<settlement>Santa Cruz Santa Cruz</settlement>
									<region>CA</region>
									<country key="US">USA</country>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">Mix&amp;Match: A Construction Kit for Visualization</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:31+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<textClass>
				<keywords>
					<term>interactive</term>
					<term>extensible</term>
					<term>spray rendering</term>
					<term>smart particles</term>
					<term>visualization environment</term>
				</keywords>
			</textClass>
			<abstract>
				<p>W e present an environment in which users can interactively create different visualization methods. This modular and extensible environment encapsulates most of the existing visualization algorithms. Users can easily construct new visualization methods by combining simple, fine grain building blocks. These components operate on a local subset of the data and generally either look for target features o r produce visual objects. Intermediate compositions m a y also be used t o build more complex visualizations. This environment provides a foundation f o r building and exploring novel visualization methods.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>The diverse needs of scientists demand the development of general purpose, flexible and extensible visualization environments. Flexibility and extensibility are particularly important since no monolithic package can be expected to satisfy every need. Users often need variations on a particular technique and there are always new techniques being developed. In this paper, we present an environment for the flexible creation of visualization techniques from basic building blocks. Designing a technique involves identifying the tasks associated with target feature detection and behavioral responses for displaying those features. This process is simplified by the categorization of these tasks into different classes and the formalization of what constitutes a valid construction. A complete and valid construction defines a new visualization method. Each component of a construction is usually very simple and operates in a local subset of the data space. One of these components specifies which local subset of data to process next. Hence, we can think of these constructions as active processes that can be replicated and sent to work on different parts of the data. In fact, these processes embody particle systems that interact with the data they encounter. Other traditional algorithms can also be decomposed and reconstructed with similar components using this environment.</p><p>In the next section, we describe how our work differs from related work. We then describe the Spray Rendering framework and how MiztYMatch enriches it. This is followed by detailed description of the internals of MixtYMatch. Finally, we show a couple of constructions and their effects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>2</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Related Work</head><p>In the last few years the data flow paradigm has become popular in scientific visualization. Visualization environments such as <ref type="bibr">AVS [17]</ref>, Iris Explorer [15], <ref type="bibr">Khoros [12]</ref>, apE [3], and IBM Data Explorer [lo] offer many modules that perform filtering, mapping and rendering tasks that can be combined to achieve a desired visualization goal. These systems offer generality, flexibility, modularity and extensibility. They address the needs of novice, intermediate and expert users. Novices merely load and execute previously constructed networks. Intermediate users use a network editor to construct such a network from existing modules while expert users extend the system by adding modules.</p><p>All of these systems can be classified as large grain data flow systems. Data flow refers to the production and consumption of blocks of data as they flow through modules in a network. Modules are required to "fire" as new data arrive. The granularity refers to the size of the data block that the module processes. In these systems, it is the same size as the data model (hence large) rather than being an atomic element of the data <ref type="bibr">model [18]</ref>. Granularity may also refer to the size and complexity of the modules. Once again, in these systems they are lrzge in the sense that they implement complete algorithms (e.g. mapping or filter modules).</p><p>A drawback with this approach is that memory requirements become prohibitive and cause performance degradation when the data set and the network are large. Performance also suffers when there is a lot of interaction or when the data is dynamic and continually changing. Recently a fine grain data flow environment has been proposed to overcome some of these <ref type="bibr">problems [16]</ref>. In this approach, the algorithms are redesigned to work locally on incoming chunks of data where the chunks are a few slices. However, visualization algorithms that require random access to the data set, such as streamlines for flow visualization, are difficult to convert.</p><p>In spite of such shortcomings, these systems enjoy a large following mostly because of their flexibility and extensibility to meet new user demands. The importance of these qualities have been recognized in other work. In ConMan, users constructed networks for dynamically building and modifying graphics applications Our approach strives to maintain the extensibility and enhance the flexibility and interactivity of modular visualization environments a t the expense of some efficiency. Instead of modules grinding on entire data sets that flow through them, we send or assign light weight processes to work on a small subset of the data. Thus the two main differentiating points are the granularity of both the modules and size of working data set, and the execution style. Although the visualization of the whole of the data set would computationally be more expensive with this approach, the fine-grained nature of our components which work locally on parts of the data allow quick, interactive exploration. The components are conceptually simple and can be networked in a very flexible way to create more complex components. Because of our choice of execution style, large and dynamic data sets can be handled by localizing these visualization components only to regions of interest.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Spray Rendering</head><p>In this section, we briefly describe the Spray Rendering [ll] framework which we use for the construction and application of visualization methods using Mit&amp;Match. Spray Rendering uses the metaphor of spray cans filled with smart paint particles. These particles are sprayed or delivered into the data set to highlight features of interest. Features can be displayed in a variety of ways depending on how the paint particles have been defined. To get different visual effects, users simply choose different spray cans from a "shelf". The regions that are displayed depend primarily on the POsition and the direction of the spray can. Cans also have nozzles that can train the particles into a focused beam or distribute them across a wider swath. The number of paint particles and the distribution of these particles can also be varied.</p><p>The Sparts are born and have a finite life time. As they travel through the data space, they interact with the data, and perhaps among themselves, leaving behind them visual effects for the users. These particle behaviors can be roughly classified into two categories: targets and visual behaviors. Targets are features in the data set that the sparts are hunting for (e.g. isovalues, gradients, combination of two fields, etc.) while behaviors specify how sparts manifest themselves visually or non-visually (e.g. leaving a polygon or an invisible marker behind, attaching color attributes, etc.). Some of these effects can be seen in Figure 1. While sparts are conveniently portrayed to live in 3D space and handle 3D data sets, they can also be designed to operate in lower or higher dimensional space. For example, to track data values from a stationary sensor, one can imagine the spart as sitting on the sensor and producing glyphs (e.g. polylines)</p><p>according to changes in sensor readings. Or a spart can be called upon to handle time dependent flow fields where the spart is required to travel through time. Eventually, a spart may also map and travel through any N-parameter space. However, we still need to investigate this further since mapping parameter values to Euclidean space will generally produce scattered data sets. This also complicates the point location test for a spart.</p><p>In earlier implementations of Spray Rendering [ll], we mentioned the idea of mixing different targets and behaviors together to form new sparts. However, we only had predefined sparts in the sense that each spart on the shelf was a complete spart and could not be altered. It was evident that since these sparts shared some common characteristics, they could be decomposed into simpler components and reorganized almost arbitrarily. The next section discusses the issues and implementation details of how this is done.</p><p>Note that the idea of visualization processes composed of basic building blocks moving through data does not require spray cans as a launching pad. Indeed, we have a mode where the processes are executed at each grid location.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Mix&amp;Match</head><p>Here we analyze the structure and components of a spart and how they can be categorized. We then discuss the construction rules for building new sparts out of these components. We also address issues such as macro facilities, multi-stage spawning, handling multiple data sets simultaneously and efficiency.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">Building blocks of a spart</head><p>As can be seen in <ref type="figure" target="#fig_1">Figure 1</ref> each spart type produces a different visual effect. Sparts can be programmed to generate iso-surfaces; they can be asked to trace through flow fields and leave vector glyphs, ribbons or stream lines; or generate a quick-and-dirty volume rendering effect by mapping the data values to colored points or spheres. Thus, each spart can be regarded as a different visualization method.</p><p>The goal of this research is to provide users the capability to interactively create new visualization methods (or sparts). We achieve this by providing a construction kit, made up of an extensible list of spart building blocks, and allowing users to flexibly combine different pieces together.</p><p>As noted earlier, predefined sparts have two general types of components: target detection and behavioral expression. We can further refine this analysis by noting that sparts are based on particle systems. They therefore have rules regarding when they are born and when they die. In addition, since these sparts are to be sent into the data space, they also have position update rules that may be different from those found in behavioral animation (collision avoidance, group centering, etc.). We have grouped these spart components into four categories:</p><p>1. Targets. These are feature detection components. They operate on the data locally and check to see whether a boolean condition is satisfied. Components in this category may include local pre-processing operations such as smoothing or gradient operators but not global ones such as Fourier transforms. Relational operators, such as And/or, are also implemented as target functions and can be used to combine any functions that output a boolean. These are components that depend on a boolean condition, usually a target being satisfied, and may produce abstract visualization objects (AVOS) to be rendered. 3 . Position update. These are components that update the current position of a spart. For example, position changes may depend on the initial spray direction or may be dictated by a flow field. 4. Bidh/Death. These components decide whether the spart should die or spawn new sparts. For example, a spart may be terminated as soon as a target is found or wait until it has exited the data space.  shows a growing list of components under each category. Each element in the list is a building block that can be used in the creation of a spart. By breaking down the spart into components, we allow the components to be used in the rapid prototyping of other sparts.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.">Behaviors.</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>I I</head><p>Each building block in the construction kit is a regular C function with variable number and type of inputs and outputs. The input and output ports can be connected together interactively. There is strong type checking at the 1/0 connectivity but no type coercion. Apart from the number and types of inputs and outputs, components may also have parameters that can be set by the user through widgets (e.g. threshold value, step size, etc). A spart is therefore a set of functions grouped together to carry out a specific visualization method.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>4.2</head><p>Putting them together LELJ The process of creating the spart corresponding to a visualization method can be seen as the mixing of different pigments on a palette to obtain a desired color. In this analogy, the building blocks are the pigments. We call this process of mixing different building blocks to obtain a desired visual effect Mztt3Malch. The rules for putting the building blocks together are quite simple. The basic pattern follows the typical operations over the lifetime of a spart as illustrated in <ref type="figure" target="#fig_4">Figure 3</ref>. Note that <ref type="figure" target="#fig_4">Figure 3</ref> is merely illustrative. For instance, there may be sparts that do not have a target function and whose behavior function executes unconditionally, or there may be death functions that depend on multiple conditions.</p><p>We provide both a textual and a graphical interface to the process of composing a spart and users can switch freely between the two. Spart construction starts with the selection of components to be included in the editor from the components browser <ref type="figure" target="#fig_2">(Figure 2)</ref>. As building blocks are included in the construction, users must manipulate the input and output fields of each component to establish connections. In the textual interface, this is done by editing the inputs and outputs such that a name given to an output field of a component and the input field of another component indicates a connection between them. In the graphical editor <ref type="figure" target="#fig_5">(Figure 4)</ref>, one merely selects the input and output names from the menus of the components in question. We have avoided the use of a programming language for the definition of a spart to make the task simpler for the scientist. Before enumerating the rules for constructing a spart, let us look at how a common visualization method can be expressed in the form of a spart as it would appear in the textual spart editor. The Marching Cubes algorithm [9] can be converted to a localized spart construction using three building blocks as illustrated below. Instead of looking at every cell in the volume, individual sparts handle a local subset of the data. In this particular example, it would be those cells that the spart visited as it travels through the data space.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Iso-surface spurt:</head><formula xml:id="formula_0">IsoThresh C S1 1 ( Found ) ( Tag 1 ( IsoVal 1 IsoSnrf C S 1 1 [: Found I c Tag I C IsoVal 1 ( Obj 1 RegStep C Si 1</formula><p>The above construction consists of a target function IsoThresh, a behavior function IsoSurf, and a position update function RegStep. The Streams component <ref type="figure" target="#fig_5">(Figure 4)</ref> exists in all networks for binding data streams to the input ports of the other components. There is also a default death function that kills the sparts once they exit the bounding box of the data set.</p><p>Input fields are identified with [ ] while output fields are identified with ( ). IsoThresh is a simple function that examines the cell the spart is in within the input stream SI. It sets the boolean Found if there exists a surface at the given iso-value. In this case, IsoSurf will generate one or more polygon visualization objects Obj in that cell. The spart then advances a fixed step size according to the parameter set in RegStep. These functions are repeated until the spart is terminated after exiting the bounding box of the data volume.</p><p>The power of MixtYMatch becomes evident when the user has the flexibility of modifying sparts to produce different effects. For example, in the construction above, the death function could be made conditional on an iso-surface being found. This slight modification will produce iso-surfaces that are visible only from the spray can's perspective. The position update function may be modified to follow surface gradients. Likewise, the behavior function may be substituted with one that paints the entire cell achieving a cuberille effect <ref type="bibr">[6]</ref>.</p><p>For some sparts it may be undesirable to rely on position update and death functions that sample the data. In the example above, cells that are missed will not produce polygons and may result in discontinuous surfaces. For this reason, we provide a mode where the spart visits all the cells and only the target and behavior functions are executed.</p><p>There are a few simple rules for constructing sparts which are enforced either during construction or during parsing:</p><p>Strong typing. The types of the input and output fields of a connection must match. Type checking is done a t the time the connection is being established in the graphical editor and is postponed until parsing time in the textual editor. No optional inputs. All function input fields must either be connected to an output field or have a constant value associated with it. Output fields can be left floating. Fan out but no fan in. There can only be a single connection into an input field. The same output field can be connected to multiple input fields however. Acyclic graph. A directed graph where the edges denote the dependency between components has to be acyclic.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">. Execution order.</head><p>The components of a spart execute according to a specific order: target functions first, then behavior functions, position update functions and finally birthldeath functions. Topological sorting ensures correct dependency ordering within each category. However, a component from a category that will execute earlier should not depend on another component that will execute later. The environment also provides a macro facility t o build a component from a collection of other components allowing more succinct compositions. The macros can be nested and more than one macro can appear in a composition. Note that macros are like procedures and can be saved and used in compositions. They are not merely a temporary visual grouping of components.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Handling multi-parameter data sets</head><p>A spart can handle multi-parameter data sets. Each parameter of a multiple parameter data set is treated as a separate data stream. The spart composition then contains separate components to handle different data streams individually. The stream identifiers, e.g. SI, saved with the spart composition are bound by the user to the actual data streams at the time the spart is loaded into a can. When two different streams appear as input in the composition, it may mean that they are the two parameters of a data set with the same bounding volume, or two different data sets with different bounding volumes. The latter implies that there may be multiple incarnations of the spart, one in each stream. An incarnation in one stream may be dead but another may still be alive and the spart will continue executing its program until all incarnations are dead. This allows us to look for relationships between parameters of the same data set or between parameters in different data sets that have overlapping bounding volumes.</p><p>Relational expressions used in combining different targets, whether from the same data stream or not, are also implemented as target functions. For example, if the target functions TargetA and TargetB have boolean outputs A and B, they could be combined as follows:</p><formula xml:id="formula_1">TargatA ... ( A ... TargetB ... ( B 1 ...</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>AndCA1 C B I (AmdB)</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">Multi-stage spawning</head><p>Sparts are initially spawned as they are sprayed from the cans. Each time the user sprays or holds the spray button down, sparts are continually being spawned and added to the can's pool of sparts to be executed. These sparts are eventually executed and terminate when they have satisfied the death function.</p><p>New sparts may also be spawned during the life span of a spart. This is achieved by including a spawn function in the construction. The spawn function takes the name of the spart to be spawned as an argument. The new spart does not have to be the same as the parent spart. The spawn function is handy in certain situations. For instance, new sparts may be spawned in the vicinity where iso-surface sparts have located a surface. This will fill in the surface more quickly than relying on the spraying marksmanship of the user.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Extensibility</head><p>One advantage of MidYMalch over other systems is the relative ease of writing small fine-grained functions that perform very specific tasks (e.g. update position in certain way or produce certain AVOs). In comparison, coarse-grained modules are typically larger and also have some degree of code replication since some modules may be very similar in certain tasks but differ on details.</p><p>Extending the functionality of the environment involves adding more functions to the browser. New functions must be registered so that they can be included in the browser. A configuration manager provides a graphical user interface for this task. The user defines the number and types of the inputs and outputs and graphically designs the control widgets for the component. The configuration manager then generates appropriate wrapper code. The new component is integrated into the system by compilation and linking.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">Efficiency and object compaction</head><p>There is a tradeoff between flexibility and efficiency. If components exist at a low level, there is greater flexibility in composition but one suffers higher costs in execution overhead. Inversely, a high level component results in loss of flexibility. At the cost of code replication and program size, one can include both the high level module and its components. At the extreme, one could have the spart be a single module. We call these predefined sparts. If a certain spart is to be used often it may be worth the effort to re-implement it as a predefined spart.</p><p>The building blocks are written independently from each other and hence have to determine at run time where to find the inputs and the parameters they need and where to send the outputs. This is handled by the components looking for their inputs and parameters from fixed places in their own structure. During parsing, memory is allocated for the addresses of input and output fields of each component. These addresses are filled according to the connections in the composition. All that the function does when called is to dereference the pointers from the component structure passed to it. Multiple instances can thus coexist in a composition.</p><p>The main reason for the cost in execution is not so much the extra function calls and pointer dereferences but the fact that those functions that produce AVOs have to generate them at each call that satisfies the target function. For instance, a predefined streamline spart would accumulate vertices that define a single multi-segmented line object (polyline). A Mzt&amp;Malch streamline spart, on the other hand, would define a simple line segment consisting of the present and the previous vertex each time it is called. This causes inefficiency both in execution (many more calls to malloc) and in storage (inner vertices are replicated). The rendering time also suffers because of the greater number of AVOs generated that need to be traversed. To alleviate the latter problem, objects of similar attributes are compacted periodically into a single object. In the above example, all the simple line segment objects would be compacted into a single polyline object.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>5</head></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Examples</head><p>In this section, we give some examples of spart compositions. By changing single lines of these compositions, different visualizations can be achieved. Users can experiment with the different compositions and save those that they are likely to use again.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.1">Flow visualization</head><p>Showing streamlines is a typical flow visualization method for displaying vector fields <ref type="figure" target="#fig_6">(Figure 5 )</ref> . In this technique, the path of a massless particle through the flow field is traced assuming that the vector at the current location is tangential to the path. The new position is calculated by forward integration using the vector at the current location. Such a spart can be constructed as follows: This is a spart without a target function. The first component is a behavior function that unconditionally outputs objects while the position update function VecForwInteg calculates the new position. The first component also outputs the calculated vector a t the current location so that it can be used by the following component. It is a good idea to pass intermediate values that may require expensive computation so that other components can use them without recomputation.</p><formula xml:id="formula_2">Streamline spart: StreamLine C Sl] [ =TRUE 1 ( Vec 1 ( Obj 1 VecForvInteg [ S1 1 [ Vec ]</formula><p>Another technique for vector field visualization is to use vector glyphs. Usually, the glyphs are placed at some sub-sampling of the grid but in spray rendering, we can place them at intervals along the path of the spart. By replacing the behavior function in the composition above with a behavior function that produces vector glyphs, we can place glyphs at intervals along a streamline. Alternatively, we can include both behavior functions and obtain streamlines and glyphs along the streamline.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5.2">Iso-surfaces</head><p>We can make some minor variations to the isosurface spart described in section 4.2. For example, we can combine two or more iso-surface seeking sparts within one construction. The target functions may be bound to the same input stream (i.e. looking for different iso-values) or they may be bound to different input streams. The target function of the iso-surface spart can be used in a spart that does not actually generate an iso-surface, but merely uses this component as a filtering operation. Another behavior that takes in a geometry(the iso-surface) as input and colors it according to a stream value can be used to investigate a relationship between two parameters of a data set by showing the variation of one parameter over a surface on which the other parameter is constant as in <ref type="bibr">[4]</ref>. The following composition illustrates these ideas:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusions</head><p>MixtYMatch is an extension to Spray Rendering which allows composition of visualization techniques from simple, fine grain building blocks. Unlike the predefined sparts presented in our earlier work, the MixEfMatch sparts are made up of elementary components and users are allowed t o edit them by adding, removing or changing different components with the aid of a textual or graphical spart editor. This capability encourages the users to experiment with different ways of visualizing their data. In contrast t o data flow networks, the execution model used here sends multiple independent agents to different localities of the data space. Its strengths are its extensibility and the fact that users can create their own visualization methods interactively. On the other hand, its weaknesses are primarily efficiency and the duplication of effort by multiple sparts that enter the same data space.</p><p>The current work opens up the proverbial Pandora's box. There are many issues that need to be resolved to fully exploit the capabilities of sparts. Among these are the traversal through unstructured grids and scattered data, mapping t o parallel architectures, interspart communication and letting sparts query scientific databases. Whether our approach offers advantages in massively parallel environments is something that we will be investigating in the near term.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>[5]. Abram and Whitted used an interactive network based system for constructing shaders from building blocks [l]. Kass used an interactive data flow programming environment to tackle many computer graphics problems [7]. Corrie and Mackerras recently extended the Renderman shading language to provide a modular and extensible volume rendering system based on programmable data shaders [2].</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>Figure 1 :</head><label>1</label><figDesc>Spray Rendering workspace showing effects of different types of smart particles (spurts). Users control viewing and spraying through either graphics window. T h e lower left graphics window shows the view from the current can.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>Components browser showing the list of functions categorized under targets, behaviors (visuals], position update and death functions.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Figure 2</head><label>2</label><figDesc>Figure 2 shows a growing list of components under each category. Each element in the list is a building block that can be used in the creation of a spart. By</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 3 :</head><label>3</label><figDesc>Flow chart illustrating the life-time o f a typical spart.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 4 :</head><label>4</label><figDesc>T h e graphical spart editor showing the iso-surface spart composition. T h e IsoSurf component is shown expanded to reveal the types and the status of connections. Circles indicate connections o f the fields while colors of the triangles represent the types of the fields.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 5 :</head><label>5</label><figDesc>A spart that generates streamlines from a vector field. Iso-surfaces from a scalar field are also shown in the background.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" type="table" xml:id="tab_0"><head>of boids in [14] and [8].</head><label></label><figDesc></figDesc><table><row><cell>key ingredient of Spray Rendering are the smart</cell></row><row><cell>particles or spurts. These sparts are reminiscent of the</cell></row><row><cell>Particle Systems introduced by Reeves [13] but also</cell></row><row><cell>possess some of the features</cell></row></table><note></note></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Acknowledgements</head><p>We would like to thank the other members of the spray team: Jeff Furman, Tom Goodman, Elijah Saxon, and Craig Wittenbrink. We would also like t o thank Dr. Teddy Holt and Dr. Paul Hirschberg for kindly providing us the meteorological data sets used in the figures. Support for this work is partly funded by NSF grant CDA-9115268 and ONR grant N00014-92-5-1807.</p></div>
			</div>

			<div type="annex">
<div xmlns="http://www.tei-c.org/ns/1.0"><p>A spart with four streams:</p><p>In this example, an iso-surface is created based on one stream (S1:geopotential height) and the values of another stream (S2:humidity) are mapped onto the generated surface as color.</p><p>A third stream (S3:temperature) is filtered based on a threshold value (S4:wind field) and vector glyphs are placed at those locations that satisfy this condition. An iso-surface is generated from the geopotential height field and the relative humidity is mapped onto this surface. T h e temperature field is thresholded and wind vectors placed a t the locations that would have produced an isosurface. <ref type="figure">(See color plates, page CP-34.)</ref> </p></div>			</div>
			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Building block shaders</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gregory</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Turner</forename><surname>Abram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Whitted</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics (ACM SIGGRA PH Proceedings)</title>
		<imprint>
			<biblScope unit="volume">24</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="283" to="288" />
			<date type="published" when="1990-08" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Data shaders</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Brian</forename><surname>Corrie</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><surname>Mackerras</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings: Visualization &apos;93</title>
		<meeting>Visualization &apos;93</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="275" to="282" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">A dataflow toolkit for visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">S</forename><surname>Dyer</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">10</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="60" to="69" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Multi-valued volumetric visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><forename type="middle">A</forename><surname>Foley</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><forename type="middle">A</forename><surname>Lane</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings: Visualization &apos;91</title>
		<meeting>Visualization &apos;91</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1991" />
			<biblScope unit="page" from="218" to="225" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Three-dimensional display of human organs from computer tomograms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><forename type="middle">E</forename><surname>Haeberli</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">K</forename><surname>Herman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Liu</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics (ACM Siggraph Proceedings)</title>
		<imprint>
			<biblScope unit="volume">22</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="1" to="21" />
			<date type="published" when="1979" />
		</imprint>
	</monogr>
	<note>Computer Graphics and Image Processing</note>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">CONDOR: Constraint-based dataflow</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Kass</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics (ACM SIGGRAPH Proceedings</title>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Marching cubes: A high resolution 3D surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Kerlick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings: Visualization &apos;90</title>
		<editor>W. E. Lorensen and H. E. Cline</editor>
		<meeting>Visualization &apos;90</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1987" />
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="page" from="163" to="169" />
		</imprint>
	</monogr>
	<note>Moving iconic objects in scientific visualization</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Alex Pang and Kyle Smith. Spray rendering: Visualization using smart particles</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Lucas</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">G</forename><surname>Abram</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">N</forename><surname>Collins</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Epstein</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Gresh</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">K</forename><surname>Mcauliffe</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings: Visualization &apos;92</title>
		<meeting>Visualization &apos;92</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1992" />
			<biblScope unit="page" from="283" to="290" />
		</imprint>
	</monogr>
	<note>Proceedings: Visualization &apos;93</note>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Particle systems: A technique for modeling a class of fuzzy objects. Computer Graphics, C. W. Reynolds. Flocks, herds and schools: A distributed behavioral model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rasure</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">D</forename><surname>Argiro</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>Sauer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">T</forename><surname>Williams ; W</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Reeves</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics, G. Sloane. IRIS Explorer Module Writer&apos;s Guide. Silicon Graphics</title>
		<imprint>
			<biblScope unit="volume">2</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="7" to="1369" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
	<note>International Journal of Imaging Systems and Technology</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Fine-grain visualization algorithms in dataflow environments</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Deyang</forename><surname>Song</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eric</forename><surname>Golin</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings: Visualization &apos;93</title>
		<meeting>Visualization &apos;93</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="126" to="133" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">The application visualization system: A computational environment for scientific visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Upson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="30" to="42" />
			<date type="published" when="1989" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">The state of the art of visual languages for visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Williams</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">J</forename><surname>Rasure</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Hansen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings: Visualization &apos;92</title>
		<meeting>Visualization &apos;92</meeting>
		<imprint>
			<publisher>IEEE Computer Society</publisher>
			<date type="published" when="1983" />
			<biblScope unit="volume">26</biblScope>
			<biblScope unit="page" from="25" to="34" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
