<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">Fast Surface Rendering from Raster Data by Voxel Traversal Using Chessboard Distance</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<title level="a" type="main">Fast Surface Rendering from Raster Data by Voxel Traversal Using Chessboard Distance</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:31+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>The increasing distinguishing capability of tomographic and other 3 0 scanners as well as the new voxelization algorithms place new demands on visualization techniques aimed at interactivity and rendition quality. Among others, triangulation on a subvoxel level based on the marching cube algorithm has gained popularity in recent years. Howevel; without graphics hardware support, rendering many small triangles could be awkward. We present a surface rendering approach based on ray tracing of segmented volumetric data. We show that if a proper interpolation scheme and voxel traversal algorithm are used high quality images can be obtained within an acceptable time and without hardware support.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Introduction</head><p>During the last decades we have encountered an immense boom in the development of computing machinery, which has enabled us, among others, to generate and manipulate large matrices of three and even higher dimensional data. The data results either from of some simulation processes (e.g. gas flow simulation) or is the product of various types of 3D scanners, which have found an important place, e.g. in medical diagnostics (Cl", MR, PET scanners).</p><p>Caused by the increased resolving ability of the scanners, the quality of the final 3D reconstruction of the data comes into prominence. An inevitable condition for the visualization of details, comparable with the voxel size is the application of an algorithm that enables us to define the surface of the scanned object with subvoxel precision.</p><p>This development has resulted in a large number of visualization techniques, among which triangulation on a voxel level has gained popularity <ref type="bibr">[ll]</ref>. Its basic idea is to approximate the object surface within a space, defined by eight neighboring data samples (cell) by up to four triangles, resulting in a surface model that can be rendered by standard tools. The continuous nature of this model enables us to render the object in various scales without danger of blocky artifacts caused by the limited sampling frequency of the scanner. The large number of triangles, typically 105-106, causes no problems when rendering through some hardware renderer. On the other hand, in spite of the rapidly decreasing hardware prices, many laboratories still exist with no access to such engines. In this case, rendering a big amount of primitives can become very awkward.</p><p>Another drawback of the surface model approach is the separation of the surface from the volume data (original samples) processing. Many of applications exist (e.g. in medical diagnostics), where just the combined data representation is important <ref type="bibr" target="#b5">[6]</ref> and can grant the operator deeper insight into the problem.</p><p>Direct visualization techniques omitting the intermediate surface model represent an alternative, which can overcome the two aforementioned drawbacks of the surface model approach. Traditionally, they split into two categories: volume rendering and surface rendering. The first one represents a class of methods, where all scene voxels contribute to the resulting image by means of color compositing. Since no binary decisions between object and background are done, these approaches are claimed to be suitable for rendering weak surfaces and thin structures too. However, interpretation of such images can often lead to difficulties.</p><p>The surface rendering approach lies half way between the surface model and volume rendering techniques. Its prerequisite is an object mask, obtained from the original gray level scene by some kind of segmentation. Only the boundary mask voxels contribute to the final image by means of a color value derived from the local properties and a chosen shading model. Ray tracing can be used to solve the visibility problem and to enhance the 3D perception by simulating highlights, shades, reflection and refraction.</p><p>In this paper, we would like to present a direct approach to the visualization of volumetric data based on ray tracing, with no intermediate surface model. We shall show, that if a suitable interpolation scheme and a voxel traversal algorithm are used, high quality renditions can be achieved with the possibility to magnify details within a reasonable time, and without hardware support.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.1">Ray tracing</head><p>Ray tracing has been established in the last decades as a tool for high quality rendering. Its main drawback is the high computational cost, which can be, among others, overcome by space subdivision techniques. The scene is subdivided, either uniformly or hierarchically, into voxels, containing only fractions of the objects. To reduce the number of necessary ray-object intersection tests, only the voxels pierced by a given ray are inspected. Various voxel traversal algorithms solving this task were proposed <ref type="bibr">[4,</ref> 1, 3, 81. An experiment has shown <ref type="bibr">[l]</ref>, that the optimal subdivision rate is relatively low, resulting only in a few thousands of voxels.</p><p>Scanned or simulated volumetric data sets are usually represented in a similar form, as a 3D raster. The difference is in the typical size (106-107 voxels) and in the fact, that we have only one kind of object, the voxel itself. The value assigned to the voxel represents a density of some measured or simulated primary parametric field. Ray tracing (or its simplified form ray casting) was used for the implementation of volume <ref type="bibr" target="#b8">[9]</ref> and surface rendering of either scanned <ref type="bibr" target="#b12">[13]</ref> or voxelized data <ref type="bibr" target="#b18">[19,</ref><ref type="bibr">18]</ref>. In the surface rendering case it is necessary to introduce some interpolation scheme for the precise detection of the ray-surface intersection point.</p><p>In order to obtain high quality renditions in an acceptable time, the voxel traversal algorithm should have the following properties: </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1.2">Previous work ization can be categorized as</head><p>The voxel traversal algorithms used in volume visual-1. continuous ray generators (floating point 3D DDA), which define the ray as a sequence of usually equidistant points on a line. Due to its algorithmic simplicity, it was used by more authors [9, 141. However, it is not possible to apply any of the ray connectivity criteria <ref type="bibr" target="#b7">[8]</ref> to the sequence of voxels thus defined, and the ray can skip some important voxels. This is usually overcome by increasing the point density, which degrades the algorithm performance.</p><p>2. discrete ray generators, which generate the sequence of voxels pierced by a ray directly.</p><p>In the latter category we can further distinguish integer based algorithms, which assume that the ray has start and end points with integer coordinates <ref type="bibr" target="#b7">[8]</ref> and algorithms enabling arbitrary start point and direction [l, 31. Not all voxels contribute to the rendered image with the same weight. Only some of them belon to the interresting objects, while the others can be traversedgrapidly or even totally skipped. This capability is called space-leaping <ref type="bibr">[18]</ref>.</p><p>The idea to switch between the lower precision but faster 26-connected line generator in the background region and the precise 6-connected one in the object vicinity was introduced in <ref type="bibr" target="#b18">[19]</ref>. Another popular approach for fast empt space leaping is based on hierarchical subdivision <ref type="bibr">[</ref></p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>lo, IS{</head><p>Digital distance transforms were used in <ref type="bibr" target="#b20">[21]</ref> to speed up the floating point 3D DDA algorithm as well as in <ref type="bibr" target="#b6">[7]</ref> for 26-connected ray templates traversal. Coherency between consecutive images was used for minimizing the background leaping time in <ref type="bibr" target="#b4">[5,</ref><ref type="bibr" target="#b19">20]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">Surface rendering of raster data</head><p>It is necessary to define some kind of interpolation surface that is at least CO continuous across the voxel boundaries, in order to detect the object surface with subvoxel precision. The exact surface point should be then searched for as an intersection of the ray with that surface. This task splits into two parts:</p><p>1. finding the voxel, where the ray-surface intersection can be found, i.e. the discrete scene traversal, and 2. exact computation of the intersection position within the voxel.</p><p>First, we shall deal with the suitable surface interpolation and the exact ray-surface intersection computation and then with the scene traversal.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.1">Definitions</head><p>Let the 3D image P be a set of K</p><formula xml:id="formula_0">x L x M values,</formula><p>representing samples of some measured property in the vertices of a regular unit grid:</p><formula xml:id="formula_1">P = { p i j k E'R : O &lt; i &lt; K , O 5 j &lt; L,O&lt; k &lt; M } ,</formula><p>where i, j and k are integers. Let us segment P into n subsets UI, such that</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>U u 1 = P A I I</head><p>Let ul be the lth object and 1 its identifier. Let Z = { O , l , . . .n -1) be a set of object identifiers and let I E Z.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The binary image B is the set</head><p>We can assume without any loss of generality, that border values of B, i.e. those, for which at least one coordinate</p><formula xml:id="formula_2">i, j or k is either equal 0 or K -1, L -1 and M -1</formula><p>respectively, belong to the Oth object.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>Let voxel be a tuple K j k = ( v i j k , h i j k )</head><p>, The voxel value depends on the binary image 13 and on the choice of the surface approximation. We denote voxels with values equal to 0 (resp. 1) 0-voxels (resp. 1-voxels).</p><formula xml:id="formula_3">where v j j k =&lt; i , i + 1)x &lt; j , j + l ) x &lt; k, k + 1)</formula><p>We denote the set of oints </p><formula xml:id="formula_4">D = {[i, j , k] : 0 5 i &lt; p , 0 5 j &lt; q , 0 &lt; k &lt; r f</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.2">Surface point definition by ray tracing</head><p>Let the surface sl'jk of the object UI be defined within the volume of v j k by means of an interpolating function FI and the threshold value tl:</p><p>The u i j k represent values p j j k or b i j k in some neighborhood of a voxel K j k . We speak of gray level interpolating function if p i j k values are used and we suppose, that the object 1 was segmented by thresholding with a threshold tl.</p><p>In the case of some other segmentation method we use the values b i j k in such a way that to samples b i j k = 1 we assign value 1 and to samples with b i j k # 1 we assign value 0. In this case we speak about binary interpolating function and we use value tl = 0.5 for all objects as the threshold.</p><p>We get the exact position of the ray-object surface intersection by solving the system of equations:</p><formula xml:id="formula_5">X = A + t Z Fl(z, Y, z , u i j k ) = t l ,<label>(1)</label></formula><p>where A is the eye position and iiis the ray direction vector.</p><p>It may happen that a voxel is intersected by the surfaces of more than one object. In this case, it is necessary to compute the intersections with all of them and to take the nearest to the eye point into consideration.</p><p>In the following we shall describe some possibilities for the definition of the function FI in dependency of q j k .</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">3 0-order interpolation in the center representation</head><p>We shall use this kind of interpolation for faster, less precise rendering of the 3D image. Let us define FI within the voxel volume as which means that the binary interpolating function is constant within the voxel volume. The voxel value h i j k is in this case initialized by min(1, b i j k ) <ref type="figure">(Figure la)</ref>. To detect the surface by ray tracing means to find the first voxel of the ray with a nonzero value without further intersection computation.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.4">Wlinear interpolation in the center representation</head><p>The trilinear interpolation function is defined as  <ref type="figure" target="#fig_5">o , v 1 , .</ref> . . , v7 must be computed as a mean over those voxels sharing the given vertex. This approach gives smooth surfaces due to the mean computation. It has been observed that such surfaces can be shifted into the object, which may completely "smooth out" object details comparable with the voxel size.</p><formula xml:id="formula_6">ues v</formula><p>Another consequence is that the surface can be detected not only within object voxels but also within background voxels in their vicinity. Therefore, in this case, we shall assign the value 0 only to those background voxels of the scene Sc, which are not 26-adjacent to an object voxel. To all other voxels we shall assign 1 <ref type="figure">(Figure lb)</ref>.</p><p>We shall prefer this kind of interpolation, due to its smoothing ability, for objects segmented by some other method as the thresholding.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2.5">Wlinear interpolation in the vertex representation</head><p>The interpolating function is in this case defined as in the previous section, with the exception that the values vo, v1, . . . , v7 are directly given by samples S i j k . . . &amp; + 1 j + l k + l positioned in the voxel vertices. We assign value 0 to background voxels and 1 to foreground voxels. This kind of interpolation is suitable for scenes with details on a voxel level.</p><p>Of course, higher order interpolation schemes considering a larger environment of the voxel, can be used, too, at the cost of a higher computational complexity.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Discrete ray traversal</head><p>In the previous sections we came to the result that, because of the segmentation and the choice of the interpolation method, we can partition the scene into 0-voxels with no object surface and 1-voxels, where a ray-surface intersection can be found. Let us define a discrete ray as an ordered sequence of voxels v1. of the scene Sc(Sv), pierced by the ray with the equation X = A + t?.</p><p>The goal of the voxel scene traversal algorithm is to find the ray's lirst 1-voxel. We shall proceed with the following voxel of the ray only in such a case, that no ray-surface intersection is found within the volume of the previous one. If we add to the requirement of correctness of the surface point detection the requirement of high speed too, the discrete ray traversal algorithm should have the following properties:</p><p>1. it should pass the region of background voxels usually surrounding the object as fast as possible, i.e. it should utilize the object scene coherency and 2. it must not miss any object voxel, i.e. the voxels of the ray should fulfill the condition of 6-adjacency <ref type="bibr" target="#b18">[19]</ref> at least in the vicinity of the object.</p><p>In the algorithm design, we start from the assumption that the chessboard distance(CD) <ref type="bibr" target="#b1">[2]</ref> to the nearest object voxels is assigned to each 0-voxel V;:j k . Thus a cubic macro region is created:</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>O " ( i , j , k ) = ( h p c l r = 0 : i -n 5 p 5 i + n , j -n 5 q &lt; j + n , k -n &lt; r &lt; k + n }</head><p>with its center in K j k and with side size 2n + 1. Since CD is independent of the projection parameters, we can calculate it during a preprocessing phase. No extra space is necessary for the storage of the distance information, if we use the originally "empty" background voxels. In order to  Detailed description of the algorithm is in [lq, therefore we limit ourselves only to a brief description of its main loop, i.e. to the calculation of steps between macro regions and to the description of the traversal of a single macro region.</p><p>Since the algorithm is symmetric with respect to all axes, we shall present only the relations for the x axis. Further, we shall assume that the direction vector has only nonnegative coordinates. Generalization to all possible directions is done by the proper initialization of some variables.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3.1">Scene traversal</head><p>Let us imagine that we have reached the voxel V i j k with the assigned C D = n at an entry point p <ref type="figure">' = ( p , , p , , p z )</ref> , whose coordinates are expressed with respect to [i, j , IC].</p><p>Let the entry (exit) face be that through which the ray enters (exits) the voxel. It is necessary to find the nearest intersection of the line X = p'+ sr'with the planes x = n, y = n and z = n in ordertofind thefirst rayvoxeloutsideofO"(i, j , k). Let us suppose that the entry face is of type X , i.e. perpendicular to the x axis. We can see in <ref type="figure" target="#fig_2">Figure 2</ref> that for each n there exists such a threshold value tG(n) of the input coordinate p , that (2D case)</p><p>1. ifp, &lt; tE(n), then theexit face is also of X type, and</p><formula xml:id="formula_7">2. if p , &gt; te(n)</formula><p>, then it is of Y type, which in the 3D case holds for p z , too. The upper index denotes the type of the entry face. It can be shown that</p><formula xml:id="formula_8">r x -ry T X t i ( n ) = ( n + 1)-.</formula><p>The basic scheme of the algorithm is outlined in <ref type="figure">Figure 3</ref>,  The first case is a step across a slab defined by two parallel planes with distance n. If we denote dc(n) = n * 2, then for the next voxel holds:</p><p>Step, <ref type="figure">Figure 5a)</ref>, and ure 5b). <ref type="figure">int(d;(n)</ref> As a consequence we get rid of some multiplications.</p><formula xml:id="formula_9">i ' = i + n j' = j +</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Implementation and results</head><p>All algorithms were implemented in the C language on a DECstation 5000/200 equipped with 48 MB of main memory. <ref type="figure" target="#fig_9">Figure 7</ref> shows the impact of the subvoxel precision surface detection on the visual uality of the rendered image. The 64x64~64 data were renlered to a 500x500 image with either 0-order interpolation (a) or trilinear interpolation (b).</p><p>The scheme based on the vertex scene representation (Section 2.5) was chosen due to the importance of details.</p><p>The 500x500 image in <ref type="figure" target="#fig_10">Figure 8</ref> was rendered by the CD voxel traversal algorithm using trilinear interpolation with recursion depth 4 in 128 seconds. The skull data was obtained by a (X tomograph, the teapot and the implicit surface were voxelized from their analytical description [ 171. All objects were combined into a 200~200x110 scene.</p><p>To obtain information about the behavior of the CD algorithm over scenes with various complexities, a computer experiment was set up, based on rendering of scenes with randomly positioned spheres of various size and number. Its performance was compared with three similar algorithms known from the literature, fulfilling the conditions from the Section 1.1</p><p>The first one is Cleary's and Wyvill's algorithm <ref type="bibr" target="#b2">[3]</ref> for fast voxel traversal 0, generating a sequence of voxels pierced by the ray in a uniformly subdivided scene. The decision which voxel will be the next in the sequence is controlled by three variables d x , d y and dz, recording the total distances along the ray from some common point to the last crossings with X, Y and Z type voxel face.</p><p>The second Ray Acceleration by Distance Coding (RADC) algorithm <ref type="bibr" target="#b20">[21]</ref> is a modification of the 3D-DDA algorithm, which takes advantage of a 3D digital distance to speed up the voxel traversal. Since this algorithm works with various approximations of the Euclidean distance, we included tests with the chessboard <ref type="figure" target="#fig_8">(Figure 6</ref>, RADCchess) and chamfer (RADCchamf) distances. A sampling rate of 1.4 samples per volume distance has been chosen.</p><p>The third one, the Spackman's and Willis's SMART (Spatial Measure for Accelerated Ray Tracing) navigation oct-tree traversal <ref type="bibr" target="#b14">[15]</ref> works on an oct-tree represented as a breadth first list.</p><p>The notion of the spatial coherency leads to the following idea: The "more" coherent scene contains few larger objects, while the "less" coherent scene contains many small objects. The scene with a single spherical object has the highest spatial coherency. Since the sphere has the smallest surface-to-volume ratio (SVR), we propose this ratio to be a measure of the scene coherency for the purpose of algorithm comparison.</p><p>The sequence of scene phantoms was generated in the following manner. The scene built up of 128x128~128 voxels was subdivided into NxNxN subregions (N = 1, . . . ,lo). Within each subregion, a voxelized sphere was randomly placed (1-1024 spheres), such that total volume of all spheres was identical for all N. Thus we obtained Scenes with equal number of object voxels but different SVR. Chessboard and chamfer distance initialization took from 18 to 21 seconds.</p><p>In the experiment, only parallel primary rays were traced until the fist object voxel was found, with no subsequent shading. The results of the experiment are depicted in <ref type="figure" target="#fig_8">Figure 6</ref>. The y axis values represent the pure traversal time necessary for rendering of a 250x250 image. Values on the left side of the graph correspond to the simple scenes with low number of spheres, while those on the right side belong to the more complex scenes.</p><p>We see that the proposed CD traversal algorithm outperforms all three algorithms over the whole SVR range, delivering the best results in comparison to FVT for the less complex scenes. Experiments with tomographic data gave results similar to those from the left side for most of the scanned objects. We further see from <ref type="figure" target="#fig_8">Figure 6</ref> that the traversal time for the FVT algorithm is shorter for the denser populated scenes. In that case the surface is encountered earlier, which shortens the total distance traversed. All other algorithms show opposite behavior. In this case the shorter distance is surpassed by smaller macro regions which results in shorter mean step. It is apparent that beyond some scene complexity the macro region based traversal algorithms are, due to their larger one step cost, slower than the FVT algorithm. For example, in semitransparent volume rendering, where the traversal is not stopped at the object surface, but all or at least a lot of voxels should be traversed, it proved to be useful to switch between the CD traversal algorithm in the background region and the FVT within the object.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Conclusion</head><p>We concentrated in the paper on the following topics:</p><p>1. we showed how, based on the segmentation and choice of the interpolation function, the voxel values should be initialized to enable efficient traversal of the scene, 2. we proposed the CD voxel traversal algorithm based on cubic macro regions defined by the chessboard distance, and 3. we compared it with other similar algorithms known from the literature.</p><p>Some problems remain open, however, such as the utilization of the ray-to-ray coherency in the CD traversal algorithm, or the efficient computation of the ray-surface intersections. These will be the subject of our further research.</p><p>(a)  </p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head></head><label></label><figDesc>is voxel volume and h i j k E {0,1} is its value. The point [i, j , k] is a voxel vertex and similarly the point [i + 0.5, j + 0,5, k + 0.51 is the voxel center. The voxel value h i j k will have the following meaning: h j j k = 0 means certainty that none of the object surfaces h j j k = 1 means, that we are not sure about this. pass through this voxel, and</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head></head><label></label><figDesc>voxel Scene domain and the set S ( p , q , r ) = { K j k : ( i , j , k) E D} voxel scene. The voxel Scene S C ( M , N, 0) is called center representation of the image P, if the sample P j j k is assigned to the center of the voxel K j k . Analogously, it is the vertex representation Sv, if the sample is assigned to the voxel vertex. Apparently the size of the scene Sv domain along each axis is 1 voxel smaller than that of Sc. Let the voxels whose all corresponding b i j k = 0 be called background voxels (in both representations) and the rest foreground voxels.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Fl(z, Y, 2 ,</head><label>2</label><figDesc>u i j k ) = tzy,+yz + t,y+y + t,,+Z. + tytyz + t,+ + tyy + t,% + t . The coefficients t . . .tryz depend on the values yo, v l , . . . , v7, positioned in the voxel K j k vertices. Since in the center representation we assume that the samples of the scanned field are situated in voxel centers, the val-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head>Figure 2 :</head><label>2</label><figDesc>Entry point coordinate thresholds distinguish between the object identifier and the distance, a flag bit is reserved within each voxel descriptor.We know that there are no object voxels within O*(i,j, k), so we can jump from K a j k directly to the first ray's voxel outside of U"(i, j, 1). The traversal speed up is thus achieved by reducing the number of visited voxels.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head>Figure 1 :</head><label>1</label><figDesc>scene initialization: (a) sc for order interpolation, (b) Sc for trilinear interpolation (c) S" for trilinear interpolation and the scheme for computation of the exit face type in</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>Figure 4 .Figure 3 : 2 ChangeMacroRegionStepFigure 4 : 3 . 2</head><label>432432</label><figDesc>The expression p , 2 t; ( n ) + pz 2 enables us to distinguish between exit types Y and Z when the type is not X .while(in scene and object not found ) CD algorithm: scene traversal macroRegionStep(x,y,z,n) t if(~v 5 t i ( n ) and PZ 5 t : ( n ) ) NoChangeMacroRegionStep(x,y,z,n); else if ( p v 1 t i ( n ) + p Z CD algorithm: macro region step Macro region traversal In this part we describe briefly the calculation of the next voxel position and the coordinates of the new entry point. l k o kinds of steps across the macro region can be distinguished as shown in Figure 4: 1. without face type change (NoChangeMacroRegion-2. with face type change (ChangeMacroRegionStep, Fig-</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head>PYPy = r, * P x 3 3 Figure 5 :</head><label>35</label><figDesc>), p; = frad(dc(n)) 1' = h + int(d:(n)), p: = frad(d:(n)) The second case is analogous; only the intersection with the plane z = 0 must be calculated (Figure 5b): Further speed up CD traversal algonthm: There are some possibilities for a further speed up of the 1. both arrays t (n) and d( n) can be precomputed. However, in this case the algorithm can be used only for a parallel projection, Macro region traversal: (a) entry and exit face of the same type, (b) with different types 2. implementation in the fixed point arithmetics is possi-3. the decision variable triple (px, py , pz) can be replaced ble, and by</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head>Figure 6 :</head><label>6</label><figDesc>Comparison of various voxel traversal algorithms</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 7 :</head><label>7</label><figDesc>Electrone density map of High Potential Iron Protein molecule (b) (a) 0-order interpolation, (b) trilinear interpolation</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>Figure 8 :</head><label>8</label><figDesc>Scene with voxelized and scanned objects (See color plates, page CP-21.)</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0" />
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">A fast voxel traversal algorithm for ray tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Amanatides</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andrew</forename><surname>Woo</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proc. EUROGRAPHICS &apos;87</title>
		<editor>G. Marechal</editor>
		<meeting>EUROGRAPHICS &apos;87<address><addrLine>North-Holland</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1987" />
			<biblScope unit="page" from="3" to="10" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">Distance transformations in digital images</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gunilla</forename><surname>Borgefors</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Computer Vision, Graphics, and Image Processing</title>
		<imprint>
			<date type="published" when="1986" />
			<biblScope unit="volume">34</biblScope>
			<biblScope unit="page" from="344" to="371" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">Analysis of an algorithm for fast ray tracing using uniform space subdivision</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Geoff</forename><surname>Cleary</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wyvill</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">4</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="65" to="83" />
			<date type="published" when="1988-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Arts: Accelerated ray-tracing system</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Akira</forename><surname>Fujimoto</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Takayuki</forename><surname>Tanaka</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kansei</forename><surname>Iwata</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page">1626</biblScope>
			<date type="published" when="1986" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Incremental generation of projections of CT-volumes</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">B</forename><surname>Gudmundson</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">M</forename><surname>Randen</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the First Conference on Visualization in Biomedical Computing</title>
		<meeting>the First Conference on Visualization in Biomedical Computing<address><addrLine>Atlanta, GA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1990-05" />
			<biblScope unit="page" from="27" to="34" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">3D visualization of tomographic volume data using the generalized voxel model</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karl</forename><surname>Heinz Hohne</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Bomans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Pommert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Martin</forename><surname>Riemer</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Carsten</forename><surname>Schiers</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ulf</forename><surname>Tiede</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Gunnar</forename><surname>Wiebecke</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">The Visual Computer</title>
		<imprint>
			<biblScope unit="volume">6</biblScope>
			<biblScope unit="issue">1</biblScope>
			<biblScope unit="page" from="28" to="36" />
			<date type="published" when="1990-02" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">An Interactive Tool for Manipulation and Presentation of 3D Tomographic Data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Igor</forename><surname>Hollander</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milo5</forename><surname>Srlmek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">CAR &apos;93 ComputerAssisted Radiology</title>
		<editor>H. U. Lemke, K. Inamura, C. C. Jaffee, and R. Felix</editor>
		<meeting><address><addrLine>Berlin</addrLine></address></meeting>
		<imprint>
			<publisher>Springer-Verlag</publisher>
			<date type="published" when="1993" />
			<biblScope unit="page" from="278" to="383" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">3D scan-conversion algorithms for voxel-based graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arie</forename><surname>Kaufman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Eyal</forename><surname>Shimony</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of 1986 Workshop on Interactive 3 0 Graphics</title>
		<editor>Frank Crow and Stephen M. Pizer</editor>
		<meeting>1986 Workshop on Interactive 3 0 Graphics<address><addrLine>Chapel Hill, North Carolina</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1986-10" />
			<biblScope unit="page" from="45" to="75" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<analytic>
		<title level="a" type="main">Display of surfaces from volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">8</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="29" to="37" />
			<date type="published" when="1988-05" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">Marching cubes: A high-resolution 3D surface construction algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">]</forename><forename type="middle">W E</forename><surname>Lorensen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><forename type="middle">E</forename><surname>Cline</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">21</biblScope>
			<biblScope unit="issue">4</biblScope>
			<biblScope unit="page" from="163" to="169" />
			<date type="published" when="1987-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<monogr>
		<title level="m" type="main">Ray coherence theorem and constant time ray tracing algorithm</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Matasaka</forename><surname>Ohta</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Mamoru</forename><surname>Maekawa</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<monogr>
		<title level="m" type="main">Computer Graphics 1987 -Proceedings of CG International</title>
		<editor>T. Kunii, editor</editor>
		<imprint>
			<date type="published" when="1987" />
			<publisher>Springer-Verlag</publisher>
			<biblScope unit="volume">87</biblScope>
			<biblScope unit="page" from="303" to="314" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title level="a" type="main">Volume visualization in magnetic resonance angiography</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Andreas</forename><surname>Pommert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Michael</forename><surname>Bomans</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karl</forename><forename type="middle">Heinz</forename><surname>Hohne</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="12" to="13" />
			<date type="published" when="1992-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Interactive 3-D image display and analysis</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">R</forename><forename type="middle">A</forename><surname>Robb</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Barillot</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings SPIE on Hybrid Image and Signal Processing</title>
		<meeting>SPIE on Hybrid Image and Signal Processing<address><addrLine>Bellingham, WA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1988" />
			<biblScope unit="volume">939</biblScope>
			<biblScope unit="page" from="173" to="195" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<monogr>
		<title level="m" type="main">The SMART navigation of a ray through an oct-tree</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Spackman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Philip</forename><surname>Willis</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1991" />
			<biblScope unit="volume">15</biblScope>
			<biblScope unit="page" from="185" to="194" />
		</imprint>
	</monogr>
	<note type="report_type">Comput.&amp;Graphics</note>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">Cubic macro-regions for fast voxel L A traversal</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milos</forename><surname>Srlmek</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
			<biblScope unit="page" from="171" to="179" />
		</imprint>
	</monogr>
	<note>Machine Graphics &amp;&quot;Vision, 3(1/2</note>
</biblStruct>

<biblStruct xml:id="b16">
	<analytic>
		<title level="a" type="main">Gray level voxelization: A tool for simultaneous rendering of scanned and analytical data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Milos</forename><surname>Srlmek</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Proceedings of the Tenth Spring School on Computer Graphics and its Applications</title>
		<editor>Eugen RuZickq, Pavol ElilS, and Andrej Ferko</editor>
		<meeting>the Tenth Spring School on Computer Graphics and its Applications<address><addrLine>Bratislava, Slovak Republic</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1994-06" />
			<biblScope unit="page" from="159" to="168" />
		</imprint>
		<respStmt>
			<orgName>Comenius University</orgName>
		</respStmt>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">Volume sampled voxelization of geometric primitives</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Sidney</forename><forename type="middle">W</forename><surname>Wang</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arie</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization &apos;93</title>
		<meeting><address><addrLine>San Jose, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-10" />
			<biblScope unit="page" from="78" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<analytic>
		<title level="a" type="main">Discrete ray tracing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roni</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Daniel</forename><surname>Cohen</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Arie</forename><surname>Kaufman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">IEEE Computer Graphics and Applications</title>
		<imprint>
			<biblScope unit="volume">12</biblScope>
			<biblScope unit="issue">5</biblScope>
			<biblScope unit="page" from="19" to="28" />
			<date type="published" when="1992-09" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<analytic>
		<title level="a" type="main">Accelerating volume animation by space-leaping</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Roni</forename><surname>Yagel</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Zhouhong</forename><surname>Shi</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization &apos;93</title>
		<meeting><address><addrLine>San Jose, CA</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1993-10" />
			<biblScope unit="page" from="62" to="84" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b20">
	<analytic>
		<title level="a" type="main">Acceleration of ray -casting using 3D distance transforms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Karel</forename><forename type="middle">J</forename><surname>Zuiderveld</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Anton</forename><forename type="middle">H J</forename><surname>Koning</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Max</forename><forename type="middle">A</forename><surname>Viergever</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">Visualization in Biomedical Computing U, Proc. SPIE 1808</title>
		<editor>R. A. Robb</editor>
		<meeting><address><addrLine>Chapel Hill, NC</addrLine></address></meeting>
		<imprint>
			<date type="published" when="1992" />
			<biblScope unit="page" from="324" to="335" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b21">
	<analytic>
		<title level="a" type="main">Efficient ray tracing of volume data</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Levoy</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">ACM Transactions on Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">9</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="245" to="261" />
			<date type="published" when="1990" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
