<?xml version="1.0" encoding="UTF-8"?>
<TEI xml:space="preserve" xmlns="http://www.tei-c.org/ns/1.0" 
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
xsi:schemaLocation="http://www.tei-c.org/ns/1.0 /home/pisenberg/grobid/grobid-0.6.1/grobid-home/schemas/xsd/Grobid.xsd"
 xmlns:xlink="http://www.w3.org/1999/xlink">
	<teiHeader xml:lang="en">
		<fileDesc>
			<titleStmt>
				<title level="a" type="main">A Library for Visualizing Combinatorial Structures</title>
			</titleStmt>
			<publicationStmt>
				<publisher/>
				<availability status="unknown"><licence/></availability>
			</publicationStmt>
			<sourceDesc>
				<biblStruct>
					<analytic>
						<author role="corresp">
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><forename type="middle">A</forename><surname>Najork</surname></persName>
							<email>najork@src.dec.com</email>
							<affiliation key="aff0">
								<orgName type="department">DEC Systems Research Center</orgName>
								<address>
									<addrLine>130 Lytton Ave. Palo Alto</addrLine>
									<postCode>94301</postCode>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<author>
							<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><forename type="middle">H</forename><surname>Brown</surname></persName>
							<affiliation key="aff0">
								<orgName type="department">DEC Systems Research Center</orgName>
								<address>
									<addrLine>130 Lytton Ave. Palo Alto</addrLine>
									<postCode>94301</postCode>
									<region>CA</region>
								</address>
							</affiliation>
						</author>
						<title level="a" type="main">A Library for Visualizing Combinatorial Structures</title>
					</analytic>
					<monogr>
						<imprint>
							<date/>
						</imprint>
					</monogr>
				</biblStruct>
			</sourceDesc>
		</fileDesc>
		<encodingDesc>
			<appInfo>
				<application version="0.6.1" ident="GROBID" when="2021-02-19T20:31+0000">
					<desc>GROBID - A machine learning software for extracting information from scholarly documents</desc>
					<ref target="https://github.com/kermitt2/grobid"/>
				</application>
			</appInfo>
		</encodingDesc>
		<profileDesc>
			<abstract>
				<p>This paper describes ANIM3D, a 3 0 animation library targeted at visualizing combinatorial structures. In particulal; we are interested in algorithm animation. Constructing a new view for an algorithm typically takes dozens of design iterations, and can be very time-consuming. Our library eases the programmer&apos;s burden by providing high-level constructs for pelforming animations, and by offering an interpretive environment that eliminates the need for recompilations. This paper also illustrates ANIM3D&apos;s expressiveness by developing a 3 0 animation of DijhtraS shortest-path algorithm in just 70 lines of code.</p>
			</abstract>
		</profileDesc>
	</teiHeader>
	<text xml:lang="en">
		<body>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="1">Background</head><p>Algorithm animation is concerned with visualizing the internal operations of a running program in such a way that the user gains some understanding of the workings of the algorithm. Due to lack of adequate hardware, early algorithm animation systems were restricted to black-and-white animations at low frame rates <ref type="bibr" target="#b5">[6]</ref>. As hardware has improved, smooth motion [ l l , 151, color <ref type="bibr">[l]</ref>, and sound <ref type="bibr" target="#b3">[4]</ref> have been used to increase the level of expressiveness of the visualizations.</p><p>Constructing an enlightening visualization of an algorithm in action is a tricky proposition, involving both artistic and pedagogical skills of the animator. Most successful views undergo dozens of design iterations. Based on our experiences in the 1992 and 1993 SRC Algorithm Animation Festivals <ref type="bibr" target="#b1">[2,</ref><ref type="bibr">31</ref> (20 SRC researchers participated each year), we found that a high-level animation library, coupled with an interpreted language, was instrumental in developing highquality views <ref type="bibr" target="#b11">[12]</ref>.</p><p>A high-level animation library allows users to focus on what they want to animate, without having to spend too much time on the how. An interpreted language significantly shortens the time needed for each iteration in the design cycle because users do not need to recompile the view after mod-ifying its code. In fact, in our algorithm animation system, users just need to hit the "run" button in the control panel to see their changes in action.</p><p>In 1992, we began to explore how 3D graphics could be used to further increase the expressiveness of visualizations <ref type="bibr" target="#b4">[5]</ref>. We identified three fundamental uses of 3D for algorithm visualization: Expressing fundamental information about structures that are inherently two-dimensional; uniting multiple views of the underlying structures; and capturing a history of a two-dimensional view. <ref type="figure" target="#fig_0">Fig. 1</ref> shows snapshots of some of the 3D animations we developed.</p><p>We found that building enlightening 3D views is even harder than building good 2D views. One obvious reason is that we (and most people) are much less used to designing in 3D than in 2D. But a more pragmatic problem was that our 3D software infrastructure was quite impoverished: We used a small, object-oriented graphics library for displaying static 3D scenes. This library (like the rest of our algorithm animation system) was written in Modula-3 and used PEXlib as its underlying graphics system. This architecture was limiting both in terms of turnaround time and in terms of animation support. Therefore, drawing on our prior experience in 2D algorithm animation, we built ANIM3D, a 3D object-oriented animation library.</p><p>ANIM3D supports several window systems (X and Trestle <ref type="bibr" target="#b12">[13]</ref>) and several graphics systems (PEX and OpenGL). The base library is implemented in Modula-3; clients can either directly call into this base library, or access it through Obliq <ref type="bibr" target="#b6">[7]</ref>, an interpreted embedded language. Using ANIM3D, the size of a prototypical 3D animation (Dijkstra's shortestpath algorithm) decreased from about 2000 lines of Modula-3 to 70 lines of Obliq, and the part of the design cycle time devoted to compiling, linking, and restarting the application from about 7 minutes to about 10 seconds of reloading by the Obliq interpreter (on a DECstation 5000/200).</p><p>Although ANIM3D was designed with algorithm animation in mind, it is a general-purpose animation system. We believe it to be particularly well-suited for visualizing and animating combinatorial structures. The first snapshot shows a divide-and-conquer algorithm for finding the closest pair of a set of points in the plane. The third dimension is used here to show the recursive structure of the algorithm. The second snapshot shows a view of Heapsort. Each element of the array is displayed as a stick whose length and color is proportional to its value. With clever placement, the tree structure of the heap is visible from the front and the the array implementation of the tree is revealed from the side. The third snapshot shows a k-d tree, fork = 2. When viewed from the top, the walls reveal how the plane has been partitioned by the tree; when viewed from the front or side, we see the tree. The last snapshot shows a view of Shakersort. The vertical sticks show the current values of elements in the array, and the plane of "paint chips" underneath provides a history of the execution. The sticks stamp their color onto the chips plane, which is pulled forward as the execution progresses.</p><p>The remainder of this paper is structured as follows. After presenting an overview of ANIM3D, we show how to use the library to construct a simple animation. The animation is of a trivial solar system. We then build a 3D visualization of Dijkstra's algorithm for finding the shortest path in a graph. This animation can also serve as an introduction to our methodology for animating algorithms. Finally, we discuss how ANIM3D compares with other general-purpose animation systems and with other algorithm animation systems.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="2">An Overview of Anim3D</head><p>ANlM3D is built upon three basic concepts: graphical objects, properties, and callbacks.</p><p>A graphical object, or "GO', can be a geometric primitive such as a line, polygon, sphere, or cone, a light source, a camera, or a group of other GOs. Graphical objects form a directed acyclic graph; typically, the roots of the DAG are the top-level windows, the internal nodes are groups of other GOs, and the leaves are geometric primitives, lights, or cameras. The GO class hierarchy is as follows:</p><formula xml:id="formula_0">( GO GroupGO-- RootGO LightGO - 'AmbientLightGO V</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>e c torLightG0 PointLightGO iSpotLightGO</head><p>A property consists of two parts, a name and a value. Property names are constants, such as "Surface Color" or "Sphere Radius." Property values are objects (in an objectoriented programming sense) representing colors, 3D points, reals, etc. Because property values are objects, they are both mutable and can be shared by several GOs. In addition, property values are time-variant: the actual value encapsulated by the property value depends on the current animation time, a system-wide resource.</p><p>Associated with each graphical object o is a property mapping, a partial function from property names to property values. A property associated with o not only affects the appearance of 0, but also the appearance of all those descendants of o that do not explicitly override the property.</p><p>Although it is legal to associate any property with any graphical object, the property does not necessarily affect the object. For example, associating a "Sphere Radius" property with an ambient light source does not affect the appearance or behavior of the light. However, associating this property with a group g potentially affects all spheres contained in g .</p><p>Graphical objects are reactive, that is, they can respond to events. We distinguish three different kinds of events: mouse events are triggered by pressing or releasing mouse buttons, position events are triggered by moving the mouse, and key events are triggered by pressing keyboard keys.</p><p>Events are handled by callbacks. There are three types of callbacks, corresponding to the three kinds of events. Associated with each graphical object are three callback stacks. The client can define or redefine the reactive behavior of a graphical object by pushing a new callback onto the appropriate stack. The previous behavior of the graphical object can easily be reestablished by popping the stack.</p><p>Consider a mouse event e that occurs within the extent of a top-level window w . Associated with w is a RootGO r . The  top callback on r's mouse callback stack will be invoked (if the callback stack is empty, the event will simply be dropped).</p><p>The callback might perform an action, such as starting to spin the scene, or it might delegate the event to one of r's children.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="3">Using Anim3D</head><p>Both Modula-3 and Obliq support the concepts of modules and classes. (Obliq is based on prototypes and delegation, not classes and inheritance; however, it is expressive enough to simulate them.) For each kind of graphical object, there is a Modula-3 module in A"i3D. This module contains the class of the graphical object, and a set of its associated functions and variables. For each Modula-3 module, there is a "wrapper" that makes it accessible as a module from Obliq.</p><p>The moduleGO contains the class of all graphical objects. There are various methods associated with them: methods for defining, undefining, and accessing properties in the property mapping of a graphical object, and methods for pushing and popping the three callback stacks of the graphical object as well as for dispatching events to their top callback objects.</p><p>In addition, there is one property named GO-Trans f o m , which names the spatial transformation property and is meaningful for all graphical objects. Unlike other properties, a transformation property does not "override" other transformations that are closer to the root, but is rather composed with them.</p><p>The module G r o u p G O contains the class of all graphical object groups, i.e. graphical objects which are used to group other graphical objects together. The GroupGO class has methods for adding elements to a group and removing them again. The module also contains a function New, which creates a new group and returns it.</p><p>A 3D window is regarded as a special form of group, which contains all the objects in a scene (we therefore call it the "root" of the scene), and has some additional properties, such as the color of the background, whether depth cueing is in effect, etc. Also associated with each window is the camera that is currently active, and a "graphics base," an abstraction of the underlying windows and graphics system. Finally, the R o o t G O module contains functions New and NewStd. The latter creates a new scene root object with reasonable default elements, callbacks, and properties (a perspective camera, two white light sources, top-level reactive behavior that allows the user to rotate and move the scene, and various surface properties).</p><p>Both PEX and OpenGL distinguish between lines and surfaces: surfaces are affected by light sources, lines are not. There are a variety of properties common to all surfaces: their color, transparency, reflectivity, shading model, and so on. Although it is legal to attach these properties to non-surfaces, it will not affect them. In order to emphasize that these properties are meaningful only for surfaces, we provide a module S u r f aceGO, which contains the superclass of all graphical objects composed of surfaces, along with their related properties. We are provide a NonSurf a c e G O module for lines and markers.</p><p>The module SphereGO contains the class of spheres, which is a subclass of the SurfaceGO class, as spheres are composed of triangles, i.e. surfaces. Apart from the definition of the sphere class, it contains a functionNew for creating new sphere objects, and property names C e n t e r and R a d i u s , which are used to identify the properties determining the center and the radius of the sphere.</p><p>Here is a complete Obliq program to display a planet and its moon. The user can control the camera using the mouse. This scene is displayed in the left snapshot of Property values can be time-variant; that is, their value depends on the time of the animation clock. Time-variant property values can either be unsynchronized or synchronized.</p><p>An unsynchronized time-variant p ' o p e w value starts to change at the moment it is created, and animates the graphical object o as long as it is attached to 0. The animation does not need to be triggered by any special command. For instance, unsynchronized property values can be used to rotate the scene or some part of it for an indefinite period of time.</p><p>Synchronized property values, on the other hand, are used to animate several aspects of a scene in a coordinated fashion. Each synchronized property value is "tied" to an animation handle, and many values can be tied to the same handle. A synchronized property value object accepts animation requests, messages that ask it to change its current value, beginning at some starting time and lasting for a certain duration. When a client sends an animation request to a property value, the request is not immediately satisfied, but instead stored in a request queue local to the property value. Sending the message animate to an animation handle causes all property values controlled by this handle to be animated in synchrony. The call to animate returns when all animations are completed.</p><p>When added to the above program, the following few lines create a 25-second animation. The planet rotates six times about its axis, while the moon revolves once around the planet. In order to better show the rotation, we add a red torus around the planet, aligned to the axis of rotation. See <ref type="figure" target="#fig_2">Fig. 2</ref>, the three frames at the right. Note that we chose to attach the same transformation property to both the torus and the planet. Alternatively, we could have made a group containing both, and attached the transformation property just to this group.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4">Casestudy: Shortest-Path Algorithm Animation</head><p>This section contains a case study of using ANIM3D with the Zeus algorithm animation system [ 11 to develop an animation of Dijkstra's shortest-path algorithm. We first describe the algorithm, and then sketch the desired visualization of the algorithm. Next, we present an overview of the Zeus methodology and finally, we present the actual implementation of the animation.</p><p>The implementation consists of three elements. First, we define a set of "interesting events," used for communication between the algorithm and the view. Second, we annotate the algorithm with the events. And finally, we build a view, a window that displays interesting events graphically.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.1">The Algorithm</head><p>The single-source shortest-path problem can be stated as follows: given a directed graph G = (V, E) with weighted edges, and a designated vertex s, called the source, find the shortest path from s to all other vertices. The length of a path is defined to be the sum of the weights of the edges along the path.</p><p>The following algorithm, due to Dijkstra <ref type="bibr">[lo]</ref>, solves this problem (assuming all edge weights are non-negative):</p><formula xml:id="formula_1">for all v E V do D ( u ) := 00 while V \ S # 0 do D ( s ) := 0; s := 0 s := s U {U} let U E V \ S such that D(u) is minimal for all neighbors v of U do endfor endwhile D ( v ) := min{D(v), D(u) + W ( U , v)}</formula><p>In this pseudo-code, D ( v ) is the distance from s to v, W ( U , v) is the weight of the edge from U to U , and S is the set of vertices that have been explored thus far. V \ S denotes those elements in V that are not also in S.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.2">The Desired Visualization</head><p>An interesting 3D animation of this algorithm is shown in <ref type="figure" target="#fig_6">Fig. 3</ref>. The vertices of the graph are displayed as white disks in the ay plane. Above each vertex v is a green column representing D ( u ) , the best distance from s to U known SO far. Initially, the columns above each vertex other than s will be infinitely (or at least quite) high. An edge from U to v with weight W ( U , U ) is shown by a white arrow which starts at the column over U at height 0 and ends at the column over U at height W ( U , U ) .</p><p>Whenever a vertex U is selected to be added to S, the color of the corresponding disk changes from white to red. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>The addition D(u) + W ( U ,</head><formula xml:id="formula_2">+ W ( U , v)</formula><p>is smaller than D(v), the end of the arrow will still touch the green column over D ( v ) , otherwise, it will not. In the former case, we shrink the column over v to height <ref type="bibr">D(u)</ref> </p><formula xml:id="formula_3">+ W ( U , v)</formula><p>to reflect the assignment of a new value to D ( v ) , and color the arrow red, to indicate that it became part of the shortest-path tree. Otherwise, the arrow simply disappears.</p><p>Upon completion, the 3D view shows a set of red arrows which form the shortest-path tree, and a set of green columns which represent the best distance D ( v ) from s to v. </p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.3">Zeus Methodology</head><p>In the Zeus framework, strategically important points of an algorithm are annotated with procedure calls that generate "interesting events." These events are reported to the Zeus event manager, which in turn forwards them to all interested views. Each view responds to interesting events by drawing appropriate images. The advantages of this methodology are described elsewhere <ref type="bibr" target="#b5">[6]</ref>.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.4">The Interesting Events</head><p>The interesting events for Dijkstra's shortest-path algorithm (and many other shortest-path algorithms) are as follows: <ref type="figure">U , a , y , d )</ref>  In addition, we need another event for house keeping purposes: b start ( m ) is called at the very beginning of an algorithm's execution; it initializes the view to hold up to m vertices and up to m2 edges.</p><formula xml:id="formula_4">b addvertex (</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.5">Annotating the Algorithm</head><p>Here is an annotated version of the algorithm we showed before: In this pseudo-code, views is the dispatcher provided by Zeus. The dispatcher will notify all views the user has selected for the algorithm.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>views. start (JVI) for all</head><formula xml:id="formula_5">v E V do D(v) := 00 for all v E V do views. addvertex ( v , U,, uy , D(v) ) for all (U, v) E E do views. addEdge ( U , U , W ( U , v) whileV\ S # 0 do D ( s ) := 0; s := 0 let U E V \ S such that D(u) is minimal views.selectVertex(u) for all neighbors v of U do S : = S U { u } views. raiseEdge (u,v, D ( u ) ) if D(v) &lt; D(u) + W ( U , v</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="4.6">The View</head><p>A view is an object that has a method corresponding to each interesting event, and a number of data fields. In this view, the data fields are as follows: a RootGO object that contains all graphical objects of the scene, together with a camera and light sources; arrays of graphical objects holding thedisks (vertices), columns (distances), arrows (graph edges), and shortest-path tree edges; and an "animation handle" for triggering animations. This leads us to a skeletal view:</p><formula xml:id="formula_6">let view = { scene =&gt; RootGO-Newstdo, ah =&gt; AnimHandle-New ( ) ,</formula><p>verts =&gt; ok, ( * initialized by method start * ) dists =&gt; ok, ( * initialized by method start * ) parent =&gt; ok, ( * initialized by method start * ) edges =&gt; ok, ( * initialized by method start * ) start</p><formula xml:id="formula_7">=&gt; meth(self,m) . . . end, addvertex =&gt; meth(se1f , U , x,y) . . . end, addEdge =&gt; meth(self,u,v,w) . . . end, selectvertex =&gt; meth(self,u) . . . end, raiseEdge =&gt; meth(self,u,v,z) . . . end, lowerDist =&gt; meth(self,u,z) . . . end, promoteEdge =&gt; meth(self,u,v) . . . end, demoteEdge =&gt; meth(self,u,v) . . . end,</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head>1;</head><p>The Zeus system has a control panel that allows the user to select an algorithm and attach any number of views to it. Whenever the user creates a new 3D view, a new Obliq interpreter is started, and reads the view definition. The algorithm and all views run in the same process, but in different threads; thread creation is very light-weight. The above expression creates a new object view, and initializes view. scene to be a RootGO, and view. ah to be an animation handle.</p><p>The remainder of this section fleshes out the 8 methods of view, which correspond to the 8 interesting events:</p><p>b The start method' is responsible for initializing view.verts, view.dists, andview.parent to be arrays of size m, and view. edges to be an m x m array.</p><p>The elements of the newly created arrays are initialized to the dummy value ok. Here is the code: An arrow is composed of a cone, a cylinder, and two disks; its geometry is computed based on the "Center" property of the disks representing the vertices to which it is attached. <ref type="figure" target="#fig_9">Figure 4</ref> illustrates the relationship. The selectvertex method indicates that a vertex U has been added to the set S by coloring U'S disk red:</p><formula xml:id="formula_8">start =&gt; meth(</formula><formula xml:id="formula_9">addEdge =&gt; meth(self,u,v</formula><formula xml:id="formula_10">selectvertex =&gt; meth(self,u) end</formula><p>SurfaceGO-SetColor (self .verts <ref type="bibr">[U]</ref>, "red") :</p><p>D The raiseEdge method highlights the edge from U to v by coloring it yellow, and then lifting it up by z. The arrow is moved by sending a "translate" request to its transformation property. The translation is controlled by the animation handle se1 f . ah, and shall take 2 seconds to complete.</p><p>Calling self. ah. animate ( ) causes all animation requests controlled by se1 f. ah to be processed. ("move over a linear path to") request to the "Point2" property of the cylinder. This completes our example. The complete view is about 70 lines of code, compared to the roughly 2000 lines of the PEXlib-based version that generated the animations presented in <ref type="bibr" target="#b4">[5]</ref>. This measure is fairly honest; we did not add any functionality (such as a new class ArrowGO) to the base library in order to optimize this example. Furthermore, turnaround time during the design of this view was limited only by the design process per se (and our typing speed), whereas compiling a single file and relinking with the Zeus system takes several minutes.</p><formula xml:id="formula_11">raiseEdge =&gt; meth(self,u,v</formula></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="5">Related Work</head><p>There are two areas that have influenced ANIM~D: general-purpose 3D animation libraries and algorithm animation systems that have been used for developing 3D views.</p><p>The most closely related general-purpose animation library is OpenInventor <ref type="bibr">[17,</ref> 181, an object-oriented graphics library with a C++ API. OpenInventor, like ANIM~D, represents a scene as a DAG of "nodes". Geometric primitives, cameras, lights, and groups are all special types of nodes. However, there are three key differences between A " 3 D</p><p>and OpenInventor:</p><p>ANIM~D includes an embedded interpretive language, which is instrumental for achieving fast turnaround and short design cycles.</p><p>OpenInventor views properties (such as colors and transformations) as ordinary nodes in the scene DAG. This means that the order of nodes in a group becomes important. In this respect, A " 3 D is more declarative than OpenInventor: the order in which objects are added to a group does not matter.</p><p>In a number of aspects, OpenInventor requires the programmer to do more work than A " 3 D requires. For example, OpenInventor clients have to explicitly redraw a scene whereas A " 3 D uses a damage-repair model to automatically redraw just those primitives that need to be redrawn.</p><p>Nonetheless, OpenInventor is a very impressive commercial product that greatly simplifies 3D graphics. Many of the ideas of OpenInventor can be found in work done at Brown University <ref type="bibr">[ 16, 191.</ref> There are three algorithm animation systems that have been used for developing 3D views, Pavane, Polka3D, and GASP.</p><p>In Pavane <ref type="bibr" target="#b7">[8]</ref>, the computational model is based on tuplespaces and mappings between them. Entering tuples into the "animation tuple space" has the side-effect of updating the view. A small collection of 3D primitives are available (points, lines, polygons, circles, and spheres), and the only animation primitives are to change the positions of the primitives.</p><p>Polka3D [ 141, like Zeus, follows the BALSA model for animating algorithms. Algorithms communicate with views using "interesting events," and views draw on the screen in response to the events. The graphics library is similar to A " 3 D in goals and features, but it appears to be a bit slimmer and more focused on algorithm animations. Unlike our system, views are not interpreted, so turnaround time is not instantaneous.</p><p>The GASP [9] system is tuned for developing animations of computational geometry algorithms involving three (and two) dimensions. Because a primary goal of the system is to isolate the user from details of how the graphics is done, a user is limited to choosing from among a collection of animation effects supplied by the system. The viewing choices are typically stored in a separate "style" file that is read by the system at runtime; thus, GASP provides rapid turnaround. However, it does not provide the flexibility to develop arbitrary views with arbitrary animation effects.</p></div>
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="6">Conclusion</head><p>The first part of this paper described ANIM3D, an objectoriented 3D animation library targeted at visualizing combinatorial structures, and in particular at animating algorithms. The second part presented a case study showing how to use ANIM3D within the Zeus algorithm animation system for producing a 3D visualization of a graph-traversal algorithm.</p><p>ANIM3D is based on three concepts: scenes are described by DAGS of graphical objects, time-variant property values are the basic animation mechanism, and callbacks are the mechanism by which clients can specify reactive behavior. These concepts provide a simple, yet powerful framework for building animations.</p><p>ANIM3D provides fast turnaround by incorporating an interpretive language that allows the user to modify the code of a program even as it runs. Previous experience has shown us that powerful animation facilities and fast turnaround time are crucial for enabling non-expert users to construct new algorithm animations.</p></div><figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_0"><head>Figure 1 :</head><label>1</label><figDesc>These snapshots are examples of the type of views for which ANIM3D is very well-suited. Each view requires from 50 to 200 lines of code to produce.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_1"><head>(</head><label></label><figDesc>See color plates, page </figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_2"><head>Figure 2 :</head><label>2</label><figDesc>The ANIM3D Solar System</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_3"><head>Fig. 2 .</head><label>2</label><figDesc>let root = RootGO-Newstdo; let planet = SphereGO-New( [ O , O , 01,l) ; SurfaceGO-SetColor (planet, " lightblue" ) ; root.add(planet) ; let moon = SphereGO-New( [3,0,0], 0 . 5 ) ; SurfaceGO-SetColor (moon, "of fwhite" ) ; root.add(moon);</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_4"><head></head><label></label><figDesc>let torus = TorusGO~New([O,0,01,[1,0,01,1,0.1); root.add(torus); SurfaceGO-SetColor (torus, "red" ) ; let ah = AnimHandle-New(); let planettransform = TransformProp-NewSync(ah); planet.setProp(G0-Transform,planettransform); torus.setProp(G0-Transform,planettransform); let moontransform = TransformProp-NewSync(ah); moon.setProp(G0-Transform,moontransform); moontransform.getBeh0 .rotateY(2*PI,0,25); planettransform.getBehO.rotateY(12*PI,0,25); ah. animate ( ) ;</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_5"><head></head><label></label><figDesc>v) is animated by highlighting the arrow corresponding to the edge (U, v ) and lifting it to the top of the column (i.e. raising it by D(u)). If D(u)</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_6"><head>figure 3 :</head><label>3</label><figDesc>These snapshots are from the animation of Dijkstra's shortest-path algorithm described in section 4. The left snapshot shows the datajust before entering the main loop. The next snapshot shows the algorithm about one-third complete. In the third snapshot, the algorithm is about 213 complete, and the snapshot at the right shows the algorithm upon completion.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_7"><head></head><label></label><figDesc>adds a vertex U (where U is an integer identifying the vertex) to the graph. The vertex is shown at position (a, y) in the ay plane. In addition, D(u) is declared to be d. b addEdge ( u , v , w ) adds an edge from U to U with weight w to the graph. D selectvertex ( U ) indicates that U was added to S. b raiseEdge ( U , U , d ) visualizes the addition D(u) + W ( U , v) by raising the edge (U, v) by d (where the caller passes D(u) ford). b lowerDi s t ( U , d ) indicates that D( U) gets lowered to d. b promoteEdge ( U , U ) indicates that the edge (U, v) is part of the shortest-path tree. b demoteEdge ( U , v ) indicates that the edge (U, v) is not part of the shortest-path tree.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_8"><head></head><label></label><figDesc>) := D(u) + W(U, v) views.promoteEdge(u,v) views. lowerDist ( v , D(v)) endif endfor endwhile</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_9"><head>Figure 4 :</head><label>4</label><figDesc>The structure of an arrow generated by the addEdge method.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_10"><head>b</head><label></label><figDesc>se1f.m) self.verts : = array-new(m, ok); self.dists := array-new(m, ok); self.parent : = array-new(m, ok); self.edges : = arraya_new(m, m, ok); end b The addvertex method adds a new vertex to the view. Vertices are represented by white disks that lie in the ay plane. Above each vertex, we also show a green column of height d, provided that d is greater than 0. The location of the cylinder's base is constant, while its top is controlled by an animatable point property value. addvertex =&gt; meth(self,u,x,y,d) self.verts[ul : = DiskGO-New( ~X,Y,Ol I [0,0,11, 0.2); self.scene.add(self.verts[ul); if d &gt; 0 then let top = PointProp-NewSync(self.ah, [x,y self.dists[u] : = CylinderGO-New( [X,Y, 01 I top I 0.1); SurfaceGO-SetColor(self.dists[ul,"green" self.scene.add(self.dists[ul); The addEdge method adds an edge (represented by an arrow) from vertex U to vertex U. The arrow starts at the at the disk representing U , and ends at the column over v at height w.</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_11"><head></head><label></label><figDesc>,w) let a = DiskGO-GetCenter(self.verts[u]).get~); let b = DiskGO-GetCenter(self.verts[vl) .get(); let c = Point3-Plus(b,[O,O,wl); let d = Point3_Minus(c,a); let e = Point3-Minus(c,Point3_Scale(d,O.4) ) ; let grp = GroupGO-New(); grp.setProp(G0-Transform, grp . add (DiskGO-New (a, d, 0.1) ) ; grp.add(CylinderGO-New(a,e,O.l)) ; grp.add(DiskGO-New(e,d,0.2) ) ; grp.add(ConeGO-New(e,c,0.2) ) ; self .edges [ul [VI : = grp; self.scene.add(grp) ; TransformProp-NewSync(self.ah) ) ; end b</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_12"><head></head><label></label><figDesc>,z) SurfaceGO~SetColor(self.edges[ul [vI,"yellow"); let pv = GO-GetTransform(self.edges[ul [VI); p~.qetBeh().translate(O,O,z,0,2); self.ah.animate0; end I&gt; The method 1owerDist indicates that the "cost" D(u) of vertex U got lowered, by shrinking the green cylinder representing D(u). This is done by sending a 1inMoveTo</figDesc></figure>
<figure xmlns="http://www.tei-c.org/ns/1.0" xml:id="fig_13"><head></head><label></label><figDesc>lowerDist =&gt; meth(self,u,z) let pv = CylinderGO-GetPoint2(self.dists[ul); let p = pv.get ( ) ; pv.getBeh() .1inMoveTo([p[Ol, p[ll, 21, 0 , 2 ) ; self.ah.animate0; end b The method promoteEdge indicates that ( U , U), the edge that is currently highlighted, shall become part of the shortest-path tree. This is indicated by coloring the edge red. If there already was a red edge leading to U , it is removed from the view. promoteEdge =&gt; meth(self,u,v) SurfaceGO-SetColor (self .edges [U] [VI, "red") ; if self.parent[vl isnot ok then end ; self .parent [VI := U; self.demoteEdge(self.parent[vl,v); end D Finally, the method demoteEdge removes the edge (U, v ) from the view: demoteEdge =&gt; meth(self,u,v) end self.scene.remove(self.edges[ul [VI);</figDesc></figure>
		</body>
		<back>

			<div type="acknowledgement">
<div xmlns="http://www.tei-c.org/ns/1.0"><head n="7">Acknowledgments</head><p>We are grateful to Allan Heydon and Lucille Glassman for helping to improve the quality of the presentation.</p></div>
			</div>

			<div type="references">

				<listBibl>

<biblStruct xml:id="b0">
	<analytic>
		<title level="a" type="main">Zeus: A System for Algorithm Animation and Multi-View Editing</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Marc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Brown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Workshop on Visual Languages</title>
		<imprint>
			<date type="published" when="1991-10" />
			<biblScope unit="page" from="4" to="9" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b1">
	<analytic>
		<title level="a" type="main">The 1992 SRC Algorithm Animation Festival</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Marc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Brown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Visual Languages</title>
		<imprint>
			<date type="published" when="1993-08" />
			<biblScope unit="page" from="116" to="123" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b2">
	<analytic>
		<title level="a" type="main">The 1993 SRC Algorithm Animation Festival</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Marc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Brown</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Digital Equipment Corp</title>
		<imprint>
			<biblScope unit="volume">126</biblScope>
			<date type="published" when="1994" />
			<publisher>Systems Research Center</publisher>
		</imprint>
	</monogr>
	<note>Research Report</note>
</biblStruct>

<biblStruct xml:id="b3">
	<analytic>
		<title level="a" type="main">Color and Sound in Algorithm Animation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Marc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Hershberger</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer</title>
		<imprint>
			<biblScope unit="volume">25</biblScope>
			<biblScope unit="issue">12</biblScope>
			<biblScope unit="page" from="52" to="63" />
			<date type="published" when="1992" />
			<publisher>December</publisher>
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b4">
	<analytic>
		<title level="a" type="main">Algorithm Animation Using 3D Interactive Graphics</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Marc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Marc</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Najork</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACMSymposium on User Interface SofnYare and Technology</title>
		<imprint>
			<date type="published" when="1993-11" />
			<biblScope unit="page" from="93" to="100" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b5">
	<analytic>
		<title level="a" type="main">A System for Algorithm Animation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">H</forename><surname>Marc</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><surname>Brown</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Sedgewick</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Computer Graphics</title>
		<imprint>
			<biblScope unit="volume">18</biblScope>
			<biblScope unit="issue">3</biblScope>
			<biblScope unit="page" from="177" to="186" />
			<date type="published" when="1984-07" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b6">
	<analytic>
		<title level="a" type="main">Obliq: A language with distributed scope</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Luca</forename><surname>Cardelli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Digital Equipment Corp</title>
		<imprint>
			<biblScope unit="volume">122</biblScope>
			<date type="published" when="1994-04" />
			<publisher>Systems Research Center</publisher>
		</imprint>
	</monogr>
	<note>Research Report</note>
</biblStruct>

<biblStruct xml:id="b7">
	<analytic>
		<title level="a" type="main">Pavane: A System for Declarative Visualization of Concurrent Computations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Kenneth</forename><forename type="middle">C</forename><surname>Gruia-Catalin Roman</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><forename type="middle">Donald</forename><surname>Cox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Jerome</forename><forename type="middle">Y</forename><surname>Wilcox</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Plun</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Journal of Visual Languages and Computing</title>
		<imprint>
			<biblScope unit="volume">3</biblScope>
			<biblScope unit="issue">2</biblScope>
			<biblScope unit="page" from="161" to="193" />
			<date type="published" when="1992-06" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b8">
	<monogr>
		<title level="m" type="main">GASP-A System to Facilitate Animating Geometric Algorithms</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">David</forename><surname>Dobkin</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Ayellet</forename><surname>Tal</surname></persName>
		</author>
		<imprint>
			<date type="published" when="1994" />
		</imprint>
		<respStmt>
			<orgName>Department of Computer Science, Princeton University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b9">
	<analytic>
		<title level="a" type="main">A note on two problems in connexion with with graphs</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">E</forename><forename type="middle">W</forename><surname>Dijkstra</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Numerische Mathematik</title>
		<imprint>
			<biblScope unit="volume">1</biblScope>
			<biblScope unit="page" from="269" to="296" />
			<date type="published" when="1959" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b10">
	<analytic>
		<title level="a" type="main">Animated Graphical Interfaces Using Temporal Constraints</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Robert</forename><forename type="middle">A</forename><surname>Duisberg</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM CHI &apos;86 Con$ on Human Factors in Computing</title>
		<imprint>
			<date type="published" when="1986-04" />
			<biblScope unit="page" from="13" to="14" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b11">
	<analytic>
		<title level="a" type="main">A Turbo Environment for Producing Algorithm Animations</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Steven</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Glassman</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symp. on Visual Languages</title>
		<imprint>
			<date type="published" when="1993-08" />
			<biblScope unit="page" from="32" to="36" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b12">
	<analytic>
		<title/>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">S</forename><surname>Mark</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Greg</forename><surname>Manasse</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Nelson</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="j">Trestle Reference Manual. Research Report</title>
		<imprint>
			<biblScope unit="volume">68</biblScope>
			<date type="published" when="1991-12" />
			<publisher>Systems Research Center</publisher>
		</imprint>
	</monogr>
	<note>Digital Equipment Corp.</note>
</biblStruct>

<biblStruct xml:id="b13">
	<analytic>
		<title level="a" type="main">Three-Dimensional Computation Visualization</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">T</forename><surname>John</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Joseph</forename><forename type="middle">E</forename><surname>Stasko</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Wehrli</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">IEEE Symposium on Visual Languages</title>
		<imprint>
			<date type="published" when="1993-08" />
			<biblScope unit="page" from="100" to="107" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b14">
	<analytic>
		<title level="a" type="main">TANGO: A Framework and System for Algorithm Animation</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">John</forename><forename type="middle">T</forename><surname>Stasko</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">September</title>
		<imprint>
			<date type="published" when="1990" />
			<biblScope unit="volume">23</biblScope>
			<biblScope unit="page" from="27" to="39" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b15">
	<monogr>
		<title level="m" type="main">BAGS: The Brown Animation Generation System</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><forename type="middle">S</forename><surname>Strauss</surname></persName>
		</author>
		<idno>CS-88-22</idno>
		<imprint>
			<date type="published" when="1988-05" />
		</imprint>
		<respStmt>
			<orgName>Brown University</orgName>
		</respStmt>
	</monogr>
	<note type="report_type">Technical Report</note>
</biblStruct>

<biblStruct xml:id="b16">
	<monogr>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><forename type="middle">S</forename><surname>Strauss</surname></persName>
		</author>
		<title level="m">IRIS Inventor, a 3D Graphics Toolkit. OOPSLA&apos;93 Cont Proc</title>
		<imprint>
			<date type="published" when="1993-09" />
			<biblScope unit="page" from="192" to="200" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b17">
	<analytic>
		<title level="a" type="main">An Object-Oriented 3D Graphics Toolkit</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Paul</forename><forename type="middle">S</forename><surname>Strauss</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">Rikk</forename><surname>Carey</surname></persName>
		</author>
	</analytic>
	<monogr>
		<title level="m">ACM Computer Graphics (SZG-GRAPH &apos;92)</title>
		<imprint>
			<date type="published" when="1992-07" />
			<biblScope unit="page" from="341" to="349" />
		</imprint>
	</monogr>
</biblStruct>

<biblStruct xml:id="b18">
	<monogr>
		<title level="m" type="main">An Object-Oriented Framework for the Integration of Interactive Animation Techniques</title>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><forename type="first">C</forename><surname>Robert</surname></persName>
		</author>
		<author>
			<persName xmlns="http://www.tei-c.org/ns/1.0"><surname>Zeleznik</surname></persName>
		</author>
		<imprint/>
	</monogr>
</biblStruct>

<biblStruct xml:id="b19">
	<monogr>
		<title level="m">ACM ComputerGraphics(SIGGRAPH &apos;91)</title>
		<imprint>
			<date type="published" when="1991-07" />
			<biblScope unit="page" from="105" to="111" />
		</imprint>
	</monogr>
</biblStruct>

				</listBibl>
			</div>
		</back>
	</text>
</TEI>
